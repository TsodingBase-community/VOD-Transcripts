start,end,text
0,9520," Hello and welcome to another Zodian session. How about that? So today is Thursday, if I'm not"
9520,15360," mistaken, and today we're going to continue developing our programming language called Bang,"
15360,22080," which resides for some reason in a repo called BM. And this is because it's a build on top of"
22080,26800," the virtual machine called BM. You can find the source code of this thing in the description. And"
27360,32640," in the previous episode, we were working on compiling loops. So you can find the previous"
32640,39360," episode in the description. We successfully managed to implement the compilation of the while loop. And"
39360,45760," today we're going to work on something else. I suppose we're going to try to work on compiling"
45760,54080," procedures. Because right now we can only compile one single procedure, which is main. So since I'm"
54080,60320," trying to get the language to a usable state as quickly as possible, I'm taking a lot of shortcuts,"
60320,67760," and one of the shortcuts was that we can only have one procedure. So maybe today the time has come to"
67760,73520," finally get rid of that limitation. So let's take a look. Let's take a look at what we need to do in"
73520,80720," here. So I think I even have an issue for that, if I'm not mistaken. Does not support additional procedures."
80720,87120," Yes, it is a thing in here. It is a thing. It does not support additional procedures. So let's see what"
87120,92000," we can do about that. So do we need to fetch the other stuff? I don't think I need to fetch the other"
92000,98560," stuff. All right. So let's take a look at our example. So we have a very simple example in here,"
98560,104400," as you can see. It's a single procedure, because our language supports only single procedure. And it just"
104400,111600," like loops 10 times and prints. Hey, we can try to run this entire thing and see if it works exactly"
111600,118640," as it's supposed to work. And there you go. It seems to be working. It seems to be twerking. So if you try"
118640,127760," to add another procedure in here, for instance, something like proc foo, right, there we go. And then you try to"
127760,133280," write something inside foo, this will not compile. And it will produce a hilarious error message."
133280,141920," Bang does not support additional procedures. Only main. We are working on adding more procedures."
141920,148080," Stay tuned. So, and that's precisely the topic of today's session, right? That's precisely the topic"
148080,155280," of today's session. We're going to be adding more procedures. We're going to be adding more procedures."
155280,162560," That's actually quite, quite funny. So, yeah. And we can remove all of that. And if you try to run it"
162560,168880," one more time, it is working. It is twerking. So let's create a separate branch for this specific issue."
170800,179200," It's going to be for 415, right? And how are we going to be doing all of that? So I think we need"
179200,183520," to find a place where we're compiling all of this. So it should be located somewhere in the compiler."
183520,190080," Right. It has to be something like compile bang module, right? So this is where we compile the module."
190080,196560," Okay. So we're just iterating through all the top level definitions and top level definition"
196560,204320," is basically either variable definition or a procedure definition, right? So right now we only have two"
204320,210320," top level definitions. So if you encounter a variable definition, you just compile it as it is. If you"
210320,218240," encounter a procedure definition, you look if it's main, right? You look if it's main, then you set up the"
218240,225600," entry point for the Basm context and so on and so forth. And if it's not main, you throw that error message"
225600,230720," saying that we don't have more procedures, right? We also check for the redefinition of main. So yeah,"
230720,240320," yeah, yeah. So how would you? So here's an interesting thing. How would you generally, generally compile,"
240320,248960," compile a procedure, right? So let me see, let me see. So let's actually go to the drawing board. And let's"
248960,257600," imagine that you have a procedure Foo, yet again, right? Which basically writes Foo as before."
257600,266240," Well, first of all, you will probably generate some sort of a label, right? Indicating the procedure. And how"
266240,274720," do you usually enter a procedure and enter a procedure in BM, right? In BM, we have two instructions to for"
274720,282160," working with procedures. It's call and return, right? So we can even take a look at the definitions of"
282160,289120," those instructions in BM.c. So here is the definitions of all the instructions. We have 64 of them."
290000,295680," And if you take a look at the call, well, it's not class. Why do they type class? Call. There we go."
295680,302000," So it's an instruction that has a single operand, right? As you can see, it has an operand. And the"
302000,310160," operand type is an instruction address, right? As far as I know, it... Oh, and it also produces an instruction"
310160,317120," address output, right? So this is quite interesting. So it accepts instruction address as an operand,"
317120,323120," right? And also pushes on the stack another instruction address. All right, let's take a look"
323120,328320," what's going on in here. So if you have a particular procedure somewhere here, right? So here is the"
328320,334960," procedure. And then in BM, you call Foo. What is going on, right? Foo is an instruction address."
335520,342080," So what this function will do... Instruction, not function. It will take the address of the next"
342080,348560," instruction, right? It will take the address of the next instruction and push that thing onto the stack,"
348560,360880," right? All right. So red address. So it pushes onto the stack and jumps to here, right? So it remembers where"
360880,368320," it needs to return and jumps to the particular label, to the particular address rather. Then you execute"
368320,373600," the instructions of the address, and then you can use a return instruction to return back"
373600,382960," to the original location. So what return does... What return does... Yeah. It takes"
382960,390160," instruction address on the stack, right? It takes the instruction address on the stack and just jumps to it,"
390160,396320," consuming the instruction address, right? So usually a procedure in Basm, right? A procedure in Basm will"
396320,404240," look like this, right? Right. So you have a label that indicates the beginning of the procedure,"
404240,409520," right? Then you have an instructions, and then you have the return address, a return instruction to return"
409520,416080," back to the core. So yeah, that's basically how it looks like. And this is what we need to compile"
416080,422960," our procedure into. Right. So, but here's an interesting thing. Usually the entry point,"
422960,431120," the entry point procedure doesn't look like this, right? Usually when you have something like main,"
431120,437840," right? You have something like main, you have the instructions of the main, right? And then instead of"
437840,444560," return, you're supposed to put halt. And halt is a special instruction that holds the virtual machine."
444560,451040," So the reason why it is like that is that because there's nowhere to return. So the execution just"
451040,457920," starts from the main. And where does it return? It returns nowhere. So the only thing you can do after"
457920,463440," you're done executing your entire program is just hold the entire virtual machine. So essentially,"
463440,470400," we need to distinguish between a procedure that is a regular procedure that has to use return to return"
470400,477440," from itself, right? And also an entry point procedure that holds at the end. What's interesting is that"
477440,484480," there is more than this kind of differences between these kind of procedures, the entry point one and not"
484480,492000," entry point one. When you enter the procedure, you have the return address on the stack. And you also"
492000,498160," use the stack for other mathematical operations. So you constantly will have to keep track of,"
498160,502720," oh, okay, so I have a return address. I should not corrupt it and should not lose it. Otherwise,"
502720,510160," I won't be able to get back, right? And in the main, you don't need to do that because there's no way to return."
510160,516960," And so that you don't, because of that, you don't have to maintain the return address. So these become"
516960,524000," two completely different procedures that have to be compiled and handled differently throughout the whole"
524000,531680," like execution, which is kind of what makes it difficult to generalize just compilation of the"
532640,541920," of the procedures. I have the following idea. What if we make the main just a regular procedure, right?"
541920,549280," So it's going to be a regular procedure. And essentially, we're not going to set the entry point, the entry"
549280,557680," point to the main. We're actually going to generate a completely separate entry point that jumps to the main."
558480,563120," Right. So in that entry point is going to look like this, right? So it's going to be something like this."
563120,568480," If you program in bank, you will never actually define this entry point directly. What you will"
568480,574640," have to define, you will have to have to define the main procedure and the entry point will be generated"
574640,579200," for you by the compiler. And the entry point will look like this, right? So it's going to be entry."
579200,588240," And what you're doing here is you just call main. You just call main. And after main returns from its"
588240,597520," execution, you just hold. That's it. So that way, you can compile main as a regular procedure."
597520,603760," So you can just have a single procedure in the compiler and single process in the compiler that"
603760,609200," just compiles procedures and the procedures look the same. They all have the return address on the stack"
609200,615120," and they all end with the return using that return address. And the entry point just calls to that main"
615120,620880," function. And when main function returns, it just puts the whole thing here and it simplifies everything."
620880,622560," It simplifies everything. It's beautiful."
623120,632480," So as a matter of fact, that's precisely how C programs work on Linux specifically. On Linux, right, if you"
632480,642000," have a C program, right, if you have a C program that looks like this. Let's actually write a hello world."
642000,645280," This is going to be a hello world."
650560,655600," This is not how you do that. Okay. So this is going to be a slash n. And let's recompile this entire thing."
655600,662800," It's going to be all main main.c. Okay. I didn't want to return. I removed it. And there we go."
662800,667920," You have a hello world. So let's actually try to compile this entire thing with the debug information"
667920,674320," and see what's going on. There we go. We now have a debug information and I can do GDB on this entire thing."
674320,680160," And I'm going to break on main. I'm going to run it and let's take a look at what's going on. Okay."
680160,687600," So we are inside of the main procedure. If you take a look at the stack, it just shows me."
687600,699520," Okay. Thank you. What if I disable all of the optimizations? Will it work?"
700240,709680," Or is that how the debug information usually generated, right? If I take a look at the T? Apparently it doesn't show that."
709680,717760," Apparently it doesn't show that. But the point is, as far as I know, GCC and maybe other compilers first generate"
719680,729840," a start function, right? A start function, which already calls a main function, right? Which already calls main function."
729840,739840," And after main function has finished executing, it just calls the exit syscall of Linux and it's actually kind of similar to what we're trying to do with our virtual machine."
739840,747280," So Linux start. Why does the user start in C?"
747280,750000," Yeah. So people talking about it. It is a thing."
753440,761360," Oh yeah. So you can actually define this thing yourself, right? You can define this thing yourself, but you have to do no start files."
761360,769440," Symbol starts is an entry point of your program. That is the address of the symbol is the address jump to on program start."
769920,776800," Normally the function with the name underscore start is supplied by the file call CRT zero. Yeah, I remember that. Which contains the startup code, blah, blah, blah."
776800,782160," It populates argv and then it calls main and then it calls exit."
782160,790480," Right. If the program does not want to use CRT, you can use start. The thing about the exit, by the way, is that if you don't call exit syscall,"
790480,796400," your program is not going to finish correctly. It's just not going to finish correctly."
796400,804400," Basically, the program cannot just stop executing. It needs to tell an operating system that it's done executing."
804400,809520," So operating system can unload it from the memory. And that's what exit syscall is usually used for."
809520,815200," And it's precisely our case, right? It's precisely our case with the virtual machine, right?"
815200,820640," Our virtual machine cannot just stop executing. It always keeps executing the next and next instruction."
820640,828640," So what it needs to have, it needs to have a special instruction that tells the environment or the virtual machine itself that I'm done executing."
828640,834640," That's it. Stop me. I'm loaded from memory. Full stop. Right. And that's actually kind of a similar situation."
834640,841440," It's actually kind of a similar situation. So we can actually try to do that. I kind of want to try to compile this example."
841440,845600," put gcc no start files and just, you know, see what's going to happen. It's kind of interesting."
845600,849120," All right. So I have main.c."
849120,855280," Oh yeah. So if I try to just define something like this, right?"
855280,863280," Will that even work? So it's going to be gcc no start, no start files."
863440,871440," Okay. So what we will see implicit declaration of main. So that's probably means that I need to put start below the main."
871440,880320," So what else do we have in here? Exit. Implicit declaration of exit. I think exit is located somewhere in lib, stdlib."
880320,886160," And it worked actually. It actually worked. That's kind of interesting."
886160,895200," So if I try to execute this entire thing, it is working correctly. So here's the interesting thing. What if I don't do exit?"
895200,898480," What if I don't? Who knows what's going to happen?"
898480,901920," It will set fault."
901920,906720," Why did it set fault?"
906720,909040," Why did it set fault?"
910960,918720," Well, because I suppose gcc compiled this as a regular procedure, since it's applied as a regular procedure,"
918720,926560," and the regular procedure ends with the return, right? But again, there is no place to return to, right?"
926560,934320," So it either tried to return to some garbage, right? To some garbage address and it hit unmapped memory and"
934320,938640," the operating system said, no, no, no, you can do that and kill the program completely."
939200,946720," Or it actually continue executing after this procedure. It just depends on what exactly got"
946720,953680," generated. So if you program in assembly for Linux and you don't call the exit syscall, your program will"
953680,958080," essentially continue executing until it hits the memory that you're not supposed to touch or not"
958080,962480," supposed to execute. The operating system will just kill you with the sec fault, right? That's why you need"
962480,968480," to call this exit. And usually you don't have to worry about it because this kind of code is generated for"
968480,974160," you by the compiler, right? So it's generated for you by the compiler and you don't worry about this kind"
974160,979040," of stuff. And that's precisely what I want to implement today, right? So we're going to just have"
979040,985360," a single way of compiling procedures. And then at the end of all of the compilation, we're going to generate"
985360,994480," a very small little entry point that is going to basically set up the main call and then hold the machine"
994480,1004480," and so on and so forth. So, uh, yeah, so I'm just thinking, should I put any, um, like this thing into"
1004480,1011040," the description? I guess, um, I guess I'm going to put it in the description just in case. Okay. So,"
1011040,1020480," you can find this thing in the description if you're interested in this kind of stuff."
1020480,1028000," Uh, so let's get started, I suppose, but before we get started, I think I want to make a cup of tea. I"
1028000,1034400," forgot to do to make a cup of tea right before the stream. So let me quickly do that. Um, all right,"
1034400,1044640," I'm back. Uh, let's freaking do this. What the fuck was that? Uh, so let's take a look at the"
1044640,1053040," library bank compiler and we'll probably have a procedure called compile bank proc, right? Here it"
1053040,1060400," is compile bank proc. Uh, compile bank proc. Where?"
1060400,1070160," Proc def. Okay. We're compiling proc definition. Um, and essentially after we compile the proc definition,"
1070160,1076720," what we're doing is, um, yeah, we're returning the address and that address could be used to"
1076720,1081760," set up the entry points, right? Oh yeah. That's precisely what we're doing. So we're returning the"
1081760,1088320," address where it starts and, uh, there we go. Everyone is happy. So essentially after this"
1088320,1094240," entire thing, what I want to do is I want to do bosom, push instruction, right? Push instruction,"
1094240,1105040," bosom. And the instruction is essentially going to be, um, the instruction is essentially going to be"
1105040,1111440," inst return, but I have a like slight fear that it may not work properly."
1112320,1114720," Uh, it just depends on what"
1114720,1123360," is usually going on. Hmm. This one is going to be very interesting. This one is going to be very"
1123360,1130320," interesting. So it's like, depends on the return type of the expression, because if you have, uh,"
1130320,1136880," uh, something like this, right, if you have a procedure bar, uh, that have something like this"
1136880,1142800," on the stack, uh, this in the, in the expressions, it will push this thing onto the stack,"
1143600,1151440," but then that is it. Then that is it. And, uh, because of that, the return address will not be,"
1155360,1162400," will not be in the correct place, right? So the number just compiles to, uh, push zero, right?"
1162400,1167600," And that actually, uh, basically shadows the return address. So I was thinking about the word,"
1167600,1173440," I think word shadow is actually a pretty good word for that. So essentially we need to look at the"
1173440,1179920," actual value of the expressions. When we compile expressions as statements, right? When we compile"
1179920,1185920," expressions as statements, we need to look at whether they return something. And if they return something"
1185920,1192400," and we don't assign that to anything else, we have to drop it. So we still have the return address on the"
1192400,1199120," top of the stack. So, and the question is, how do, can we even determine that? I guess that should only"
1199120,1205200," happen when we are compiling the expression as a statement, right? So let me try to find that. So it's"
1205200,1215440," going to be bang, uh, compile, um, compile bank statement. Uh, do you even have statements,"
1215440,1224640," uh, compile bank statement, STMT? Yeah. Compile statement into bosom. There we go. So if doesn't"
1224640,1230320," return anything, variable assignment doesn't return anything while doesn't return anything. Uh, the only"
1230320,1235120," thing that may potentially return something, the only thing that may potentially return something,"
1235120,1242880," is expression, is expression, but it just depends. It just depends, uh, right? Because this returns"
1242880,1254320," something right, uh, hello, right? It does not return anything. So how can we even approach that? How can we"
1254320,1265040," even approach that? So, uh, obviously in here, right? Obviously in here, uh, if we know for a fact that"
1265040,1272800," if the expression is not void, right, if the expression is not void, we have to add, uh, something like"
1272800,1282000," basm, uh, push instruction, uh, basm instruction drop. And of course, this thing doesn't really accept any operands,"
1282000,1294960," so it can be set like that. But, uh, if is void. Wait,"
1294960,1303840," I thought I just typed void and it can commit in the void count. Okay, whatever. Uh, how can we know"
1303840,1310800," all of that? How can we know all of that? We can ask the compile bang expression into bosom whether"
1310800,1317920," it returns a void expression or not, right? Um, but it's more of a like a type checking at this point,"
1317920,1321280," right? So it's more of a type checking at this point. Um,"
1321280,1329440," so can we introduce the types of the expression?"
1329440,1339280," Maybe it's time to introduce like yet another type called void or unit or something like that"
1342080,1346320," to indicate an expressions that don't have anything, that don't return anything."
1346320,1351040," Or maybe all of the expressions have to return something, but then what about functions that"
1351040,1357280," should not return anything, right? So yeah, you, you need some sort of a unit type to indicate that,"
1357280,1361520," uh, you don't return anything. And so you don't need to add the drop at the end of the statement."
1362160,1364320," Um, so you definitely need that."
1364320,1370560," So, okay. Uh, I think this looks like a pretty straightforward way of doing that,"
1370560,1374720," but it feels like it has to be handled on the level of a type system, but we don't really have a"
1374720,1383200," type system at all, right? We have a notion of a type, but it's not really used properly as like as a type system thing."
1384240,1392480," So is void, um, right. It's going to be false. This one has to be not is void. Uh,"
1392480,1398400," and we're going to pass is void here as this thing, right? So, uh, let me see what we're going to have in"
1398400,1408080," here. Um, so this thing is going to accept boolean, uh, is void. So of course this entire thing is temporary,"
1408080,1412800," right? This entire thing is temporary. Uh, and eventually we're going to get rid of this entire stuff,"
1412800,1417200," uh, and it's going to be handled in the level of like, like a type system. Uh,"
1417200,1424880," so bank expression into bosom. So, and yeah, we need to replace this thing and there we go."
1424880,1434240," Okay. Uh, so I know for a fact, right. I know for a fact, uh, that"
1434240,1442640," string literals are not void, right? And we're also going to do the following thing. If"
1442640,1447600," you don't care about the expression being void or not void, you can set it to null,"
1447600,1452480," and we're going to just be doing it like that. Right. Uh, okay. So we have a couple of hardcoded"
1452480,1459680," functions. So write function is void. Uh, so I'm going to set it to true. Right. There we go. So"
1459680,1469840," booleans is, uh, obviously, uh, they're obviously not void. Uh, all of that stuff is not void. I might as"
1469840,1476560," well actually keep copy pasting this stuff. Variable read is not void for sure. Binary operation is not"
1476560,1484240," void. Uh, so the only thing in here essentially that is void is of right. Right. And as we, uh,"
1484240,1492960," as we actually go into supporting procedures and stuff like that, uh, we're going to actually have more"
1494080,1498880," action going on is here in here, right? You see, right. It's sort of like an intrinsic,"
1498880,1504160," right? It's a function that exists in the compiler, but was not defined in the source code anywhere."
1504160,1510560," It's hard coded in the compiler itself and it returns void. And then we're going to have a custom user"
1510560,1518160," functions, um, custom user functions, and they also could be void or not void. So this kind of information"
1518160,1524800," will, um, will, um, will be useful to return from here. Um, okay. So let's actually try to compile this"
1524800,1530480," entire thing and see how it goes. Uh, this is not how we compile. Um, how do you compile? We need to"
1530480,1539440," use the no build system. Uh, I'm going to be doing this test. There we go. Okay. So in here, when I combine"
1539440,1552240," binary operations, I, oh, that's interesting. That is actually very interesting. So I, I do kind of care"
1552960,1567040," whether it's void or not. Um, because if it's void, I cannot, yeah, it's, it wants to turn into a type"
1567040,1574400," system. This thing wants to turn into a type system. Get fucking damn it. Okay. Do I need to introduce"
1574400,1581440," like a proper type system so early on? Do I really need to do that just to be able to know whether I"
1581440,1586640," want to drop a value from the stack and not to drop the value from the stack? Maybe, maybe that's"
1586640,1591600," precisely what I need to do. Um, because this thing wants to be a type system. Yeah. As you can see"
1591600,1596560," here, I already want to do type checking and shit like that. And it's just like, yeah, yeah, yeah."
1596560,1602880," You want, you want to, you want a type system. Okay. So let me see what we can do about the type system."
1602880,1609600," Sometimes like, um, code just wants to go its own way and there's like nothing you can do about that."
1609600,1616320," The code wants a type system. Very well, very well then. Uh, so let me see, let me see. So where do"
1616320,1622400," we have a types? I think we have types defined somewhere in Farsa. So there was a bank type and"
1622400,1630960," it's defined in here. There you go. So we have a bank type and the only type in here we have is, uh,"
1630960,1638320," I64. Right. That's the only type we have in here. So let's introduce the void type or the bottom type"
1638320,1644320," or like unit type. So different languages actually call it differently. So in C-like programming languages,"
1644320,1650560," it's void. I remember that in Scala it was called unit type. Uh, I programmed in Scala a long time ago."
1650560,1658480," Oh my God. It's a pretty interesting language. Um, but unfortunately it's built on top of JVM."
1658480,1667520," So it's slow as fuck. Unit is a subtype of any val. Uh, there's only one value of unit, which is like"
1667520,1672720," nothing like, you know, parentheses. And it's only represented by any object in the underlying runtime"
1672720,1680320," system in Haskell. Such type is called literally parentheses. And I don't even know if it has any name."
1680320,1682240," Uh, maybe it does."
1682240,1688320," Yes. Let's wait for DHCI. It's, it's very slow on my machine for some reason."
1688320,1692640," Yeah. This is the, this is the type. This is the thing in here."
1692640,1698560," Um, it's defined in tuples. Maybe it's considered like an empty tuple."
1699200,1705600," Yeah. It only has, uh, the only value in here. So anyway, um, we need to define something."
1705600,1712560," I kind of like the name unit. Um, could be also nothing."
1712560,1719440," Oh, in, in Scala it's called unit because there's only one single value of that thing."
1719440,1724400," All right. So, uh, we're not going to have a value for this thing. We're going to just call it void."
1724400,1728560," Uh, and let's see how it goes. So we're going to have a void in here."
1728560,1733760," I wonder if me adding this, uh, new innovation will break, uh, some code."
1733760,1738080," I, I speak a very weird English. I'm sorry."
1738080,1745760," Also, I think I need to remove this, uh, is void, uh, bullshits that I added to make it properly"
1745760,1747760," compiled because right now it's not going to properly compile."
1747760,1752640," All right. So it, uh, threw a warning in, in here somewhere, right?"
1753120,1759840," So bank size of type, huh? That is very interesting. So why do you need this kind of thing? Uh, what's"
1759840,1769280," the size of this stuff? So we use it to push it into the address. So, uh, oh yeah. If you define a"
1769280,1776720," variable of void, yeah, it, it needs to know the size of the type to actually push it in there. And what's"
1776720,1783440," going to be the size of the void? That's a pretty good question. What's going to be the size of the void?"
1783440,1789760," Uh, by the way, what's the size of the void in C? Is it like one or something? I, I don't know. I don't"
1789760,1796720," program in C. I'm not a C programmer, right? I'm a Scala programmer. Believe it or not, I actually"
1797600,1803040," more of a Scala programmer than a C programmer. I actually worked on commercial projects in Scala"
1803040,1809680," that were deployed in production. Um, and they probably still work there. Uh, but I never did"
1809680,1816560," anything like that with C. So at least with Scala, I have like an actual commercial experience."
1816560,1826640," So yeah, I'm not a C programmer. Like I never actually wrote a commercial thing in C. In C++ though,"
1826640,1834560," I did, but I'm not, I'm not in PFC. Um, okay. So let me see. Haha. So it's going to be ZU and, uh, um,"
1834560,1844960," it's going to be size of void. And let's see what's going to happen. GCC main main dot C main main,"
1844960,1856880," and it's one interesting. Hmm. Hmm. Hmm. C size of void. I vaguely remember something about, uh, void."
1856880,1866640," Uh, what is the size of void? Uh, the point has no size. That will be compilation error for the same reason."
1866640,1872800," You can't do something. Uh, to my surprise doing several actually does compile in Gnucy. I can,"
1872800,1875520," we can actually do a pedantic. I think we can do a pedantic."
1875520,1885840," Oh yeah. So yeah. Uh, invalid application of size, but it failed not because of the pedantic,"
1885840,1890320," but maybe pedantic enabled some of these flags in here. So it's not a valid thing per se."
1891040,1904240," Uh, so what about C++? Uh, what about CPP? ICPP? OMIP? Ah, funny, funny. Okay. So what do we have?"
1904240,1910240," Uh, invalid. I mean, it's, it's also third warning anyway. So I think it's not that big of a deal."
1910240,1912800," I think it is not that big of a deal because"
1914800,1923840," um, we can throw a compilation error when you're trying to define a variable with the, um, void,"
1923840,1932000," with the void type. So this is one of the things we can do. Uh, let me see what we can do in here. So,"
1932000,1938240," uh, bank size, uh, all right, all right, all right. So you're trying to do, uh, type. So we're checking"
1938240,1943600," whether the variable already exists and then, uh, we can check the following thing. Maybe it would make"
1943600,1951600," sense to actually check the type first. If var definition type is equal, uh, bang type void,"
1951600,1956320," we already going to throw an error without even checking whether this variable exists or not,"
1956320,1961280," because that's already incorrect regardless of whether it exists or not. So we want to fail as"
1961280,1972160," soon as possible, fail fast. Okay. So bang, log, fmt, uh, error, um, variable,"
1972160,1977040," let's see, fmt. So this is the name. Um, okay."
1977040,1990320," Defining, defining, um, variables with type, uh, and we're going to provide this thing. Is there any way to"
1990320,2001040," get the name of the type? Um, is not allowed. Um, is not allowed. Yeah. At least right now. I'm not sure"
2001040,2007280," if it's going to be allowed in the future, but we'll see. We'll see. Bank log arg and what's going to be"
2007280,2014800," the arg in here is going to be var def location. And now I need to know how to get the name of the type."
2016080,2022960," So it's located somewhere in a pasta. And do we have like, like a really name of the type? So we have"
2022960,2032960," bank type, you have a procedure bank, uh, like parse bank type. So let me see parse bank type. There we go."
2032960,2039920," Okay. So it's simply expects, uh, okay. So everything is completely hard coded in here. Uh, so we need to"
2039920,2046320," introduce the, uh, you know, static assert system, which knows the amount of types you have in there."
2046320,2050480," And then if you modify the amount of times, it will break in a bunch of places. So I actually"
2050480,2056880," didn't introduce this kind of thing for the types. So let's do something with this count bang, uh, types."
2056880,2061360," Right. So right now we're going to only have like two, two types, the two time champion"
2062080,2068720," of the, of the type system. Um, so it's I64 and void to be fair in our virtual machine,"
2068720,2071680," you probably don't need anything else. Right."
2071680,2080800," And the funny thing about the void type is the, is the only purpose of void type is to know whether"
2080800,2087680," you want to drop the result of the expression compiled as a statement or not. All right. So"
2087680,2093120," if it's void, you don't have to drop anything. If you have expression, which is used as a statement,"
2093120,2097600," uh, you want to drop the result value. So that's the only purpose of this entire thing,"
2097600,2103680," which is quite interesting, which I would never actually guess that's why void would be needed for,"
2103680,2108400," unless I actually try to implement a programming language. So it's actually very educational experience"
2108400,2114480," for me right now. Right. I just like literally learned a thing in 35 minutes, but that's how"
2114480,2119360," I learned things, by the way, I just do the thing and I just encounter some problems and, and I'd be like,"
2119360,2124720," oh, okay, that makes sense. And again, I know nothing about language development. Uh, I went to a pretty"
2124720,2131520," shitty university that didn't have a programming programming language course. Uh, I, yeah, so I know"
2131520,2136640," nothing about this kind of stuff. So a lot of these things are just like really new for me. And that's"
2136640,2144720," pretty cool. That's pretty cool. I really enjoy that. Okay. Hmm. So we probably want to introduce some"
2144720,2153920," functions, um, something like void, actually not void, but bang type name is going to accept bang type"
2153920,2162000," and it will return your name. And then you can, uh, even iterate, uh, through all of the types and all"
2162000,2168880," their names and that's how you can parse things. I think that's one way to do that. So let's quickly"
2168880,2173600," implement this function and see what's going to happen. So I'm going to put it in here somewhere."
2173600,2182320," Uh, and it would be the easiest thing to do here is to add a global table somewhere, static global table,"
2182320,2189040," const, const, const, const, and bang type names, right? You have a bunch of names and this entire thing is"
2189040,2195200," going to be just an array. Uh, uh, like this. Okay, you go."
2195200,2207280," Okay, you go. So this one is going to be, uh, I 64, right? And this one is going to be, I guess, just void."
2208160,2217440," Uh, I guess just void. All right. So, and of course in here we're going to do static assert, uh, count bang"
2217440,2225840," types, um, is expected to be equal to two. Um, the amount, uh, okay, let's actually put this thing like this."
2228800,2241280," The amount of types have changed. Uh, please update the type name table accordingly. Uh, thanks. Let's be"
2241280,2246000," polite. Let's be polite. All right. So we're going to do in here. So in here, we're going to actually"
2246000,2253280," basically query this, um, this type name. Um, but on top of that, we're going to also perform a range check"
2253280,2258640," because the C is unsafe language. So it doesn't automatically generate, uh, you know, range"
2258640,2262880," checks for you. You have to write them yourself. We're going to write them with assert. So type has"
2262880,2270960," to be actually greater than zero or equal than zero or, uh, less than the count bank types. And once we"
2270960,2278560," check everything in here, we're going to do bank type names, uh, type. There we go. And so that way we can"
2278560,2289840," do those things. All right. So, uh, how do we parse, uh, bank name, um, parse is actually, is it compile?"
2289840,2294560," Why did they put that in the compiler? Wait a second. Why did they put that in the compiler?"
2294560,2300240," I guess it does make sense to put it in the compiler, right?"
2303680,2308560," I guess it does. Okay. So that means I need to go to the parser and, uh, yeah, yeah. So this is"
2308560,2316240," basically what I have to do in here. Bank type type equal to zero type less than count bank, uh,"
2316240,2324000," bank types plus plus type. So I'm iterating through all of the types. And if I find,"
2324000,2330160," so it basically expects the token, right? So, but one of the things we can do in here is just basically"
2330160,2340560," expect, uh, a token, uh, of a particular kind. So bank token kind name. So we're expecting the name"
2340560,2345920," in here. This is the going to be the token. Uh, there we go. And then we're going to take a look"
2345920,2355360," at the text of the token, token text, uh, SV equal, uh, and we're going to try to compare it to the bank type"
2356160,2363040," name, right? And we just provide the, the type that we got in here, but the thing is this returns C string"
2363040,2369600," and we need to convert it to SV. So I think it's something like SV from, uh, sister, right? SV from"
2369600,2376880," sister. And if we found the thing that is equal to this kind of stuff, we're going to, um, return that"
2376880,2384320," type. So we are returning that type right away. So if we didn't, uh, find any types in here, if the name"
2384320,2391440," represented like incorrect type, we can throw an error in here, uh, F print F STD error, bang,"
2391440,2399840," lock, FMT, and it's going to be error, uh, invalid, uh, invalid type. And it's going to be something like"
2400800,2413680," uh, S, well, I mean, it's, it has to be SF, SFMT, uh, all right, uh, is going to be bang lock arg."
2413680,2422800," And we're going to use the location of the token, uh, and then for the actual naming here, we're going to use"
2422800,2428080," the text of the token, right? Okay. So we reported everything correctly and then we're going to just"
2428080,2437360," exit with one. There we go. Uh, do we have anything else? Uh, let's try to do no build test. Is it going"
2437360,2443440," to work? Is it going to work now? Yo, no, it doesn't work. So switch type. Okay. So we didn't handle all"
2443440,2456640," of the situations. So let's do case. To be fair, so maybe, maybe, uh, our code should be organized so"
2456640,2463920," you never try to call void on, um, like size of on a void."
2467280,2473440," But you technically will be able to, if our language is going to have size of construction,"
2473440,2479120," right? If it's going to have a size of construction, you will inevitably, inevitably will try to call"
2479120,2487040," size of this thing. Uh, but in that case, you will have to report an error. You'll have to report an"
2487040,2492400," error, uh, saying that you cannot do that and you need to know the location of where that happened."
2492400,2497120," And this function doesn't know the location. So it's going to be the responsibility of the function"
2497120,2504080," that calls this function to actually check whether you're not trying to put a void in here. Okay."
2504080,2518960," That's a good point. Uh, so, um, let's put something like this, uh, void type void does not have, uh, a size,"
2518960,2526880," right? So bang size of a type, um, unreachable type, uh,"
2526960,2531200," void does not have a size. So this is how we're going to actually approach that. So I could have"
2531200,2536320," just redirected to unreachable, right? But I'm, uh, I think I want to actually handle this case"
2536320,2542640," specifically and tell, uh, the developer of the compiler that, well, you should never call this"
2542640,2549520," function on void. And before doing that, before trying to call size of a particular, uh, size of"
2549520,2555040," a particular type, just check that this type is not a void. Uh, at least this is going to be the policy"
2555040,2559600," for now. We'll see how it goes. And also maybe I think I want to do something like count bank types,"
2559600,2568560," uh, right? Because this thing is also unreachable. All right. So, uh, let's see what else do we have in"
2568560,2576560," here? Okay. So here is the stuff and I did a fokey walkie. Oopsie doopsie. And I wonder where exactly I did"
2576560,2585280," that. So this is a log fmt and I also have to provide the type, right? Um, okay. Compile var definition"
2585280,2589360," defined variables with the type is not allowed. And that's precisely what I wanted to do in here."
2589360,2596960," So bang type, uh, name, uh, actually name, um, and it's going to be var def type."
2596960,2606080," Uh, maybe I have to do something like this bang type to be fair. Yeah. I think this is going to be"
2606080,2612800," easy because I, at any point I can actually add more things in here. Right. And then I won't have to"
2612800,2618640," modify anything in here. Okay. So that makes sense. Uh, all right. So let me try to compile this entire"
2618640,2625760," thing and see what's going to happen. All right. Everything's compiling. That's nice. Okay. Uh,"
2625760,2629920," let me see what's going to happen in the runtime. So if I try to run the example,"
2629920,2638400," so it's going to be examples, let's recompile the examples. Uh, okay. And if I run, uh, while bang,"
2639120,2645120," while bang ran successfully. So I want to try a couple of things now. Uh, I want to open while bang."
2645120,2650320," And for instance, I want to define a variable with the type of void. What's going to happen? Is it"
2650320,2657760," going to complain? Uh, define variables with that void is not allowed. Perfect. Cat theme. Perfect. My God."
2657760,2663280," All right. So now we also probably want to do something, um,"
2665440,2672560," type checkish. If you know what I mean, maybe when one, once you try to compile an expression,"
2672560,2678480," right, once you try to compile an expression, we're going to return the type of the expression."
2678480,2685600," So then this kind of stuff could be used to know whether you need to drop the value in the statement"
2685600,2690240," or not. So, uh, let me take a look. If I take a look at the compiler dot H,"
2690240,2700160," so where is the expression? So bang expression, it returns instruction address, right? It returns its"
2700160,2708720," instruction address. Uh, and it is needed to actually facilitate compilation properly. So, but we also need to"
2708720,2716080," return, we also need to return the type of that expression, right? We also need to return the type"
2716080,2721600," of that expression. And the question is how are we going to return that? We can, we can return, um,"
2721600,2729120," the type of the expression like this, right? But it's probably not going to be super convenient."
2729920,2738560," What if we introduce like a new entity, something like struct, uh, compiled expression, right? And the"
2738560,2747440," compiled expression is going to have instruction address, like where exactly it starts and, uh, its type,"
2747440,2756000," right? So there we go. Um, yeah, sounds very interesting. So maybe that's going to be the way to go."
2756560,2762480," Um, so let's go. Let's remove this thing. And this thing is going to return compiled expression."
2762480,2768320," Maybe in the future, compiled expression is going to have like more information about self. For instance,"
2768320,2774960," like the size of instructions, we only know where the expression begins, but we don't know where it ends."
2774960,2779760," Maybe that's going to be useful in the future. Who knows, right? So basically compiled expression is"
2779760,2786000," like a chunk of code, right? It's a chunk of code and its type, right? And yeah, that's pretty much it."
2786560,2799840," So what's interesting about compiled expression. If we knew its size, uh, if we knew its size,"
2799840,2809120," we could probably, uh, try to simulate the instructions and see if it leaves any values on the stack. But I"
2809120,2813200," don't think it's actually feasible in our case. So I'm going to, I'm just going to keep it like that."
2813200,2820960," Um, so, and what's interesting is that compiled proc div here could actually return compiled proc."
2820960,2825760," Um, who knows, maybe, maybe that's going to be useful in the future, but for now, I'm going to just keep it"
2825760,2832080," like that. Uh, all right. So here, maybe we're going to have some sort of constructors for compiled"
2832080,2838560," expressions. So it's a little bit easier to, to make, uh, compiled expert is going to accept instruction"
2838560,2846960," address and bang, type, type. And there we go. So we're going to go to here. Uh, there we go. And"
2846960,2856000," might as well just return compiled expression, uh, address, address. And this one is going to be"
2856000,2861680," type. There we go. Uh, here's the compiled expression. Okay. Let's actually go to the compilation errors and fix"
2861680,2872720," everything. Uh, yes. So this one is supposed to return the compiled expression, right? Compiled expression."
2872720,2884400," All right. Hmm. This one is interesting. So it actually kind of implies that I don't need the,"
2886800,2894240," Oh yeah. Uh, I don't need the constructor so I can just do compiled expression, uh, and I can zero"
2894240,2900320," initialize it, right? Just zero initialize it. And then the result address is going to be something"
2900320,2910960," like this. Right. Uh, and what do we have in here? So this is a, uh, string literal. This is the string address."
2912560,2918800," Um, all right. And I suppose the type of the string address right now is going to be"
2918800,2925920," bank type, uh, i64, right? For now it's going to be just i64 because it's a pointer or whatnot."
2925920,2932640," Um, this one is interesting. This one is interesting because in this case, uh, this is a type of void."
2932640,2938560," It's kind of the code I'm writing right now. It's kind of similar to, you know, the Boolean is void"
2938560,2944960," thingy. And that's precisely why I got the hint that I need like a proper type system because that's"
2944960,2951200," what it wants to be because I end up writing like the same code anyway. Right. Uh, so here's the type."
2951200,2958320," So it's going to be this, uh, and for the Boolean, but the Boolean, I'm not sure. Um, so you know what,"
2958320,2965520," uh, I think I'm going to do it to do in here, uh, not here rather, but, uh, something like this, uh,"
2965520,2979440," strings don't have, uh, I dunno, a separate, a separate, separate type. The strings don't have a separate type."
2980000,2991840," Um, here we have i64, uh, and this is another thing. Um, Booleans don't have a separate, uh, type in bang."
2991840,3003440," Right. So it's actually clarified in bang. Okay. Uh, and when you have, uh, this thing is going to be that, um,"
3005200,3013280," variable read, by the way, I think it has to be void binary operation is rather interesting. So I suppose,"
3013280,3021120," I think binary operation should return its site, its type, right? So it's going to be a result type equal, uh,"
3021120,3028960," compile binary or P into bosom. So that's how it would have to work in my opinion. All right. Uh, okay."
3028960,3035200," So we already starting to establish like a very simple, uh, static type system, which is kind of"
3035200,3040320," cool, but the compile binary or P into bosom doesn't return anything. Let's actually make it return bang"
3040320,3047360," type, uh, maybe in the future is going to return a compiled expression. Um, I don't know, but for now"
3047360,3054800," it's totally fine to have these things, I think. So, uh, what we're doing in here, we're just compiling,"
3054800,3064000," um, compiling left hand side and right hand side. So maybe the thing I can do in here is just compiled"
3064000,3075680," expression, compiled LHS, right? So here's a compiled LHS. And then in here, we're going to have a compiled"
3075680,3084880," RHS, right? So we compile them both together and, um, I just summed them up, but before I will try to"
3084880,3092960," sum them up, what I'm thinking is we can actually compare their types, right? First of all, uh, we can"
3092960,3100800," check if the LHS is not equal to bank type I64, we're going to throw an error about that. So essentially for"
3100800,3108480," now we're going to support like this binary operations for I64th and nothing else. Yeah. I think"
3108480,3113440," later we can actually extend all that. All right. If it's not equal to that, we're going to throw an"
3113440,3122320," error. Uh, so it's going to be std error, uh, bang log fmt. It's going to be error. And what we're going to say in"
3122320,3144240," here, um, so we can say that plus is, um, let's do it like this, uh, is only supported, uh, for, uh, for type."
3145760,3151040," Yeah. Uh, so we're going to say that plus is only supported for this kind of thing."
3151040,3164080," So, uh, what we're going to have in here is going to be bang log arg, bang log arg compiled. Um, so I need"
3164080,3174000," to do binary, binary op lhs and I need to extract the location of this thing, right? I need to extract"
3174000,3180640," the location of this expression. And I'm a little bit worried that expressions right now don't have a"
3180640,3192400," location. So it will be kind of sad. Um, because then I won't be able to actually properly report things,"
3192400,3200400," unfortunately. All right, let's make a small break. And, um, after the break, we're going to continue"
3200400,3210640," developing this thing. I'm back. So what do we have in here? Uh, so we need to check whether the type is"
3210640,3218960," the expected type and we only support binary operations for I64 and nothing else. So, uh, I want to actually"
3218960,3225280," keep the error message generic and actually extract the corresponding names, um, because it's going to be"
3225280,3231200," more readable and more portable, more copy pasteable, right? So the, the, the highly reusable code is the"
3231200,3238400," one that you can copy paste, right? Uh, it's not the one that is super generic, right? And huge with a lot"
3238400,3242960," of interfaces. No, no, no, no. The actually reusable code is the one that you can copy paste to a different"
3242960,3251760," place and adapted to your situation. That's actually reusable code. So anyway, uh, as long as support for,"
3251760,3258000," for, for, for the type. Okay. So, uh, we need to have an ability to convert a binary operation into,"
3258000,3268400," um, into a name. Um, and I think I know how to do that, right? Do we have a table, uh, for binary operations and"
3268400,3274000," their association with tokens? I think we had something like that. If I remember correctly,"
3274000,3278880," I think we had something like that. So we can basically take a binary operation, map it to its"
3278880,3284480," corresponding token, and then we can convert token to the name of the token and use it as the name of the"
3284480,3290720," operation. That's actually super cool. Uh, so, but I need to know where all of that is located. Um, so,"
3292000,3300320," so I think we defined the binary operation somewhere here. So it's a binary OP, uh, OP kind, something"
3300320,3308800," like this. So that means in the past, uh, we should have something like, uh, yep. Binary OP tokens. Yes."
3308800,3317040," Binary OP tokens, but the only available, uh, they're only available inside of this translation need. And I'm"
3317040,3327040," thinking what can we do in here? Can we just like, oh, I don't know, make it public. Is that a thing you"
3327040,3334240," can do with the arrays in C? But again, it's actually kind of dangerous, right? Uh, because, uh, you need to"
3334240,3339440," do like a range checks and stuff like that. So maybe we can introduce like a special function outside of this"
3339440,3356080," thing. Uh, so bang token kind binary OP bank binary OP token, uh, token token, which accepts the bang binary OP,"
3356080,3364640," binary OP, uh, actually kind, right? So this one is just a kind, uh, right. And in here, uh, what we're"
3364640,3371040," doing, we're going to check the, uh, ranges of the kind. So it's going to be kind, um, has to be,"
3371040,3381200," I suppose, uh, greater or equal than zero and, uh, less than count bang binary OP kinds. And then we're"
3381200,3390160," going to return binary OP tokens, uh, with the corresponding kind. So you can take a binary operation token,"
3390160,3399520," convert it to the, um, um, binary operator, then we can take a convert it to the token and then you"
3399520,3406560," can run the token to the name. That's what you can do in here. Um, all right, that looks okay. Let's"
3406560,3414160," actually make it public. So it's available outside in here. Uh, something like this, right? It's available"
3414160,3422000," outside and how I'm going to be using all of that, how I'm going to be using all that. So, uh, compile"
3422000,3430400," binary OP, right? Compile binary OP. Uh, I'm going to take this entire stuff and I'm going to extract the"
3430400,3440800," token from the binary operation kind. So it's going to be binary OP kind. There we go. Binary OP kind. Um,"
3440800,3447760," And then I need to convert the token into the name. So I think I will find the necessary function in the"
3447760,3457520," Alexa, right? Bang token kind, um, bang token name. Where is the function? The token kind name. Okay."
3457520,3464400," So that's precisely the function I needed in here. There we go. So we have a binary kind. We extract"
3464400,3469680," the token that is associated with the binary operation and we convert it to the name that we"
3469680,3477520," can print in the error message. Um, all right. So we only checked LHS, right? We only checked left hand"
3477520,3484480," side, right? So now we need to do the same thing with the right hand side. Uh, there we go. So the right"
3484480,3491680," hand side, um, so maybe in here, I'm going to actually query place LHS with RHS. Uh, boom, boom. And there"
3491680,3495680," we go. So that's basic type checking that we're doing in here."
3495680,3504800," That is the basic type checking. Okay. Uh, so binary OP type, um,"
3504800,3513440," so this is the location. Uh, and then we also have to provide the type. Yeah. I almost forgot that we need"
3513440,3520240," to provide the type in here and also exit. Okay. So I need to focus, uh, and the type that we're talking"
3520240,3530400," about here is the bank type name. Uh, and the type is essentially bank type I 64, right? So that's a"
3530400,3535120," better version of what I'm trying to do in here. So let me copy paste it one more time. I might as well"
3535120,3545280," actually remove this thing. Uh, and let's just take this stuff, put in here and rename LHS with RHS."
3545280,3553920," There we go. Cool. Okay. So there is a lot of, uh, duplicate code in here and we'll have to copy paste"
3553920,3561600," this code for all of the operations, uh, here. So I didn't want to extract this outside of the switch at"
3561600,3567120," first, but since we're having so much code, I think the time has come. I think the time has come to"
3567120,3572160," actually extract this entire thing outside of the switch, even though maybe in the future, we're not"
3572160,3577440," going to have a binary operations that are just associated with a single token. Uh, but we're going"
3577440,3584000," to fix that when the time has come, when the time comes. Uh, so, okay. So here first we compile left"
3584000,3588400," hand side and we type check the left hand side, then we compile right hand side and we type check"
3588400,3593600," right hand side. And then depending on the binary kind, right. Uh, depending on the binary kind,"
3593600,3598880," we're going to be pushing a different operations in here. And there we go. This is how we can simplify"
3598880,3607680," all of that. Okay. There's a little bit of duplicate code in here, but, uh, it's not that bad. Uh, all right."
3607680,3612640," Let me try to compile this into, I think, and see what's going to happen. Uh, so what do we have in here?"
3613200,3619440," Uh, conflicting type, this thing, yeah, this thing is supposed to return bank type and I suppose,"
3619440,3629280," uh, yeah, I can just return always, uh, bank type i64. I, I hope it's not going to, it's not going to"
3629280,3636160," bite me in the ass. Uh, yeah, it shouldn't actually. I think it shouldn't. So we just return the bank type"
3636160,3642320," and binary operations always return this specific type in here, uh, conflicting type. So I also need to,"
3642320,3651280," uh, binary OP, just put it like that. Uh, there we go. There we go. And what do we have in here?"
3652400,3663920," Uh, okay. So LHS doesn't have a location. Okay. All right. So apparently we do not keep track of the"
3663920,3671360," location of the expressions. That is very, very interesting. But the question is, should we,"
3672560,3679440," should we, because expressions like they have a lot of stuff? In fact, they have a lot of stuff."
3679440,3686480," Uh, so we might as well just use the location of the binary operator. As far as I know, binary"
3686480,3691840," operator does knows, does know its own location. So we can try to do something like this. So let's see"
3691840,3698560," what's going to happen. Uh, okay. Okay. Okay. So, and the same thing applies here too."
3698560,3707760," So compile bank, uh, expression. So we change this function. So it returns compiled expression,"
3707760,3714560," uh, instead of instruction address, right? So this thing should return compiled expression."
3714560,3721760," Um, so what's actually called condition expression. There we go. Uh, what else do we have in here?"
3721760,3729200," Uh, condition expression. So condition expression address, uh, and another one, uh, another one."
3729200,3740960," Okay. Oh, and in here we can actually start checking things. This is actually quite cool."
3740960,3749680," This is actually quite cool because after that I can quite easily. Oh my God. So what if you put a void"
3751680,3758880," expression into while what's going to happen? Because void does not return anything for while to check."
3758880,3763040," So it's going to be completely corrupted program that will completely like jumble your stack and"
3763040,3769040," shit like that. This is actually quite cool. So the, the program sort of tells me, yeah, you need to type"
3769040,3775360," check in here. Right. So let's actually do something of this cond expression type. And if this thing is"
3775360,3780800," equal to, let's actually say not equal to, let's actually say not equal to bang, uh, type i64. Right."
3780800,3790960," To be fair for now, uh, maybe we just need to check if it's equal to void. Right. Uh, right."
3793600,3802000," Std error. Um, okay. That's actually pretty cool. Uh, bang, lock, fmt. Error. Uh, can't use,"
3802000,3810560," can't use void expression. Um, maybe we can do something of this expression"
3813360,3825920," as the condition of the while loop. Right. Uh, bang, lock, arg, bang, lock, arg. Uh, an allocation is"
3825920,3832560," going to be the location of the while. Right. So it's going to be lock in here and void expression,"
3832560,3839920," bang, type name. Uh, and I'm going to just put this thing in here. Uh, and after that, I'm going to exit with"
3839920,3842960," one. All right. Is it going to work? Is it going to work now? Yo!"
3842960,3853280," Interestingly, it worked with while, but it had no problems with the ifs. Uh, I'm actually kind of"
3853280,3866240," surprised. Why didn't, didn't fail with ifs? Uh, all right. So if I try to compile if, uh, bang if, right."
3866240,3876960," So, oh, because we're skipping all this shit. Okay. Oh, that explains everything. Yeah, yeah, yeah, yeah, yeah."
3876960,3886560," Uh, so then, all right. That actually makes sense. So here's the condition. Uh, we might as well try to"
3886560,3896160," do something like this. Compiled expression, uh, cond expression, something like this. And then we can, uh,"
3896160,3906240," basically check it. Um, so compile, bang, while, um, and I'm going to just copy paste this stuff."
3907120,3917360," Can't use S expression as the condition of the if else statement of, okay, of if else. All right."
3917360,3925360," Uh, so that's pretty cool. So we're already starting to type check things. That's, that's nice. Uh, oh yeah,"
3925360,3930320," this one had to actually be replaced. So while with if, there we go."
3930320,3938640," Uh, if condition, uh,"
3938640,3945760," uh, I see. Okay. I see what happened. Uh,"
3945760,3952160," all right. It seems to be working. Do I need to do anything else? Do I need to do anything else?"
3952160,3958080," This is actually a pretty good question. Uh, so we're tap checking stuff, um, which is quite cool."
3958080,3966640," So that means now, uh, if I take a look at the example, right? So example looks like this."
3966640,3974160," You have a while and let's see if it still works. Uh, examples run while bang it."
3978080,3984800," It only support it. Okay. This is kind of weird. Uh, first of all, we definitely broke something,"
3984800,3993680," right? Uh, first of all, uh, we don't put like a new line in here. Uh, and I probably, um, fucked up the, um,"
3993680,4004000," the logic somewhere there. So binary OP, right? So definitely here's the new line. And another thing I have"
4004000,4012160," to put in here, another new line, right? If, uh, one of these things are not equal I64. Um, yeah,"
4012160,4021760," something's going to be definitely wrong. Wait a second. Did I, that's the mistake. I confused var read"
4021760,4027920," with var assignment. That's why I put void in here. Oh my God. Yes. Var read is not an assignment."
4027920,4033120," Assignment. As a matter of fact is not an expression we can see in here. Right. So, but I mean, it can"
4033120,4038080," change at any moment. I'm just like in the middle, um, I'm in the middle of designing the language."
4038080,4048080," So this thing of course has to be, um, actually, um, yeah, it should actually return the type from this"
4048080,4056000," function. Yeah, yeah, yeah, yeah, yeah, yeah, yeah. So that will require another chain of compilation"
4056000,4060800," errors, like following another chain of compilation errors. So the type should be the type of the"
4060800,4066960," variable, but unfortunately this thing does not return that type. Uh, I suppose here we can return"
4066960,4071680," compiled expression, right? It's going to be compiled expression because it is in fact expression."
4072400,4079520," Um, so, and in here we can do something like this. So compiled expression result zero initialized,"
4079520,4087440," and then at the end returned like that. So, and the actual address of this thing could be just"
4087440,4094720," basm program, uh, program size and whatnot. So something like this. But the question is what's going to be"
4094720,4100400," the type? The type should be the type of the global variable. Do we keep track of the type of the global"
4100400,4108000," variables? We don't. Look at that. We actually don't. Why don't we do that? I don't know. Bank type type."
4108000,4114800," We should keep track of it. Uh, so now, um, let's do something like this. It's going to be result type"
4114800,4123120," equal var type. It's actually a pointer. And we also need to go to the place where we assign the name,"
4124000,4130320," um, um, the name of this variable. Um, so we can assign the type of it as well."
4130320,4137760," So let's actually go through the compilation errors. Uh, so conflicting type, uh, right. So let's update"
4137760,4144880," the header file. Uh, it was var read. There we go. So this is a new var read, which returns a compiled"
4144880,4152080," expression. Uh, what else do we have in here? Um, conflicting type. So this one, uh, we're going to just"
4152080,4157440," extract the type, you know what, maybe because of that compiled var thing, you should return just"
4157440,4163440," bank type because we don't really care about its address. Right. So we just return the bank type and"
4163440,4170960," essentially, oh yeah, essentially we just don't need any of this extravaganza here. Uh, var type,"
4170960,4179360," var type and in the header, uh, this one is going to just return the bank type. All right. So I thought"
4179360,4185440," implementing procedure compilations is going to be like a walk in the park. Uh, but apparently to"
4185440,4192160," properly implement procedures compilations, you need to have a very simple, uh, type system because"
4192160,4198000," without that type system, you cannot maintain the stack properly and know the return address."
4198000,4204480," That is very interesting, right? So you need to know whether an expression, uh, has a value or doesn't"
4204480,4210320," have a value. So you can drop, uh, frames from the stack accordingly. This is actually quite interesting."
4210320,4215280," So I love moments like that when I think one thing, but it turns out completely different. Like, yeah,"
4215280,4222320," no, this is not how work works. It works the other way around. Okay. So, and implementing procedures is"
4222320,4228160," essentially implementing a very simple type system. This is a very simple type system. So, but over time,"
4228160,4233040," maybe it's going to become like a basis of a more complex type system. We'll see. We'll see."
4233040,4240400," Uh, so this is actually quite cool. All right. So global variable name, this one is just that."
4240400,4247600," Uh, so this is not where we assign the variable. That is fine. Uh, this is where we assign it and this is"
4247600,4253360," where we probably have to assign the type of it. So, and the type is located also in a variable definition. Cool."
4255200,4261920," Uh, so now I could probably go to the global variable back, right? Uh, and just rename the,"
4261920,4270720," the name back to its normal. Okay. So it's going to be that and another one. Uh, cool."
4270720,4280240," So now we keep track of the types. Can I now run my example? Apparently I can. That is actually very cool."
4280720,4288160," Uh, so yeah, here it is. Everything seems to be working. But now what if I replace while with"
4288160,4298880," right test, right? Because right test is an expression. It is in fact an expression, but it returns nothing,"
4298880,4305040," right? It returns nothing. So that, uh, that means you cannot use it as a condition for while. Uh, will we"
4305040,4311200," check that? Okay. Can't use void expression as the condition in a while. Perfect. Look at that. Look"
4311200,4317040," at that. Legitness. Look at that. Legitness. Uh, we can even try to replace it with if and, uh, it can't"
4317040,4325760," even parse it properly. Apparently expected token, but got name. Huh? Isn't if actually what?"
4327680,4341280," Uh, something is broken with if, uh, with parsing of if, uh, expected token. Oh, maybe. Oh, okay."
4341280,4349760," Why do we have such inconsistency here? Why if requires parentheses, but while doesn't."
4353120,4359280," Okay. Maybe we should fix that inconsistency. So let's actually go to the pasta, uh, uh, and, you know,"
4359280,4368320," change that because that's kind of weird. Parse if a bang if, uh, bang if, there we go. Uh, so yeah,"
4368320,4378480," I don't remember why I did that. So we can just do that. I mean, sure. Uh, there we go. So we take if,"
4378480,4384560," then we, uh, capture its location, of course, then we, uh, parse the condition, then we parse then,"
4384560,4391280," uh, and then if else exists, we parse, uh, else as well. Okay. So I think that should be fine."
4391280,4393600," I don't quite understand why it was like that."
4393600,4403680," Okay. So what do we have in here? Uh, yeah, it's fine. If I do even here, it is also fine. Okay."
4403680,4409760," So now if doesn't require any of this shit. Uh, but if I put true in here, right, it, it works and it"
4409760,4422800," executes once. Yeah. Uh, as I already said, right. Uh, as I already said, if is simply a while that executes"
4422800,4431600," one time, you see, uh, while here executed, uh, was executing while this condition is true. And if"
4431600,4439120," it's basically while, but with a single iteration, uh, anyway, okay. So everything seems to work in"
4439120,4445360," here and we have a very simple type system, uh, which is goddamn fucking cool. I really like that."
4445360,4450480," I didn't know that implementing the type system is going to be so easy, but here it is. Okay."
4450480,4458880," Question is why the fuck did we need this entire type system? Well, when you're have an expression,"
4458880,4465040," right, when you have an expression, something like, uh, one plus two plus three, and you compile this"
4465040,4471200," expression as a statement like here, right? So here is the expression, but we put it into a statement,"
4471200,4478800," right? You need to know the type of this expression. If the type of this expression is int, uh, i64,"
4478800,4483680," you then need to drop that value from the stack because as you can see, it's not used for anything else."
4484320,4489920," Right. If it's void, you don't have to do that. And that is very important because you need to maintain"
4489920,4497600," the address of the return point on the top of the stack, on the top of the stack, uh, when you reach"
4497600,4501440," the end of the procedure. Otherwise you won't be able to return from that procedure. Make sense?"
4502080,4508080," So yeah, that's precisely why we were implementing this type system. So we know an indication. Do we"
4508080,4514160," have an indication whether do we need to drop the value or not drop the value? So yeah, makes sense to"
4514160,4520000," me. That's actually pretty cool. I'm learning a lot of things right now. I really like that. So let's go to"
4520000,4528320," the compiler and, uh, let's find compile, maybe something about statement stmt. Okay. So we're compiling a"
4528320,4533840," statement into the bosom, right? So if is, is a statement that doesn't return anything. War assignment"
4533840,4540800," doesn't return anything. Uh, while doesn't return anything, only expression may potentially return"
4540800,4550880," something. It depends on its type. So now look, look closer, my dear, uh, compiled, uh, compiled expert,"
4550880,4559840," right? So here's your expert. And let's take a look at the expert type. If the expert type not equal to"
4559840,4567040," bang type void, we're pushing additional instructions in there. We're pushing additional instruction. So in that"
4567040,4578240," instruction is going to be, uh, so instruction drop. So this is a special instruction that just basically"
4578240,4584640," drops the, uh, the frame from the stack. So after compiling this entire thing, we're going to have a"
4584640,4591760," single value on the stack, the value of that expression, right? And, uh, if this thing is not void,"
4591760,4596880," um, we need to drop it, right? Because this is a statement. So, and the reason why we need"
4596880,4602880," to support this kind of useless, um, useless expressions is because you may have expressions"
4602880,4610240," that return something, uh, right? Something like this, uh, one plus F that have side effects,"
4610240,4617600," right? So you may have a procedure F that in fact, uh, maybe return something. We don't even, uh, support"
4617600,4623520," returns right now, but yeah, it may return something, but it also performs a side effect, right? So side"
4623520,4629520," effect. That's why you need to support this kind of thing, right? So yeah, pretty much,"
4629520,4639600," pretty much scary, scary side effects. Programmers should be afraid of side effects,"
4639600,4648320," row pointers. What else should be afraid of? Assembly. All these scary things, uh, they should not be in a,"
4648960,4653360," in a programmer tool toolbox, right? Otherwise they may accidentally create something useful."
4653360,4660400," All right. So let me see."
4664320,4669360," So I also want to test how the syntax stuff is going to work. So, uh, let's actually put the word"
4669360,4673040," use 64 and it's going to be something like zero."
4673040,4681920," Uh, so let's recompile everything. I'm pretty sure I made it. Oopsie doopsie. I think it should be"
4682560,4694400," push inst, right? Yeah, it is push inst. Push inst. Okay, yeah. So if I run the example while bang,"
4694400,4701520," it's, it still works, but I want a simpler example. Uh, so we have a simple example. I remember we had"
4701520,4706880," something like hello, right? And it's not that particularly interesting example. Uh, let's, uh,"
4706880,4717280," add something like foo, right? And, uh, we're going to have an entry point in here. And now"
4717280,4722560," what we're going to do, we're going to do one plus two plus three, and we'll try to see what's going to"
4722560,4729440," happen if you try to compile this syntax stuff. Uh, so let's just try to run foo bang. And I should have"
4729440,4736960," actually run it from here. Right. Full bang, no statement. No statement starts with number."
4736960,4747120," Okay. We can't even parse this kind of thing. Um, okay. So essentially we should actually look ahead"
4747120,4753120," into the statements, trying to identify what kind of statement that is. Right. And if we can't identify"
4753120,4758240," what kind of statement that is, we should try to parse it as an expression. Apparently we're not doing it"
4758240,4763280," like that right now. Uh, and that's why we can't parse this. Okay. Let's actually go to the pasta"
4763280,4768080," and see what's going to happen. Um, to, to, to, to, so"
4768080,4777040," STMT, uh, parse statement. Okay. What we're doing here, if it starts with a name, right? If it starts"
4777040,4783840," with a name and the name is if, uh, we parse it as an if condition. If it's while we parse it as that."
4783840,4797200," Okay. Cool. Um, interesting. Very, very interesting. Hmm. Okay. So we only try to parse it as an expression"
4797200,4805120," if it starts with a name, right? Because it could be potentially, um, a function call, right? So because"
4805120,4812000," before we only had function calls as expressions that are wrapped into the statements, but now we're"
4812000,4817520," having any kind of expressions, uh, in the position of the statements. So that means we probably need"
4817520,4824240," to get rid of this entire thing in here, right? We probably need to get rid of it. Um, and just let"
4824240,4835520," it fall through, I suppose, just let it fall through, uh, and try to treat it as an expression here. So here's"
4835520,4842640," what's what's going on here, by the way. Uh, so you peek into the token and you may have it as an assignment."
4842640,4849520," Okay. Oh, this one is interesting, actually. Hmm. But if it's not an assignment..."
4849520,4859520," Mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm, mm-hmm."
4859520,4863520," I guess what we have right now is essentially..."
4863520,4879040," Do we ever reach this state? This is actually quite interesting. Do we ever reach it? Oh yeah,"
4879040,4885040," we never reach it. Okay. I see what's going on here. Uh, so essentially what I need to do in here"
4885040,4892480," is just like move this thing in here. Uh, so I was trying to parse expressions as statement. It's just"
4892480,4898400," like it would never reached... Yeah, it would never reach that code. It's kind of funny how"
4898400,4905360," C compiler never complained about that. Yeah, it's kind of strange because it was an unreachable code and"
4905360,4912800," it was totally fine in there. Um, I don't know. I don't know, man. I don't know. All right, so let's"
4912800,4919440," try to see what's going to happen if we recompile this entire thing. Um, okay, so we have a warning in"
4919440,4926720," here. Control reaches the... But it doesn't. Wait a fucking second. But it doesn't. Does it?"
4926720,4936240," Uh, it may potentially reach it in here. Um... Oh, I see."
4938800,4948560," I see. So you basically need to repeat this thing in here. Yeah, you basically need to repeat this thing"
4948560,4957360," in here, I suppose. Uh, one way to not repeat it in here is probably, again, move this thing back after"
4957360,4962400," here. So, okay, so it was actually not... It was actually reachable. But essentially what I need to do in"
4962400,4975760," here is just do nothing. Uh, okay, uh, this is probably an expression. Uh, let's just fall, um,"
4975760,4987040," through the entire switch construction, uh, and try to parse it as the expression."
4988880,4995040," So that's basically what we're doing here. It's kind of a strange control flow, but I think maybe"
4995040,5003360," it's gonna work for now, at least. Uh, maybe it's gonna work for now. Uh, all right. So, uh, let me"
5003360,5011600," try to run the example. And it ran successfully. Right. We successfully compiled this. But it doesn't do"
5011600,5016000," anything, as you can see. Right. Because there's no side effects. We can actually do something like this."
5016000,5022560," Uh, it's gonna be begin. Uh, right. It's gonna be begin. And then this is gonna be the end. Uh,"
5022560,5028880," and as you can see, it printed begin. Then it performed this thing. And then it printed end."
5028880,5035760," So let's actually see what it actually compiled to. Right. So we can do something like debosm. Right. And here"
5035760,5042880," are the instructions. Yeah. You can clearly see that. So one, two, three plus I plus I, and then drop."
5042880,5053040," Yes. Then drop. Okay. That's cool. Um, if I fit this entire stuff into the right, uh, I wonder what's"
5053040,5060240," gonna happen. There's no drop anymore. Yes. As you can see, there's, uh, we're pushing one, two, three,"
5060240,5067520," and then we summon them up and we're letting it go into the right without dropping it. That is precisely"
5067520,5074880," why we needed, uh, like a void type. So we know whether to put that drop there or not. So if I put it,"
5074880,5082320," uh, like this now, right, uh, now instead of, uh, native right, we have a drop. So yeah, type system."
5082320,5088560," Type systems are great, aren't they? I think they are. So that's pretty poog. That's pretty poog."
5088560,5095360," This kind of stuff could be actually executed at compile time, but we're not implementing any"
5095360,5101120," optimizations. Uh, computing this thing at compile time as an optimization, as far as I know, is called"
5101120,5107440," constant folding, constant folding. Uh, so at some point we're going to actually start working on"
5107440,5112240," optimizations and stuff like that. And, um, yeah, we're going to implement constant folding."
5112240,5116080," Constant folding is actually amazing, believe it or not. It's so goddamn cool."
5116080,5125360," So, um, especially if you're, yeah, especially if you're working with GCC, GCC and Clang are very smart."
5125360,5131280," So you can take this entire code. This entire code can be compiled, uh, can be executed at compile time"
5131280,5136320," completely without any problem. Uh, so let's take a look. So let's go into Godbolt."
5137440,5149920," Uh, and I wonder if I can now put it inside of like main in here and get rid of this kind of stuff"
5149920,5159680," because it's not really needed. Uh, so let me, let me see. Okay. Uh, okay. So here we go. Uh, this is"
5159680,5165920," what it compiled to, right? So this is, this entire thing compiled, uh, to, to this sequence of instructions."
5165920,5171600," If I enable all of the optimizations, uh, it got compiled to just return four."
5171600,5178560," Yes. So essentially what the compiler did, it took this entire code. And since it doesn't have any side"
5178560,5184960," effect, it doesn't depend on any input values. It just executed it at compile time and bake the final,"
5184960,5190160," uh, result into, into the program. So maybe at some point we're going to do a similar thing."
5190160,5194320," Uh, so it would be actually kind of interesting to implement something like that. Uh, something like"
5194320,5200000," this can be not only, um, computed at compile time. It could be completely illuminated because"
5200000,5207040," the result of this thing is never used anywhere. So why, why care? Um, so I guess, yeah, it's kind of"
5207040,5211680," interesting, but it's, it's for the, for another time. It's definitely for another time. So I'm going to put this"
5211680,5219360," thing in the description, if you're interested in this kind of stuff, uh, constant folding, there we go,"
5219360,5230640," constant folding. Alrighty. So now we know how to drop or not drop the, um, the values of expressions"
5230640,5238480," that are put in a position of statements. So now we can quite safely implement a procedure compilation"
5238480,5244800," where you execute each individual statement. And after each individual statement, you know for sure"
5244800,5251920," there is no any, um, additional stuff on the stack and you can just jump back into the address that is on"
5251920,5258480," top of the stack. Right. So that's precisely what we were trying to do in here. Uh, okay. So maybe the time"
5258480,5263680," has come to do a committee committee of this entire stuff. Um, all right."
5263680,5274800," Uh, introduce type void, type void and dropping, um,"
5276800,5282560," expression. Yeah. Let's actually say introduce type void. There we go. I'm going to push that"
5282560,5286960," right into the repo. Okay. I want to make a small break, uh, because I need to make a cup of tea. And"
5286960,5291360," after that, we're going to try to implement the procedure compilation and see how it goes."
5291360,5303280," Welcome back. So, uh, let's get this over with, I suppose, uh, what we need is just like compile, finally,"
5304400,5308640," implement the compilation of the procedures. Uh, so let's go to the compiler, right?"
5308640,5317840," So compile proc definition, right? So what we're doing in here now is we're just compiling the block."
5317840,5324720," And since everything in the block is a statement, you know, that after executing that block, you have"
5324720,5332800," nothing, but, uh, the return address on this stack, we don't have, uh, we don't really have any procedure"
5332800,5338480," arguments. That's why we don't really care about passing arguments via the stack or memory or anything"
5338480,5343280," like that. So, um, procedures right now don't have any arguments, uh, but, but they're going to have"
5343280,5347040," in the future. They're definitely going to have any future. So, but we don't have to worry about it anymore."
5347040,5355280," So after the compilation is blocked, essentially what we can do, we can add another instruction here."
5355280,5362160," It's going to be basm, push, uh, instruction, uh, push instruction, uh, and the instruction is"
5362160,5368160," going to be, is going to be basically return, right? World, use 64, zero. There we go."
5370400,5382640," There we go. There we go. But, but, uh, now the, uh, compilation of the main instruction is completely"
5382640,5389600," broken, right? The compilation of the main instruction is completely broken. Uh, without the special entry"
5389600,5394960," point, uh, that we talked about at the beginning of the session, it's just completely useless. It is"
5394960,5399520," completely useless. So what we need, what do we need to do in here? Uh, I think I want to kind of"
5399520,5407280," introduce, um, a notion of compiled procedure, right? It's similar to how we have a compiled expression"
5407280,5414960," that stores its instruction address and a type. I want to have a compiled procedure and compile"
5414960,5420880," procedure is going to be kind of similar to the global variable, right? Uh, right. So we have a global"
5420880,5427360," variable, which has its own location, uh, memory address in like addressing the memory, uh, the name"
5427360,5435200," and so on and so forth. So basically, um, it's going to be a global variable, but procedure, right?"
5435200,5441360," So something like that in the languages where the functions are first class citizen, there is no"
5441360,5448240," difference between, uh, a function and a variable, like a procedure, like our procedure would be a variable"
5448240,5454080," that stores the function because functions are first class citizens. So maybe, I don't know if we're"
5454080,5459680," going to have like, um, lambdas in here or anonymous functions or like first class citizens functions."
5459680,5463920," They are not the same things, by the way, they are completely different things. I'm sorry that I"
5463920,5470000," jumbled them in a single sentence, uh, that happens from time to time. Uh, but maybe we're going to have"
5470000,5474240," some elements of functional programming in our language, whatever functional programming means."
5474880,5480640," Uh, because again, the, the problem with functional programming is the same as with OOP. Uh, when"
5480640,5486000," people say functional programming, they usually mean different things. So, uh, yeah, what we're going"
5486000,5492640," to have in here, we're going to have a compiled procedure, uh, compiled proc, something like that. So"
5492640,5496880," this is going to be compiled proc. And we're going to, what we're going to have in here, we're going to"
5496880,5503440," have a location in the, uh, in the file, right? In the source code. Then we're going to have an instruction"
5503440,5510320," address where exactly it is located. Then we're going to have, uh, a name, the name of the, of the procedure."
5510320,5517120," And since, uh, we don't accept any arguments in the procedures and the procedures don't return any"
5517120,5522880," types, I think that's going to be it. But maybe in the future, we're going to have like a procedure type in"
5522880,5528160," here, the types of the arguments, uh, because it's going to be needed to properly call the procedure,"
5528160,5533520," right? And what it's returns. And it's again, it's going to be needed to maintain the stack properly,"
5533520,5540000," uh, which actually makes these two definitions kind of similar to each other, right? So maybe after all,"
5540000,5545920," procedure is just a function, just a variable that stores the function as a first class citizen,"
5545920,5550800," who knows? But for now, we're not going to make any assumptions, right? We're not going to make any"
5550800,5558160," assumptions. Uh, and another thing I want to do now, I'm going to add a list of compiled procedures into"
5558160,5564080," the compiler context. You see, in the compiler context, uh, we have, um, you know, array of global"
5564080,5570960," words and how many of them we have. So I want to have something similar. So it's going to be, uh,"
5570960,5581760," compiled proc, uh, and we're going to have procs in here, right? Bank, um, procs capacity. Let's"
5581760,5588720," introduce bank procs capacity. And this is going to be the size of those things. Alrighty. Alrighty."
5588720,5598080," So let's take this entire thing and define it in here. So, and for now, it's going to be also 1024,"
5598080,5604560," because why not, uh, why not? And when you compile procedure, what we're going to be doing is we're"
5604560,5611200," going to be adding, um, the compiled procedure into this list. That's precisely what we're going to be"
5611200,5617200," doing. All right. Makes sense to me. Makes sense to me. Let me, uh, sip my water and we're going to"
5617200,5630560," quickly implement that compiler. Let's see. Um, all right. So we check whether we already have an entry"
5630560,5636480," point. Okay. So right now this doesn't, um, doesn't matter anymore. All right. This doesn't matter anymore"
5636480,5645680," because compiling procedure is not about like compiling an entry point. So let's define compiled, uh, proc."
5645680,5650160," This is going to be proc and it's going to be initialized with zero. So after that, uh,"
5650160,5657840," I'm going to point the address of the procedure at, um, you know, at the end of the compiled program."
5657840,5665360," Then we are compiling the body, right? We're compiling the body. And then we are, uh, pushing"
5665360,5671840," return at the end of that body. So the rest of the things we need in here, we need a location. We can"
5671840,5680240," take a location from the procedure definition. There we go. Uh, and, uh, we also can take the name, uh,"
5680240,5685520," from here. It will kind of interesting. Maybe the compiled proc should refer to the whole procedure"
5685520,5690320," definition just in case. Um, I don't know. We'll see. We'll see. We'll see. We'll see. Because I"
5690320,5698240," end up copying a lot of things from AST to compile the version of things. So maybe the compiled versions"
5698240,5704400," of these things should just refer to the original AST subtrees. Uh, but I don't know. We'll see. We'll"
5704400,5710400," see. Okay. So we initialized everything and here I'm a returning address, but I think I shouldn't return"
5710400,5715600," it anymore because first thing we want to do, we want to compile all of the procedures, right? We're just"
5715600,5723680," compiling all of the procedures and, uh, then we try to find the procedure with the name main and we're"
5723680,5728960," generating, uh, an entry point that calls to the main. And once we return from the main, it just holds"
5728960,5734640," the machine, right? So, uh, we don't need to return anything in here. We just need to append a compiled,"
5734640,5739840," uh, compiled procedure to the list. Um, all right. So how are we going to be doing that? How are we going to be"
5739840,5747600," doing that? So we initialized all of these three things in here? Uh, and maybe I'm going to just assert"
5747600,5759200," that, um, procs count. Uh, so where is the procs count? So it's going to procs count, uh, bang. Uh, I think"
5759200,5767760," it's a pointer, right? Is less than bang procs, uh, capacity. There we go. And bang procs."
5770560,5774320," I'm just thinking what's going to be in here. There we go."
5774320,5786080," So, and I'm going to just assign that proc in here and also increment it like this and I don't have to"
5786080,5792640," return anything anymore. I think that is it. I'm pretty sure that is it. Let's try to compile this"
5792640,5799200," entire stuff and see if we have any compilation errors. There we go. There we go. So let's take"
5799200,5805120," a look at the header version of this thing. It has to do void now. All right. Do we have anything else?"
5805120,5813760," Uh, address. So has no member, compiled proc has no member address. What the fuck? Oh, because I"
5813760,5820160," called it inst for some reason. It has to be called address. Okay. Uh, so that's mistake on my part."
5820160,5824800," Okay. So what are we doing here? Um, so essentially I think we shouldn't care about this kind of stuff"
5824800,5832080," anymore. Um, so we just have to compile procedures. You see how we encounter a variable and we just"
5832080,5838240," compile the variable. Uh, let's just take this thing, uh, and just compile it. Uh, I don't want"
5838240,5843520," to remove this entire code because this code contains a lot of useful error messages. So I'm going to just"
5843520,5848720," put it in here and we're going to reuse it a little bit later. But for now, the idea is going to be that"
5848720,5853040," if you encounter a procedure, you just compile a procedure. If you encounter a variable, you just"
5853040,5859360," compile a variable and you don't have to worry about this kind of stuff. Um, right. So after we compiled"
5859360,5866720," everything, um, we'll need to have a special function that generates an entry point. Um, right. So"
5866720,5876400," maybe we're going to put it like this. So bank generate entry points. Uh, right. So we're going to"
5876400,5883120," provide bang the, uh, the compiler context, then basm into which we're generating an entry point."
5883120,5887840," And the, then we're going to provide the entry point name. So it's going to be something like string view."
5887840,5898640," Um, so entry proc, entry proc name, uh, something like this is going to be assert. Uh, and this thing"
5898640,5910640," is not implemented yet to do is not implemented yet. There we go. Bang, uh, basm and entry proc name."
5910640,5918320," So, and this function is going to be, uh, public and it could be used by the executable"
5918320,5924800," that performs the compilation. So essentially the executable is going to compile all of the modules"
5924800,5932240," into the basm context, and then it will call generate entry point, providing the name of the procedure"
5932240,5936640," that is going to be the entry point. So basically the procedures that are going to be called by entry"
5936640,5942240," point. So that's going to be precisely what I mean. Uh, all right. So let's go into the executable,"
5942240,5949520," uh, bang.c. Um, and yeah, we don't even have to do this kind of stuff anymore. It just doesn't matter."
5949520,5958240," Um, so, so, so, so, so we even push halt in here. We don't have to do that anymore."
5958240,5965200," So here's the idea. Uh, we compile module into basm, right? We compile module into bottom,"
5965200,5974080," then we do bang generate entry point. We still provide bang and basm and the entry point is going to be"
5974080,5986800," main. There we go. So, and in here, I suppose this kind of stuff, um, is going to be, um,"
5986800,5994880," is going to be actually reported by generate entry point. Yeah. So in here we can just basically do an"
5994880,6002800," assert and indicate that entry point got generated, uh, by basm. Uh, so we can do that like some way here."
6002800,6011280," All right. So first thing we do, we, um, yeah, we read the file, right? We read the file in here."
6011280,6017360," Then we turn the file into a stream of, uh, of the tokens. Then we parse the stream of tokens as a"
6017360,6024160," module. Then we, um, initialize the compilation context, right? So, because we need to push some"
6024160,6030240," native functions in there, then we compile the module into the bytecode, and then we're generating the"
6030240,6035040," entry point for that specific bytecode. We check that the entry point was already set properly."
6035040,6041360," And then we save the generated file into the file system. And of course, then free all the memory that"
6041360,6050720," was allocated. So that's pretty cool. Uh, that's pretty cool. All right. All right. All right. All right."
6050720,6061200," So one thing I wanted to do in here, um, um, I need to add a redefinition check to here,"
6061200,6068560," right? I need to add the redefinition check. Uh, essentially, uh, I need to"
6069600,6077600," have a function that gets, uh, the, um, the compiled procedure by its name, right? So something like a"
6077600,6086000," compiled proc, uh, existing proc, and it's gonna be a pointer. So, um, it's kind of, it's kind of similar"
6086000,6095280," to global variables actually, uh, global var, uh, uh, so we can, yeah, get global var by name. So here we're"
6095280,6103920," going to have bank get, uh, compiled proc by name. We're going to provide only bang in here and the"
6103920,6108480," name of the procedure, right? So a name of the procedure can be defined in the procedure definition."
6108480,6115280," All right. All right. If existing proc is not equal to null, we're going to throw an error, right? We're"
6115280,6121840," going to throw an error. So let me see. Uh, all right."
6121840,6138160," So existing proc, uh, procedure, procedure that is already defined. So here's the"
6138160,6144960," proc definition with its location and then proc definition with its name. So you can clearly see"
6144960,6150160," that there is like a similarities between, uh, procedures and functions. The only difference"
6150160,6155680," between them is that procedures are located in the instruction memory and variables are located in the"
6155680,6166160," memory memory. Yeah. So it's kind of interesting. Yeah. There is like a symmetry between them. The first"
6166160,6173280," definition is located in here and, uh, this is going to be like existing proc. Uh, and there we go. Uh,"
6173280,6181040," after that, um, after that, if everything went okay, we're going to be doing this kind of stuff. All right."
6181040,6189440," That is cool. That is cool. Let me try to compile this into, I think. And, uh, all right. So we don't have"
6189440,6195280," this function yet. Let's quickly implement it. This function is going to return compiled proc, uh, and it's"
6195280,6201920," going to accept the compilation context and the name, right? And here is the thing. So we're going to be"
6201920,6216560," iterating through all of the, uh, bang, eh, procs, procs count plus plus i and if bang procs i name is"
6216560,6223600," v equal to the name, we're going to be instantly returning to that specific proc. There we go. So I'm"
6223600,6228400," going to just return a pointer to that specific proc. Otherwise, I'm going to just return null. There we go. I"
6228400,6238080," probably need to put it into the header, uh, because it's c, um, uc. It is c. Uh, so I feel like we don't"
6238080,6245040," need this thing anymore, right? Compile, uh, compiled expert. Yeah. We never use this thing. I'm pretty sure."
6245040,6252720," It's kind of dumb. Um, yeah. So because of that, we don't need the redefinition anymore in here. So"
6252720,6260240," redefinition got consumed. Um, so also here we're generating this kind of stuff. So yeah, none of"
6260240,6268560," that is needed. So I already, uh, did everything. Uh, all right. So we check for the redefinitions,"
6268560,6273520," which is nice. Uh, let's see if we don't have any problems here anymore. We do have some problems."
6274240,6283920," Uh, semicolons, of course. In 2021, still semicolons problems. Am I right? Uh, okay. Uh, yeah. So this"
6283920,6289200," thing is not implemented yet. Uh, but can we just, uh, we can't even debuzz on it, unfortunately. So we have"
6289200,6296720," to first, uh, implement this function. Okay. So what we're going to be doing, um, we need to first query the"
6296720,6306800," compiled procedure, right? Uh, entry procedure. So bang get compiled, compiled proc by name. So we'll"
6306800,6314240," provide the compiler context, then entry proc name. Uh, and so let's do the phone thing. If entry proc"
6314240,6321760," ended up equal to no, uh, that means, uh, we couldn't find such procedure, so it couldn't be set"
6321760,6326720," as an entry point. So we need to report that. Uh, so it's going to be something like this."
6326720,6340720," Bang, uh, lock FMT. It's going to be error. Could not, uh, find, uh, a procedure, the procedure"
6343040,6356400," SVFMT to procedure. So let's put it like this entry. You cannot find the entry point procedure. Uh, please"
6356400,6364000," make sure it is defined. Right. And the question is, where are we going to report that? So I said that"
6364000,6372000," we're going to report it at this location, but what is the location? We have no location to report it to."
6373280,6379600," Well, maybe in that case, we just have to put like an error in here. Do not find the entry point procedure."
6379600,6386800," Please make sure it is defined. Uh, I guess I have nothing else to say, right? We went through the entire,"
6386800,6392960," the entire source code. We compiled everything, but we couldn't find the main procedure. So there's no place"
6392960,6398160," for us to report this to. So we just couldn't find anything. So it's just going to be a general error."
6398720,6406160," Right. Makes sense to me. Um, anyway, so after we've got the procedure, uh, we know its address."
6406160,6412800," So what we're going to be doing, um, we're going to set, uh, we're going to actually remember an"
6412800,6419520," instruction address, entry point address. And the entry point address is, is equal to the end of the"
6419520,6424080," program. We're going to be generating the entry point at the end of the program. Uh, so it's going"
6424080,6430160," to be program size. There we go. So this is the entry point address. Um, after that, I'm going to set"
6430160,6436560," the entry as the entry point address. And then I'm going to say that, okay, the entry point has been"
6436560,6443920," generated. Uh, so it's going to be true. Might as well, maybe even in line this entire stuff, because"
6443920,6450320," why not? That kind of makes sense. Right. So here's the entry. Here's the entry, uh, like indication that"
6450320,6455680," entry was set. So, and let's start generating instructions. Uh, first instruction that we want"
6455680,6460960," to generate for the entry point is going to be call to the entry procedure, right? Let's quickly do that."
6460960,6467840," Uh, bosom instruction, uh, push. I think it's a push instruction, right? It's going to be bosom"
6468400,6479520," instruction, uh, call and we're jumping to entry procedure address. And this is a pointer, right?"
6479520,6484080," This is a pointer. So we have to do something like this, right? So this is the first thing we do in the"
6484080,6492560," entry point. The second thing we do is, uh, simply halting. So it's going to be halt. There we go. So we just"
6492560,6499120," generated an entry point. Isn't that cool? Isn't that cool? Well, I think it's pretty full-con cool, mate."
6499120,6505200," I think it's pretty full-con cool. All right. So let's see what's going to happen. Uh, boom, boom, boom."
6505200,6515520," I need to recompile the entire stuff. Uh, so did I fuck it up yet again? So what does it say? Uh, yes."
6515520,6522080," Okay. So I have to do something like svarg, uh, entry proc, uh, name. Anything else?"
6522080,6529840," So is it, is it, is it a push instruction? Too few arguments. Oh yeah. This one has to be like"
6529840,6539200," word view 64, uh, zero. There we go. All right. So if I try to run the disassembly of the example,"
6539200,6547040," this is what we got. All right. Let's take a look, uh, at the example itself. FooBank. So it"
6547040,6552400," basically does a useless, useless expression, one plus two plus three plus four. Uh, and this is what"
6552400,6558800," we got generated. So this is the entry point. And in the entry point, we're jumping to the address zero."
6558800,6567360," So zero is somewhere here, right? And here we sum up everything. And since this entire thing is not void,"
6567360,6572720," we're dropping it. And then we're returning back into the entry point and entry point just halts it."
6572720,6581120," Perfect. Actually perfect. And here's another thing. What if I add another procedure in here?"
6581120,6586720," Let's actually put another procedure. Will that work? So it's going to be something like write, uh, full,"
6586720,6594800," uh, write full. And I think it worked as you can see now the entry point jumps not to zero,"
6595360,6601680," but actually to four. Zero, one, two, four, which is kind of..."
6601680,6614400," That is really, really sus. Zero, one, two, three. My brain is already shutting down. I'm sorry."
6614400,6620160," I skipped three, uh, because I, yeah, I should work at valve, by the way."
6620160,6629600," Oh, yeah, I'm already a little bit tired, but yeah. Uh, so here is the full, which basically like, um, prints"
6629600,6637920," the, uh, full, uh, full text. And this one is main. So we jump to main and we never actually do anything with full."
6638400,6643040," And the reason why we never actually do anything with full is because we don't know how to call procedures."
6643040,6647760," Yes. This needs to be implemented separately."
6647760,6653200," Yes. As I've already said in the previous streams, if you want to be able to have variables,"
6653760,6661520," you need to code defining the variable separately, reading the variable separately and assigning variable"
6661520,6667600," separately. These three things, defining variable, reading and writing are three separate processes"
6667600,6674400," that has to be coded explicitly separately. The same goes to the, uh, to the procedures. Defining procedures"
6674400,6681600," is one thing. Um, executing procedures is a second thing and calling procedures is the third thing,"
6681600,6687040," right? So we can't call these procedures. We can compile them, but we can't call them at all."
6687040,6695120," So, um, let's try to compile the while example and see what it gets compiled to. Uh, it looks pretty"
6695120,6701040," reasonable. So here's the entry point, right? We jump to the zero and yeah, at some point we return"
6701040,6707680," from this entire thing and we halt. So let's actually test how it works. Let's test how it works and see"
6707680,6713840," if it doesn't introduce any errors. And as you can see, it worked fine and it exited fine. It didn't"
6713840,6721440," like stack under flow or stack overflow. It returns fine. So that's actually pretty cool. That is in fact"
6721440,6728400," pretty, pretty cool. Uh, and let's try to redefine full and see what's going to happen. Uh, I have to"
6728400,6734000," switch to full. Yeah, there we go. Uh, the procedure full is already defined. It was defined here. As you"
6734000,6741920," can see, we can define bar. We can just define bar and this one is going to simply bar. Uh, right. Cool."
6741920,6752400," That is cool. That is, that is cool. Um, all right. I wonder how much time it will take to implement, um,"
6753040,6758880," function calls. You may say that we already have function calls, but we basically hardcoded a single"
6758880,6766560," function called write. Uh, but it would be kind of cool to be able to do something like this full. Uh,"
6766560,6775920," then inside of the full, right. Inside of the full, you would do something like a full and then bar. Uh,"
6775920,6781600," and just see how it just chains together and returns appropriately. So, but, uh, for now you won't be"
6781600,6787440," able to do that. This is not a thing that you can easily do it. You can't even parse that because our"
6787440,6793680," functions are hardcoded to, to be like that. To be fair, to be fair, uh, we can do the following thing"
6793680,6805680," quite easily in the parser. Right. So, parse, uh, bang, proc. Is it proc call? But something about calls."
6805680,6813600," Fun call. Yeah, it is called fun call. Uh, and what we're doing here, we expect open parent,"
6814320,6822320," um, right. And then we parse the expression and expect close pattern, which is rather,"
6822320,6830640," rather interesting. So, can we do the following thing? Right. If, um, so we need to look into the next"
6830640,6837680," token. How can we look into the next token? So, let's allocate a bang token, token, uh, it's gonna be zero"
6837680,6846400," initialized and let's peak into the next token. If Alexa, it has to be bang Alexa, uh, pick, we provide"
6846400,6854960," the Alexa and, uh, the pointer to the token and we say, let's actually peak into the next one, into the"
6854960,6861920," current one. Uh, right. If you do have the next token and, uh, that token"
6863600,6872960," is equal to, uh, uh, to this one, right, is equal to this one. So, it's gonna be token, uh, kind"
6872960,6883520," equal to that. That means you don't have any, uh, any arguments. So, in that case, I suppose you can"
6883520,6890160," quite safely just return null. Right. You didn't, you don't have any, any arguments in here. Right. So, you"
6890160,6895920," expect token open parent that removes the, uh, the parent, then you look into the next token and if"
6895920,6903680," it is, um, closed token, you can try to materialize it. Right. By just basically, uh, you know, doing"
6903680,6910160," next in here like this and just return null indicating that, oh, okay, you don't have any functional"
6910160,6915440," arguments. Right. If you do have something in there, if you do have something in there,"
6916800,6922080," something else, you should try to parse it as an expression and then just return it like that. So,"
6922080,6930880," now, this way we support function calls with zero or one argument. Uh, so, yeah, we even have an issue"
6930880,6937360," for that. But I think, uh, we can quickly hack it together like this. So, uh, since we can't have"
6937360,6943280," procedure definitions with several arguments, it doesn't really matter. It doesn't really matter at all."
6943280,6951520," Okay. So, let's try to run this entire thing. And what about full? Uh, okay. Unknown function bar. Okay."
6951520,6957520," So, we passed the parsing stage. Now, we're trying to compile the functions."
6957520,6967200," Can we quickly do that? How hard would it be actually? Just think about it. Um, so, unknown. Okay. So, if you"
6967200,6973520," encounter an unknown function, we can quite easily just query it. So, it's going to be compiled procedure."
6973520,6981360," Right. So, it's going to be proc, uh, bang, get, uh, compiled procedure by name. We know the name."
6981360,6987120," The name is expression as function call name. Right. So, something like that. All right."
6988320,6996080," And if procedure, if procedure is equal to null only then, we're going to complain that it's unknown. Right."
6996080,7002640," If it is known, we can just call to that function. I mean, why not?"
7002640,7011440," The bosom push instruction bosom instruction call and the operant is going to be word view 64 procedure address."
7012400,7019760," That's it. Why can't you do that? It's as simple as that. So, and on top of that,"
7019760,7024960," you have to actually return the void type. Right. So, because to, to indicate that you don't have to"
7024960,7031120," drop any results from there. Uh, all right. So, if I try to run this entire, not really run,"
7031120,7037280," but compile this entire stuff, uh, maybe we're going to have function calls. Uh, so, bang,"
7037280,7041200," get procedure by name. I also have to provide the context. Of course, thank you very much,"
7041200,7045120," compiler for reminding me about this kind of thing. This is a pointer. Thank you very much, compiler."
7045120,7050480," I really appreciate that. And do we have anything else? Okay. Let's try to do the following thing."
7050480,7058480," I'm going to disassemble the full example. And what do we get? We have a bunch of calls, to be fair."
7058480,7069360," We have a bunch of calls, which don't really make much sense. You call to nine. All right. So, zero,"
7070080,7081200," one, two, three, four, five, six, seven, eight, nine. Okay. Then you go to four."
7081200,7091840," You push four, four, you write, and then you call zero. All right. Here you write something and you"
7091840,7103920," return and okay. Looks reasonable. Yeah. We have three functions. Uh, we have three functions in here."
7103920,7115120," Let's see. And we have three calls. Here's three calls. And I suppose three returns. Hmm. That is pretty cool."
7117440,7124400," Is it going to work? So, if you take a look at this code, what it should do. It calls full. Full writes"
7124400,7130160," full to the standard output. Then calls bar. Bar writes bar and returns. Everything returns and just"
7130160,7139600," exits. We can also put something like, uh, write end at the end of this entire thing. Right. And let's just"
7139600,7145600," disassembly. Yeah, there we go. So, we're taking that into account. And let's just try to run this entire"
7145600,7153600," stuff. It works. It printed full, bar and end. Uh, so, theoretically, we can have, um,"
7153600,7164720," we can have a recursion. Uh, but I guess we're going to explore the recursion a little bit later. I think it would"
7164720,7171040," make sense, uh, if we had, uh, arguments. Right. So, maybe if we had arguments, we could implement"
7171040,7176880," something like Fibonacci number calculation or something like that. But yeah, we managed today"
7176880,7184880," implement procedure compilation, uh, function calls, and simple type system that supports two types,"
7184880,7191760," i64 and void, and use that type system to know whether we need to drop the values from the stack or not."
7192720,7199200," That is goddamn fucking cool. I really, I really like that. So, yeah. Today was a pretty productive"
7199200,7204160," stream. I didn't expect to actually manage to implement that. But yeah. So, we can even compile"
7204160,7210320," this kind of shit. That's, that's pretty pogue. That's pretty pogue. So, we need to think about maybe"
7210320,7218080," thumbnail. Um, I'm thinking, can you actually do a recursive shit with that? Right. Can you do a"
7218080,7224240," recursive shit? You should be able to do a recursive shit? Uh, yeah. Let's, let's give it a try. So,"
7224240,7229840," it's going to be something like main and it will obviously overflow the stack. Right. It will obviously"
7229840,7239680," overflow the stack. Uh, but, uh, let's actually see, uh, unknown function main. Oh, shit. Oh, fuck. You can't"
7239680,7251120," have a recursion yet. Nice. I love that. Hmm. Can we quickly hack it together so we can have a recursion?"
7251120,7257200," Uh, so essentially when I compile proc, uh, definition into bosom, right? I compile in the"
7257200,7266400," block. Can I append? Because I already know the address. I literally know everything before I try"
7266400,7271840," to compile the block. I literally know everything, which means I can just pull it like that. All right."
7271840,7276800," So, uh, I know where it starts. I know its name. I know its address. And while I'm compiling this"
7276800,7282560," entire thing, it will be already in the procedure. So, that means I should be able to do this thing."
7282560,7287920," Uh, unknown. Well, I mean, I need to recompile this entire stuff, of course. Uh,"
7287920,7295840," come on, come on, come on. There we go. So, and there we go. It compiled successfully. So, as you can see,"
7295840,7304160," we jump to zero and we keep calling zero, never actually exiting it or anything. So, we have a return,"
7304160,7309440," but it's unreachable. We have a hold, but it's unreachable. So, and if you try to run this entire"
7309440,7315040," thing, right, if you just try to run it, it will stack overflow, right? It overflew the entire stack"
7315040,7320880," of the virtual machine, which is quite expectable. Uh, which in fact, quite expectable. And you know what?"
7320880,7328960," I think this is a pretty goddamn good thumbnail. Not gonna lie. So, this is gonna be the thumbnail of"
7328960,7337680," today's stream, right? What procedures? Compile 2. Oh, anyway, thanks everyone who's watching right now."
7337680,7343200," I really appreciate it. Uh, have a good one and I see you all tomorrow. Tomorrow, by the way, Friday,"
7343200,7350640," Friday, and that means tomorrow we're gonna be picking a random one-off topic and it's not gonna be any of"
7350640,7354720," the, uh, of my projects. It's gonna be something completely new and we're gonna do that for the whole"
7354720,7362320," session. I have a list of, uh, different ideas to try out, to check out and I think it's gonna be interesting."
7362320,7366080," So, thanks everyone for watching. Uh, love you."
