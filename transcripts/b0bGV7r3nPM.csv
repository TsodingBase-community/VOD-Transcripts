start,end,text
960,7760," Hello everyone and welcome to yet another recreation programming session. In PORTH, the"
7760,13600," concatenative programming language that I'm developing, I introduced recently a new control"
13600,19120," flow construction. And that control flow construction is basically an early return"
19120,26880," from a procedure. So let's take a look at it. So let's open a new file, right? So let's"
26880,34960," include the standard library. And let's introduce an entry point, right? So let's write something,"
34960,45440," something like hello world. And let's actually print that on the screen and compile this entire stuff."
45440,53760," There we go. So as you can see, it says hello world, right? So early return is basically initiated"
53760,59040," by a keyword return. It's no different than in any other imperative programming language, right? So"
59040,65440," you basically hit return and you instantly return from the procedure. Right? So let's assume that here"
65440,71440," we're going to have something like before return, right? And here we're going to have after return,"
71440,77760," right? And if everything works correctly, we will see before return, but we'll never see after return,"
77760,83200," because we return from the procedure at this particular point, right? So if I try to run this"
83200,88800," entire thing, as you can see, it says before return, but it never says after return. So if I move return"
88800,96480," here, it says before return and after return, right? Exactly as you would expect. And what's cool about"
96480,102480," this entire thing is that the type checking still works as you would expect. Everything is still type"
102480,112000," checked. For instance, if I probably like move it to full. Let's do proc main in. And let's assume that"
112000,120160," foo is supposed to return a couple of integers, right? So and if you return them like this, a 69 for 20,"
120160,127760," it will, it will actually work, right? So it will actually compile. But if you return before"
128320,133920," these two integers, it will not work because you don't have enough integers on the top of the stack"
133920,139280," to actually return from this function. So that will not compile. So it will say insufficient data on the"
139280,146000," stack. So and these are the integers that are expected in here. So in complaints about this precise"
146000,152320," thing. So people were asking why I made the type checking of port is so complicated. I personally don't"
152320,158960," think that it is complicated. But people were asking why it is so sophisticated. And this is basically the"
158960,166480," answer, right? So it is general, it works with any control flow construction, I can modify existing control"
166480,171680," flow constructions, I can add whatever I want, everything is still going to be properly tab checked,"
171680,178000," because our type checking just follows all of the possible control flows. And if it finds any discrepancies,"
178000,183200," it just fails and tells you that there is a discrepancy, please fix that. So the type checking"
183200,189840," does not care about any control flow, I can just introduce like labels and gotos, and they're also"
189840,195600," going to be properly type checked, right? Because we follow all of the possible control flow and checking"
195600,202160," everything. So that's the beauty of this, I think. So yeah, now we have an early return. It was relatively easy"
202160,207360," to introduce because we already had an intermediate representation instruction to return from a"
207360,213600," function. I just had to wire it up into a keyword. And that's basically it. And also a little bit of,"
213600,219920," you know, work on delegating the memory, you know, cleaning up the stack and stuff like that. But that's"
219920,227280," just like a minor thing. So to get the gist of the usefulness of the feature, let's actually use it for"
227280,234240," something in the compiler, right? Let's introduce maybe hexadecimal literals, right? So for quite some"
234240,242480," time, yeah, I actually didn't implement that. I don't know why, right? Maybe I was waiting for early"
242480,248560," return, who knows. And every time I need a hexadecimal literal, I would just like convert it to a decimal"
248560,254480," literal and just use it like this, which is kind of weird, right? Because as far as you know, this thing"
254480,260800," should look a little bit prettier. So let's actually go to Python 3. And I'm going to say please convert"
260800,268240," that to hexadecimal literal. And as you can see, it's supposed to look much nicer, right? So and yeah,"
268240,274880," actually, early return makes it kind of easy to implement like the converter from, you know, basically"
274880,280960," parser of hexadecimal literal. And let me actually demonstrate you. So let's go ahead and do that. So to"
280960,288080," implement the hexadecimal parser, first, we need to know how to parse a single hexadecimal digit."
288080,294880," Right? So let's introduce something like hex digit. And this thing is going to take a single character,"
294880,300560," we don't have a character type. So but we do have character literals, right? So if you have something"
300560,307440," like this, it will be converted to ASCII code of that specific character, right? So but the type of"
307440,314480," this thing is still going to be integer. And this thing will return the value of that hexadecimal digit."
314480,321840," So but we also need to take into account situations when something is not a hexadecimal digit. So I think"
321840,327600," we're going to return a boolean indicating that whether we successfully parsed a single hexadecimal"
327600,334320," digit or not, right? If it's true, that means whatever we have behind that boolean is a correct"
334320,339360," integer. If it's false, this thing is going to be undefined. And this is basically an indication that"
339920,350480," the digit was incorrect. Okay. So let's take a look. Let's bind the digit to a variable d, right? And"
350480,356800," first check, is that a decimal digit, right? So if it is a decimal digit, it has to be between 0 and 9."
356800,364640," Right? So it's going to be d, it's going to be greater or equal to 0. And it should be less or equal"
364640,374560," than 9. Right? And if it is, we can quite easily just return d minus 0 and true and just return like"
374560,382720," that. Okay. So the next thing we need to check whether it's a character from a to f. And if it is,"
382720,389040," I'll have to convert it to a number and then add 10. So maybe I also want to align this entire thing like"
389040,396240," so. And we also want to take into account the capital letters, like so. So as you can see,"
396240,402400," we have like three conditions in here. And if we checked all of them, and none of them are true,"
402400,407760," we can just fall through and just return 0 false indicating that we didn't parse this entire thing"
407760,414080," correctly. So essentially, early return allows us to write a very concise code like this, which is"
414080,418880," actually pretty cool. And it's going to be properly tab checked. So let me let me see how it's going to"
418880,427920," work. So let's start with zero and parse this entire thing. So hex digit is supposed to return two things"
427920,433360," integer and boolean. As you can see, here is the boolean. And here is an integer. Right? What we can do"
433360,441040," here is check, is this true? Was the parsing successful? If it was, we can just print the next character."
441600,448080," Otherwise, the next character is sort of undefined, we can drop it and say that this is not a hex."
448080,453520," Right? So this is not hex. I'm going to do puts a new line and just close this entire thing."
453520,460640," Okay, so as you can see, it converted this entire thing to zero. Right? Then we can take a look at,"
460640,468240," for example, five. As you can see, we have zero five. Then we can take a look at something like,"
468240,476800," A. Is it going to be 10? It is in fact 10. What about the capital one? It is also 10. And what about"
476800,486080," F? Has to be 15. It is 15. What about Z? Has to be not a hex. And as you can see, it says not a hex."
486080,493200," Right? So it's relatively easy. We also can just take this entire line and factor it out into separate"
493200,498400," procedure. So let's call this procedure. Check. It basically checks the result of the hex digit"
498400,506800," function. So it's going to accept the integer and the boolean. And that doesn't really do really nothing."
506800,513600," So we're going to just like move this line in here. Right? So in this entire stuff, we can say that this is"
513600,521840," basically check. Concatenativeness, of course, makes it super easy to actually factor out things like that."
521840,530560," Okay. So we know how to parse a single digit. So it would be nice to learn how to parse several of them."
533520,544480," So let's implement something like, try parse hex. And it's going to accept a string. And it is going"
544480,550880," to return the same thing as hex digit, it will return the value of the number and indication whether it was"
550880,559760," successful or not. Okay. So this is what we have in here. Let's bind the current, you know, the current"
559760,563600," string. So this is the size of the string. This is the pointer that points at the beginning of the string."
563600,572800," So one thing we can try to do right away, if n is less or equal than zero, right? If it is less or equal"
572800,579680," than zero, there's nothing to parse. So we can right away just return zero and false and return from this"
579680,587600," entire stuff. Right? So if we do have something to parse, I think we should prepare the stack, right? So we"
587600,592080," need some sort of a value into which we're going to accumulate everything, right? So the initial"
592080,599280," state of that value is going to be zero. And let's push the string that we're parsing back onto the"
599280,604400," stack. So here we're going to have three elements that we're going to use as sort of the state of the"
604400,610560," parsing, right? So this is the state of the parsing. So the first thing on the top is a pointer,"
610560,615920," pointer to the beginning of the string. Then we have integer, which is the size of the string. And then we have"
615920,622080," another integer, which is the final result, right? Into which we're sort of collecting everything."
622080,629760," Okay. So now I'm going to do a loop, right? So the size of the string is the second element on the stack."
629760,636400," So I can do something like over while it is greater than zero. We're going to do, you know, the basic loop."
637200,643520," And in here, I'm going to bind all of these values. So we have an accumulator. I'm going to call it a and"
643520,651120," an s, right? So that's what we have in here. What do I need to do in here? I know that n is greater than"
651120,656160," zero because we check this condition in here. So I can quite safely just take the current character"
656160,662640," and read it from s. So here I have a character. I can even take a look at it. Right. So, um,"
662640,667280," oh, okay. It actually stopped in here. So maybe I'm going to do the following thing. Yeah, there we go."
667280,676240," Unexpected data on the stack. Uh, okay. So it failed before it hit the question mark in here. So"
676240,681440," I can't use the question mark in here. So maybe I should just improve the order in, in which I'm"
681440,686880," checking everything. But anyway, so what we can do, what I can do in here is basically try to parse"
686880,692880," that digit. Right. So it's going to be hex, uh, digit, and it will return, um, you know, the integer or"
692880,701600," boolean. We can check it right away. Right. If it is not hex digit, we want to right away return from the,"
702160,708960," uh, from the loop and just say that we can parse that. Um, let me see how we can do that. So we"
708960,717200," have a number in here and I suppose we can just do false, uh, a return and that is it. Right. If it is"
717200,722160," true, right. If it is true, we're going to have the number, which we can just add to the current"
722160,728160," accumulator. So let's take our accumulator, multiply it by six, right. We're multiplying it by six and we're"
728160,733200," going to be adding it to the previous character in here. So it maybe makes sense to actually"
733200,738400," separate this like this. Uh, so this entire thing will return two values. The first value is going"
738400,742880," to be boolean is going to be consumed by this condition. And the second value is going to be"
742880,750000," added to the, uh, to the accumulator. Right. So then after that, I'm going to take n and subtract it by one,"
750000,755280," uh, reducing the size of the string that we parsed. And then I'm going to take pointer s and move it to the"
755280,762720," right. Right. So basically I'm just slowly shrinking the string as I parse it. Uh, okay. So after that,"
762720,769520," we should have three values, uh, on the stack, right? So here they are the pointer to the string. Uh, but"
769520,775600," by the time the pointer to the string points at the last value, then we have the size of the string. Um,"
775600,780880," it's also going to be equal to zero. And the only thing that we care about is the, uh, is the final answer"
780880,787360," that we, uh, accumulated. So in here I can just take, uh, the answer that I want to return, ignore"
787360,793600," the entire string, the size and the pointer, and just return the answer. Right. But also I have to say"
793600,798800," that it's true. Right. So because we managed to parse everything successfully, if we reached this entire"
798800,804960," state, we parsed everything successfully. If we didn't somewhere here, we should have actually, uh, failed"
804960,810960," accordingly. So yeah, that's the entire parsing actually. It's really weird. It doesn't look like"
810960,816480," parsing in the traditional language, but it's still rather compact and rather readable when you get used"
816480,823040," to it. It's just like rust. You, you have to get used to it. Uh, so yeah, uh, let's actually see if this"
823040,828800," this entire thing compiles and it in fact compiles, uh, right. So let's actually do something. Let's"
828800,836400," create something like F and, uh, we're going to do try parse hex. And since, uh, try parse hex returns"
836400,844160," the same, uh, things as hex digits, we can just pipe it into check, uh, right away. And as you can see,"
844160,853200," F is 15, then we can say FF, it has to be 255, uh, right. And, uh, and as you can see, it's 255. So we"
853200,861840," are capable of parsing the, uh, you know, hexadecimal literals. How about that? So yeah, it is working."
861840,870080," And if I put something like hello world in here, it will say that it's not a hex. So yeah, uh, we just"
870080,877360," implemented, uh, try parse hex function using early return and that worked great. And again,"
877360,883200," everything is properly type checked. If I forget to put a false in here, it will tell me that, uh,"
883200,890960," you know, expected type integer, but got boolean, right. Um, so yeah. So the, at the top of the stack,"
890960,897760," somewhere here, we have an integer, but we accept boolean. So we'll have to put it in here. Um, yep."
897760,902560," Everything is type check. So the type checking could, uh, could have actually reported things a"
902560,909200," bit better, but it works. Right. So if there's some fishy code, it just does not allow you to"
909200,918080," compile that code. So it catches a lot of errors already, which is pretty good, which is pretty good."
918080,926080," So what I'm thinking is that I want to move this entire thing to, oh boy, I don't know, maybe, um,"
926960,933120," a standard library. I'm not sure if this function is useful for the standard library. Maybe it would"
933120,940640," make sense to like inline this entire stuff somehow. Is that a good idea? Maybe,"
940640,948480," maybe not. Okay. So, uh, let's move everything to the standard library. So this is going to be std,"
949120,957520," std.porth. And I'm going to just move hex digit here. There we go. Check. I didn't think check"
957520,964000," is needed in the standard library. It's just like a thing to, you know, print stuff, uh, literally to"
964000,974320," check stuff. And, uh, the only thing we need in here is a try parse hex. Okay. Uh, no, um, I'm going to try to run that."
974320,980640," And I can already just take this file and put into the folder of unit tests, right? So we can use it for"
980640,986960," unit testing the language, um, or specifically the standard library, right? So where is main.porth?"
987680,994880," Uh, here it is. I'm going to open it in here. And, uh, uh, I'm probably want to rename this thing, uh,"
994880,1004000," to try parse hex dot port, right? There we go. So we moved everything here. Uh, now let me delete this"
1004000,1015440," entire stuff. And also I want to update the output. Let's say update output tests, uh, try parse hex dot port."
1015440,1020960," There we go. So, and if we take a look at what is expected from that specific program,"
1020960,1027120," right? So we expect this program to exit with zero exit code and the output is expected to be this,"
1027120,1038480," right? So, and if I try to test the compiler using that specific test tests, um, try parse hex"
1039440,1046080," forth. It is working, right? So everything is, uh, working. So let me create a separate branch called"
1046080,1057280," hex, uh, like so. And let's commit the, uh, the code. Implement try parse hex, right? And I'm going to push"
1057280,1065440," that right into the repo. So now we want to do the following thing. We want to add, um, hexadecimal"
1065440,1072480," literals to our language, right? So we want to use that specific function, um, in, in the language itself."
1072480,1076400," Right. So, but I need to make a quick break before we can do that. So, um,"
1080800,1087040," I forgot to unmute myself. Okay. Uh, let's continue. Uh, so, uh, we need to go to the"
1087040,1093120," Lexer, right? Because we're parsing these string literals in the Lexer. Um, let me see, I think it's"
1093120,1098880," somewhere like a next token, right? So this is the next token and there is a lot of code in here,"
1098880,1106240," but this is because it's a very, very old code. All of that was by the way written before we even had"
1106240,1112560," the lead bindings and I'm not even sure. Yeah. We did have the local memories, right? So it's a very,"
1112560,1118800," very old code and you can see that there is like a lot of noise and all of that noise. Like I had to"
1118800,1122640," write this noise because we didn't have like a proper features that would make it a little bit less"
1122640,1129760," painful. So this is where it happens, right? So we have a word and we try to first parse this word as"
1129760,1136080," an integer, uh, right then, um, what are we doing here? This is really interesting. We're trying to"
1136080,1142640," parse that word as a keyword, right? And if we couldn't parse it as a keyword, we parsed it as a"
1142640,1148480," word, right? So this is probably where we want to add this kind of stuff, right? So maybe we want to"
1148480,1156880," try to parse it as a hexadecimal thing first, then try to parse it as the decimal one. And, uh, yeah,"
1156880,1163680," so, and that will actually make it in the future a little bit easier to, um, you know, add more, uh,"
1163680,1170160," literals or something like that, right? So octaliterals, binary literals and everything. But with the"
1170160,1176640," hexadecimal one, it's kind of interesting. Um, we probably have to first, uh, check the prefix,"
1176640,1180560," right? So because the usual convention in programming languages is that hexadecimal"
1180560,1188000," literals start with a zero x, right? So, and our thing, uh, which is called try parse hex doesn't"
1188000,1194720," know about that prefix because that thing is like more general one. It just parses only hexadecimal"
1194720,1200640," numbers and it doesn't parse the hexadecimal literals, right? And hexadecimal literal is slightly"
1200640,1206720," different thing than just a hexadecimal number. It's a prefix zero x plus the hexadecimal number."
1206720,1213920," Uh, so I think one of the things we can try to do maybe wrap all of that into a special"
1214880,1224160," uh, function, right? So try parse, um, number literal or something like that. Uh, try parse"
1224160,1230800," number literal and here we're gonna accept the string, right? So accepting the string"
1230800,1236720," and, uh, we're gonna return an integer and a boolean indicating whether we successfully parse this entire"
1236720,1243360," thing or not. Right? So the first thing we want to probably check is whether this entire thing starts"
1243360,1251280," with zero zero x for instance. Um, right? So in the standard library we should have something for that."
1251280,1264720," Uh, std.porth, uh, str starts with, right? So the prefix is going to be zero x, then n and s str starts with."
1264720,1271760," And if it starts with that, right? If it starts with that, uh, what we're going to try to do,"
1271760,1279040," we're going to try to parse it as a hexadecimal thing, but, uh, we'll have to remove that prefix first,"
1279040,1289120," right? So this is going to be n, oh boy, um, n two minus, right? And then s two pointer plus,"
1289120,1299280," and we're going to do try, uh, parse hex, try parse hex. Is that enough? Right? If we didn't manage to"
1299280,1306640," parse it as a hexadecimal thing, what should we try to do? Right? Because we know this thing starts with,"
1307280,1322480," zero x. So if it was successful, we can just try to say true return. Right? And if it wasn't successful,"
1322480,1332240," if it wasn't successful, we can probably just drop whatever we had and try again. Right? So we can try to"
1332240,1342320," do n and s and then say try parse integer and yeah. So, and then in here we'll be able to add more,"
1342320,1348560," uh, literals. Right? So maybe octal literal and the octal literal is the one that starts like maybe with zero"
1348560,1357840," o. Um, right? And it's going to be like literally something like this. Um, so we can even say something"
1357840,1369520," like to do, uh, octal parsing octal literals is not implemented yet. Right? Something like this. And, uh,"
1369520,1381520," also it would be nice to have, uh, the binary literals and sstr starts with parsing binary literals is not"
1381520,1389680," implemented yet. Right? Stuff like that would be really, really nice. Um, so, and then if neither of"
1389680,1395280," those things succeed, we can just try to parse it as an integer. And if that thing failed, uh, the entire"
1395280,1401840," stuff is also failed basically. Um, okay. So let me try to compile the compiler to see if all of that,"
1401840,1408000," you know, is sound. If all of that type checks and all of that type checks apparently first try by the"
1408000,1419280," way. Um, that's, that's exciting. Uh, now I can try to try parts number literal and let's see if it compiles."
1419280,1426880," It seems to be compiling. Right? So now we should have a compiler that supports the, uh, hexadecimal literals."
1426880,1434160," Okay. So I didn't expect that that would be this easy. Um, now I'm going to include the"
1434160,1444640," std.port and then, uh, just do the following thing. Okay. So let's try to print 69. Uh, right. So"
1448080,1456960," uh, excuse me, what am I doing? I think I'm being an idiot. Okay. Uh, so this is a 69. And let's try to"
1456960,1463840," do something like ff. This should not work because there's no such, uh, word. Right? So, but if I put"
1463840,1471680," the prefix, right, it should work. And it worked. We have hexadecimal, uh, literals. Would you look at that?"
1472640,1483920," Uh, that's pretty cool. Okay. Uh, so if I try to like have, uh, octal once, right? So 777, it should"
1483920,1489280," not work if I understand correctly. Right? But it will also say that parsing octal literals is not"
1489280,1494000," implemented yet. Right? So the only thing you need to do, you just need to implement that. Uh, and then"
1494000,1502080," we can do the same thing for binaries. Right? So this is gonna be one, um, zero zero one. Right?"
1502080,1510000," Something like this. Um, all right. What am I doing? I should have actually removed that. Uh, parsing"
1510000,1517600," binary literals is not implemented. Okay. So what if we have this kind of stuff, right? What if we have this"
1517600,1523920," kind of stuff? So it tries to recognize it as a word, right? So it does not recognize it as an integer."
1523920,1532400," It recognizes it as a word. So that means I can define this thing like, uh, this, right? Which is"
1532400,1539840," rather interesting. But if I try to define it like this, it will be considered a word. Yeah, that's very"
1539840,1546800," interesting. So this is a number. You can't use it as a name for constants, but this is not a number and"
1546800,1553520," you can use it as a name for constants. It's really interesting, but I don't know how to do that better"
1553520,1560560," yet. And I don't think it matters that much. So whatever we have right now semantically is okay. Uh,"
1560560,1567600," right. I think it is in fact, okay. Um, all right. So that's basically everything that I wanted to"
1567600,1573280," showcase today. So we introduced early return and this is how early return makes it super easy to"
1573280,1579440," sort of like short circuit the, um, you know, error cases, right? So when you just like do the usual"
1579440,1584880," logic, the happy path, you encounter something, something bad, and you basically short circuit the"
1584880,1589760," entire procedure indicating that some sort of error has happened. And, uh, every return just makes it"
1589760,1596320," easier. And it's a nice addition to the language, right? It's a nice addition to the language. So that's"
1596320,1601920," basically it for today. Thanks everyone who's watching right now. I really appreciate that."
1601920,1608240," Have a good one. And I see you on the next recreational programming session. Love you."
