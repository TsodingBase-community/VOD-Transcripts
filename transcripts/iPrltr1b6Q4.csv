start,end,text
960,11040," Today I woke up and chose the violence. Today we're implementing ""go to"" in OCaml. Let's get started."
11040,16880," So let's start with implementing ""hello world"". Right, so let's create a file and let's do ""let"""
16880,22240," parenthesis because this is how you define an entry point in OCaml and let's do print and line"
22240,29600," ""hello world"". Right, so essentially it will just print this string and put ""hello world"" at the end"
29600,34320," of the output. Right, and we're going to call the OCaml compiler. Right, so we're going to compile"
34320,40880," this entire thing and that should produce an executable ""a.out"" which you can then run and it"
40880,45520," will say ""hello world"". It's not particularly a real executable. Right, if you take a look at the file"
45520,51920," in here it will not say that it's an ""elf"" executable, it will say that it's a script executable with binary"
51920,57360," data. Right, that's kind of sus, isn't it? And this is because it's actually bytecode. Right, so they're"
57360,62880," using a very interesting trick in here where they just compile all of that into byte code and then"
62880,69520," they append ""shebank"" with OCaml run that just executes that bytecode as a script. Right, but of course"
69520,76480," in OCaml you can actually compile into a native executable if you want to. OCaml opt.ml. Right,"
76480,83680," and that will produce an actual and native executable F64 bits, LSB blah blah blah. So the usual stuff."
83680,89520," But for our case, I don't think it matters. I don't think it matters that much. So anyway,"
89520,98480," how would you print ""hello world"" for example 10 times? You know, the computer science freshman"
98480,106000," would probably write a recursive function. Right, so let's create something like ""hello"" function. Right,"
106000,112320," and this function will probably accept a counter. Right, it will count 10 times and then it will quit."
112320,118000," So this entire thing accepts an integer and in here one of the things we can do, we can check if i is"
118000,129040," less than 10. Right, then we are printing ""hello world"" and then we're calling ""hello i+1"". Right, so that's"
129040,135920," what we're essentially doing and otherwise we're just exiting this entire thing and then we do ""hello 0"". Right,"
135920,141280," and if we actually compile this entire thing, as far as you know we can even just like run with"
141280,147680," interpreter without like missing the compilation step and it should work, but it doesn't because ""hello"" is"
147680,154240," an unbound variable. It is in fact an unbound variable, even though we just defined it. And"
154240,159120," this is because it's not visible within the function itself. To make it visible within the function, we"
159120,166160," need to mark it as a recursive. Right, and only then it will allow us to do all of that. We can even probably"
166160,172880," maybe even print the number of the iteration. So to do that we probably want to use ""printf"". Right,"
172880,179440," where we're going to do ""d"" and a new line ""i"". And then I'm going to do the following thing, but we don't have"
179440,186000," a ""printf"", because this is not a ""c"". It's a ""soy"", a ""camel"". So what we have to do, we have to actually import"
186000,193280," ""printf"" from a separate module. Right, there we go. And now it actually works. Okay, that's cool. But"
193280,200080," people write code like that because they're bad-shit scared of for loops. But we are professional software"
200080,206880," developers who are not scared of for loops. So let's go ahead and rewrite this entire thing using"
206880,211760," for loops. Right, so I'm going to write ""for"". I think, you know, ""camel"", you do it like in Pascal. Right,"
211760,218640," so ""from 0 to 9"", ""do"". And I'm going to take the printf, I'm going to put it in here, and I'm going to put"
218640,225840," ""done"" in here. There we go. I might as well comment out this entire thing super quick. And let's actually"
225840,231360," try to run it. And it's an error, so I think... Yeah, there we go. So yeah, you don't have to put ""call"""
231360,239280," here because it's from Pascal. Anyway, so this is how you write with for loops. But again, both of the"
239280,247600," solutions, they kind of avoid a very important thing, and that thing is mutable variables. Right, that thing is"
247600,253040," mutable variables. Again, we are professional software developers. We're not afraid of mutable variables."
253040,260080," Let's go ahead and introduce a mutable variable like so, and rewrite this entire thing using while loop."
260080,267760," All right, so while... So to read from a ref, we have to do ""excelenation mark i"". So essentially,"
267760,275600," ref is a mutable cell. So the thing about the camel is that it's kind of like a half pure"
275600,282080," functional programming language where everything is immutable. But it has some hacks that allow you to"
282080,288000," have mutable variables like ref cells. Right, so and what we're doing in here, we're creating a ref cell"
288000,295680," where we put a value 0. And to read a value from that from that ref cell, we have to actually put this"
295680,303200," operator. Right, so it's not ""not"". Right, it's a dereference this value. So if you want to use ""not"","
303200,308320," in a camel, I think you have to do ""not"". Yeah, so they basically made it like that. Right, so we're"
308320,316240," reading ""i"" and while it's less than 10, right, we're printing ""hello world"". After that, we have to mutate the"
316240,322800," variable. Right, and to mutate a ref cell, you have to use the double-dig operator like in Pascal. And this"
322800,327520," is why I thought that in for loop you have to use also like a column in there. Right, so what you're"
327520,332960," going to do in here, you're going to just basically read the value and add one in here. And there you go."
332960,338640," We re-rolled this entire thing using wire loops. Right, so if we try to run it, it doesn't really work"
338640,345120," because you have to read ""i"" in here. There we go. So it also works. So obviously, this solution is way more"
345120,358400," superior than this soy boy computer science student's comp soy solution. Yeah, obviously, this solution is"
358400,366960," more superior than this comp soy solution. So we're going to nuke that out of the codebase. So, all right,"
366960,374320," that's cool and all, but there's even more chad solution than this. And that solution would involve"
374320,386480," goto, right. Unfortunately, being the comp soy language OCaml is, it doesn't have a chad goto construction."
386480,394400," But let's actually hallucinate like chad gpt that it does have goto. How would we implement all of that? Well,"
394400,401360," first of all, I would probably just remove all of that, first of all, right. So, and I would create a"
401360,410720," label loop, right. I would create a label loop. And then at the end of the loop, I would basically go to"
410720,417520," in here. So, I think Emacs have a stroke, right, because we're using syntax that doesn't exist"
418320,424240," in a camel, right. So, we do something like go to loop in here. And we also need to have an exit"
424240,433280," condition, right. So, essentially, what we can do, we can say if i is less than 10, right, maybe greater or"
433280,439440," equal than 10, then we're going to do go to out of the loop, right. So, we need to create some sort of a"
439440,446320," label outside of the loop somewhere here. So, it's called out, and basically go to out. Otherwise, do"
446320,453200," nothing, right. So, and essentially how such loop would work, right. So, you initialize the ref cell"
453200,459600," with zero, then you enter the loop, you check that it's greater or equal than 10, and if it's not, you just"
459600,466400," do literally nothing, just do nothing, then you print ""hello world"", then you increment the iterator,"
466400,474720," and then you go to the loop, effectively repeating these three actions again, right. And this time i"
474720,479440," is going to be equal to 1, it's still less than 10, so it's going to do another iteration until it becomes"
479440,485520," equal to 10. And in that case, it will encounter out, it will go to the out, and it will just go in here,"
486320,492160," where we're going to print something like ""done"", right. So, let's actually print something in here to sort of"
492160,499120," signify that we're done doing this entire thing, right. And that is the most chat solution that you"
499120,506560," can come up with. Real software developers write code like that all the time. So, and, but unfortunately, this"
506560,513520," is not going to compile in a camel. Like, this is a syntax error, right. Straight up syntax error. Like, we can't"
513520,519920," even implement that thing on the level of a library, we literally have to hack the compiler to introduce"
519920,526560," all of that. So, maybe we should simplify ourselves the work, right. So, let's actually make it syntactically"
526560,534080," a correct camel, at least, right. So, let's make it syntactically a correct camel. So, what if we introduced"
534080,542720," all of that as a function calls, right. So, what if I said that label is just a call to label, right. It's a call to label."
542720,550240," All right. So, go to is a call to function, and it accepts the strings, right. So, I'm accepting the strings in here, right,"
550240,557040," because, you know, they will not cause the compilation error, right. So, they will not cause a compilation error,"
557040,562960," because if I do something like this, it will say loop is unbound name, and I don't even know, like,"
562960,568720," where to get that. So, it's way easier to sort of refer to the labels as strings, right. So, let's refer"
568720,575120," to the labels as strings. So, I think that would make sense. All right. So, this is already something,"
575120,579840," this is already an interesting approximation of what we want to create. And this thing is already,"
579840,588480," technically a valid OCaml program, right. So, it just doesn't have values label and values go to, right."
588480,594080," If we try to compile this into, I think it will just say, you know, unknown label. How do you spell label,"
594080,599440," by the way? Do you spell it like a label? Yeah, you spell it like a label. What the fuck is wrong with me? Sorry."
599440,608640," Right. There we go. So, this is a label. So, if we technically create these functions, right. So,"
608640,615200," this is basically the name of the label, right. In this case, it returns nothing and go to also accepts"
615200,623200," the name. There we go. It turns nothing. It will compile, but it won't work correctly, right. Because"
623200,629280," all of that kind of fell through. All of that fell through. So, essentially, what we need to do,"
631440,640000," we need to interrupt the control flow when we encounter go to. So, what kind of mechanisms in"
640000,648240," OCaml do we have to interrupt the usual control flow of the of the commands? That mechanism is called"
648240,655600," exceptions. Right. What if we made so that go to throws some sort of an exception? Because when we encounter an"
655600,662240," actual go to, we have to, we should not continue the execution. We should jump somewhere else."
662240,668560," The only way to jump somewhere else we have in this comp_soil language is exceptions. Right. So,"
668560,672960," let's create an exception. Right. So, this is how we create exceptions in here. As far as I know,"
673680,682080," go to of, and let's actually pass the name of the label, right, to which we want to jump. Right. So,"
682080,689200," let's actually pass it in there. And when you do go to, we're going to raise the go to of the name."
689200,694160," Right. So, this is basically name. Maybe I should call it a label. Yeah. Let's keep it name. Whatever."
694160,699280," So, let's actually try to compile this into that thing. And it's, I think it's a syntactical error,"
699280,704320," right. So, straight up syntactical error because you have to wrap it into parentheses. And there you go."
704320,710640," And it has a little bit of warnings. Right. Because this thing, when you enter go to, you kind of never"
710640,719040," return. Right. You kind of never return. So, okay. That's cool. So, go to interrupt the usual sort of"
719040,726320," like way of executing the usual control flow. So, what we need to do, we need to kind of catch this"
726320,735440," exception. Right. Somewhere like outside of this block. And then from that place where we caught that"
735440,741680," exception, we have to jump to either of these labels in here. Right. It would be kind of cool. Right. To"
741680,749600," just do try. Right. So, try catch. Right. So, this is how try catch looks like in OCaml."
752080,759600," And here we would do something like go to name. And this is we would somehow jump. Somehow jump to"
759600,767120," either of these labels. Right. Depending on what kind of name we got in here. Right. So, but that's kind of"
767120,772160," kind of difficult. Right. So, again, that requires go to. But we are trying to implement go to."
773360,780880," So, essentially, what I'm thinking is that if you look very close, labels in imperative languages"
780880,790480," generally, they form blocks. They're essentially as separators of blocks of codes. Right. So, if you"
790480,798640," have several labels in here. So, A maybe B in here and some more commands in here. Full bar buzz."
798640,805520," Essentially, each label is associated with its own block. Right. So, we have a block loop. We have a"
805520,812160," block A. We have a block out. We have a block B. And so on and so forth. What if we take each individual"
812160,820560," block and wrap it into a separate function and associate a name with that function? That way,"
820560,827840," we can work with these imperative blocks in the functional paradigm. Right. So, this is kind of"
827840,831600," interesting. So, let's actually remove all of that redundant stuff in here. So, I put that for"
831600,836960," demonstrations. But effectively, what we have in here, we have two blocks. We have a loop block and we have"
836960,842240," out block. Right. So, let's actually wrap the loop block with a function. Right. So, it's not going to"
842240,848800," accept any arguments. So, it's going to be just that. So, this is the first block in here. Right. And the"
848800,855760," second block in here is this one which just prints done. Right. There we go. So, we have two blocks in"
855760,864000," here. And probably, we want to take both of the blocks and we want to put them into a list of pairs."
864000,869600," The label, the name of the block and the code of the block. Right. So, let's actually try to do the"
869600,877200," following thing. Right. So, this is going to be that. All right. And I wonder if it's going to be even"
877200,884800," readable. So, this is the first pair. Right. And this is going to be the second pair. There we go. And we can"
884800,892560," already form a list out of that. Right. So, we can form a list out of that. There we go. So, this is the list."
892560,900080," And this is basically the blocks. Right. So, this is basically the blocks that we need to execute."
900080,908000," So, and essentially, what we want to do, we want to have some sort of engine that would allow us to"
908000,915920," start executing the blocks from a certain name. Right. So, essentially, we can even move the blocks"
915920,920400," out of the outside of the try-catch, like completely. Let's actually try to move them in here."
920400,927120," Right. So, something like this. So, this is the blocks. I wonder if we can just make it a little"
927120,932800," bit prettier if I move it somewhere here. Yeah. It looks a little bit prettier. So, and essentially,"
932800,939440," we would have some sort of a code in here, some sort of a code that executes the blocks. Right. They"
939440,946640," execute the blocks. And if blocks throw an exception, we would catch this exception and we would execute"
946640,953600," the blocks again, but starting from that specific name and continue. Right. So, because the blocks will"
953600,958720," fall through. Right. If you continue execution from one block, it will fall through into another one and"
958720,963680," so on and so forth. In our case, it won't because at the end of the loop block, we have go to loop,"
963680,970640," which jumps back to the loop. But generally, that engine has to do something like that. Right. And"
970640,978960," I'm thinking maybe we should have something like, I don't know, a function called go to block. Right."
978960,987600," That would accept the blocks, which are essentially a list of the pairs. Right. So, this is a list"
987600,994960," and it accepts the pairs string and the code, the function from unit to unit. Right. The function"
994960,1000960," from unit to unit. And it will basically also return unit. So, it doesn't really do anything. Right. It"
1000960,1008480," doesn't really do anything. Right. And essentially, we probably want to try to move this entire code in"
1008480,1015760," here. Right. And it's nice to have this as a function because we'll be able to recall this function in here."
1015760,1023600," Right. So, essentially, if we caught a name. Right. We want to execute go to block again,"
1023600,1029840," but already on that name. Right. So, we would pass the blocks, but we also need to pass the name somehow,"
1029840,1038480," which implies that we also need to pass the name in here. Right. So, as an argument. Right. So, this is"
1038480,1044160," the name. So, we keep passing it. And since we basically made this function recursive, we need to mark"
1044160,1049920," it as a rack. Right. So, this is basically how the engine sort of starts to take the shape. Right."
1049920,1056800," Right. Essentially, what we have to do here, we have to start executing the blocks starting from name."
1056800,1062000," Right. And just like iterate through the blocks. Right. So, we can take the blocks. We need to start"
1062000,1072080," iterating through them. And in here, we should essentially execute each individual block. Until one of the blocks"
1072080,1077200," will throw go to exception. And as soon as the go to exception is thrown, we're going to catch it in"
1077200,1083520," here. And we're going to rerun go to block, but with a new label, which will effectively jump to the next"
1083520,1090000," block, to the other block. Not really next one, but the other one. So, there is a little bit of a"
1090000,1096800," problem in here. Right. So, we have to first initially call go to block in here with blocks. But we need to"
1096800,1100960," specify the label from which we're starting to execute, which is not particularly convenient,"
1100960,1107840," because I want to execute starting from the first one. Right. So, what would be the like a good way to"
1107840,1114720," sort of resolve that? We can basically make the label optional. Right. So, label could be essentially"
1114720,1122320," optional. And essentially, if you didn't provide the label, the engine, right. So, our engine should start"
1122320,1128400," executing from the first one. So, that way we shouldn't really worry about any of that. So, here I would say"
1128400,1136400," none. Right. So, this becomes none. And here I would actually pass the sum. Right. Because if somebody called"
1136400,1142160," go to from within the blocks, we do have a name. Right. So, when we sort of materialize this name in here."
1142160,1149200," Right. So, this is not particularly convenient in a sense that users still have to provide this none in"
1149200,1155360," here. Right. It would be nice if none was sort of like default. Unfortunately, OCaml doesn't have"
1155360,1162000," default arguments. It doesn't have default arguments. But there is a trick to basically wrap everything into"
1162000,1169520," like an outer function. Go to block. Right. Where you accept just the blocks. Right. You accept just the"
1169520,1174800," blocks. This becomes an inner function. Right. So, this becomes an inner function that you then"
1174800,1179360," call. Right. So, you probably want to give it a different name. Right. So, it's going to be"
1179360,1184880," implementation. You want to call blocks and the default value of this entire thing. That way, you don't"
1184880,1190560," have to provide this thing in here. So, furthermore, we can even make it syntactically look nice. Right."
1190560,1196160," So, we can just inline these blocks in here. Right. We're inlining all of these blocks in here."
1196160,1203520," And there you go. So, essentially, you have a special function into which you pass this block."
1203520,1208560," And if we implement everything correctly, it should work like a loop. Right. So, you should be able to"
1208560,1214080," basically jump between different blocks. Right. And it turns the whole thing"
1214080,1220400," into sort of like a state machine in some sense. Right. So, basically, you are being in one state"
1220400,1227200," and then you can explicitly switch to other states. State out or state go to loop. Or if you didn't"
1227200,1232240," switch to any of the state throughout the block, it will just fall through to the next state. Right."
1232240,1236320," It kind of feels like a little bit like a Turing machine. Right. So, but yeah, essentially, it's a"
1236320,1243680," it's a state machine. Right. That's kind of cool. And yeah, this is how go to essentially works."
1243680,1248480," Right. It's essentially how it works. All right. So, what we need to do in here. Right. What we need"
1248480,1257680," to do in here. I'm thinking we need to distinguish between whether we have a name. Right. So, because"
1257680,1263680," name is option or we don't have a name. All right. The easiest case is when we do have a name. Right. So,"
1263680,1271760," with some label. Right. So, with some... Actually, the easiest case is when we don't have a name. Right."
1271760,1277040," When we don't have a name. Because in that case, what we have to do, we have to just go and iterate"
1277040,1281840," through all of the blocks and call them. Right. So, I'm going to do blocks and then I'm going to do a list."
1281840,1286240," I'm going to iterate through this entire thing. So, here we get the labels and we don't care about"
1286240,1290240," the label. We're going to ignore it. But we do have a block. And what we're going to do in here,"
1290240,1295600," we're going to just call that block. And that is it. This is the easiest case. Right. This is the easiest"
1295600,1301280," case. So, the other case is when you do have some sort of a label in here. Right. So, I think"
1301280,1307520," I think we can just do that in here without any parentheses. So, in that case, we have to skip"
1307520,1317360," like everything until we have a label. Right. So, basically, drop the elements until you encounter"
1317360,1323520," the label with which you have to actually call until you encounter the name. Right. And I wonder if a camel"
1323520,1330000," even have like something like ""drop while"" like in Haskell. I don't quite remember. So, let me actually"
1330000,1335200," see. So, I want to take a look at the list. All right. So, what do we have in here? So, is there"
1335200,1340720," something like ""drop while""? I don't think so, actually. A camel standard library doesn't really have"
1340720,1347280," shift drop. Yeah, there is no drop. It's actually kind of sad. We could try to implement something"
1347280,1359360," ourselves or we could have maybe some sort of like a special function. What if we could use the name"
1360000,1367760," as sort of an indicator that we... Yeah. So, essentially, we can introduce two states."
1367760,1375200," In the first state, we are skipping the labels that we don't care about. And in the other state, we're"
1375200,1383600," executing all of the labels. Right. So, and if we are in a state that skips the labels and we encounter the"
1383600,1389440," label that we're interested in. We switch to the state where we start executing the labels. Right."
1389440,1395760," Something like that. That's a very interesting approach in here. And we can use the name as an"
1395760,1405520," indicator which state we're in. Right. So, essentially, if name is not present, we are in a state that keeps"
1405520,1416480," and looks for a specific label in there. Right. Something like that. So, that's actually very"
1416480,1424560," interesting. And the iterator for this entire stuff can be the go-to block. Right. I think. I think it"
1424560,1428640," could be the go-to block. Or maybe it could be actually internal function. I think it should be an internal"
1428640,1437040," function. Right. So, let's try something like this. So, I don't really know how to call that function."
1437040,1443520," I'm going to call it go. Right. And so, we don't really have to pass the blocks in here because we're"
1443520,1449920," getting them from here. Actually, that means we don't even have to pass the blocks in here. Yeah,"
1449920,1455280," that's actually a very interesting idea because we have the blocks already in the scope. We are basically"
1455280,1459760," capturing them from the outer scope. So, we don't really need this stuff in here. Which means we"
1459760,1464320," don't really have to pass the blocks in here. Right. And we don't have to pass them in here. There we go."
1464320,1471440," So, we can actually simplify, like, you know, greatly this entire stuff. Okay. That's cool. So, that means"
1471440,1479840," here, if we're going to have some sort of a go, we only have to pass the name. Right. So, we only have"
1479840,1489680," to pass the name. And essentially, if the name is not present, right, if the name is not present, we"
1489680,1497040," just execute the block, the current block. But we don't have the current block, which means that we"
1497040,1502320," should have the blocks in here. Right. So, we should have the blocks in here because this function is going"
1502320,1509440," to be iterating through the blocks. All right. So, it's going to be iterating through the blocks."
1509440,1513920," All right. So, and essentially, what we need to do in here, we probably need to match"
1513920,1521840," both blocks and the name. Right. So, both blocks and the name. If the blocks that we have in here"
1521840,1527200," empty, it doesn't really matter what kind of name we have in here. Right. So, essentially, we should stop the"
1527200,1532480," execution. Right. So, the execution has stopped. So, maybe I'm going to put unit in here and unit in"
1532480,1538720," here. There we go. If we do have some blocks in here, right, we usually have them in the form of"
1538720,1550960," name, name and block. Right. And the rest of the blocks. And then, if we don't have the name in here,"
1550960,1556800," right, if the name in this particular case is none, what we have to do, we have to essentially ignore"
1556800,1563440," the name. So, maybe we can just, like, say name is ignored. Run the block. Right. And continue the"
1563440,1571680," execution with the rest of the blocks. And none name. Right. I'm not really sure if I have to wrap this"
1571680,1576800," entire thing in parentheses. Right. So, probably not. Right. I think I shouldn't actually do that."
1577520,1585040," Right. So, and let's take a look at the situation when we do have a name in here. Right. When we do"
1585040,1590240," have a name in here. So, and let's call this name something like, so it's an entry into which we have"
1590240,1597840," to actually jump. Right. So, this is going to be an entry. So, and in that case, if entry is equal to the"
1597840,1608160," name. Right. If entry is equal to the name, we have to run the block and essentially switch to a different"
1608160,1616560," state. But maybe we don't really have to do that. So, we can do something like string equal name entry. Right."
1616560,1623760," So, if we found the label, if we found the label that we need to execute, what I can do, I can run go again."
1624960,1634320," But essentially with this full block. Right. With this full block, but without the name,"
1634320,1641600," which effectively switches to the state where it just keeps executing the blocks. Right. Right. Otherwise,"
1641600,1649520," otherwise, if it's not what I think it is, what I have to do is keep executing. Right. Keep executing."
1650080,1658240," But with some entry. Right. Unfortunately, yeah, that might work actually. I think I think that might"
1658240,1664960," work. Yeah. Okay. That might work. So, this is basically the iteration. Right. So, it will skip the"
1664960,1672320," blocks that we don't care about. And then, as soon as it encounters the block that we care about, it will"
1672320,1677440," continue executing the start from there. Right. And then here, what we want to do, we want to run blocks"
1677440,1680400," name. Right. So, we run blocks name."
1680400,1687440," So, that's rather interesting. That's rather interesting. So, let me see if this entire thing"
1687440,1692880," will even compile. Let me just try to compile and go through the compilation errors. Okay. So, this has to be"
1692880,1703280," multiple blocks. These go unbound. We have to make it recursive. This one is another one. And this one"
1703280,1712800," is another one. Right. So, we call... Yeah. Okay. So, go to block. Unbound. Yeah. This one has to be"
1712800,1720720," implementation. Let's go. So, and it seems to be compiling. It seems to be compiling. So, if I try to now run"
1720720,1728880," this entire thing, will that it works. Right. It freaking worked. So, yeah."
1728880,1740000," Essentially, if you... And what's funny is that this is implemented basically in a pure functional way."
1740000,1749760," If we just close our eyes on try catch, like all of that is pure functional way. Right. So, it's kind of"
1749760,1756240," interesting. Right. But yeah, there you go. So, this is how you can implement go-tos in a camel in purely"
1756240,1760000," functional language. But it's actually not really purely because it has states and stuff like that."
1760000,1766960," But yeah. So, you can think of labels as actually blocks. Right. And you have a sequence of blocks"
1766960,1773920," that fall through each other. Right. You fall through each individual block. Right. And then,"
1773920,1778400," when you want to jump to a different block, you throw an exception, you catch the exception"
1778400,1785200," above. Right. And then, you jump to the corresponding block. Right. And it's more of a like a jumping"
1785200,1791040," between different states. Right. So, it's sort of like a state machine. Right. So, I think it's kind of"
1791040,1795120," an interesting way of looking at this intense stuff. Right. So, it's kind of an interesting way of looking"
1795120,1802400," at this intense stuff. Right. I was also thinking... Okay. This particular approach works. But I was also"
1802400,1810960," thinking maybe to iterate all of that in two mutually recursive functions. Right. So, right now, we have this"
1810960,1817680," one single go function. But what if we had... What if we split it into two separate functions that do two"
1817680,1823360," separate things? Like the first one just skips everything until it finds the label. And the other"
1823360,1831680," one just executes everything. Right. So, if we had something like execute... Just execute. And it accepts"
1831680,1836800," the blocks. Right. So, this entire thing accepts the blocks. And it doesn't accept any name because it"
1836800,1843520," doesn't care. Right. So, it just executes all of the blocks. So, in here, we would do something like..."
1843520,1852880," We would just say it's list iterate blocks. And it's just going to be that. Right. So, this is the block."
1852880,1861280," And we would just call that specific block. Right. And we can even pipe this entire thing into this"
1861280,1866480," function. What's funny is that I am... I actually been programming in the camel for quite some time"
1866480,1874640," already. Right. And I've been programming since this pipe operator didn't exist in a language. Right."
1874640,1881520," I remember the times when this operator didn't exist in language. You guys know that? Right. And essentially,"
1881520,1889040," they introduced that operator after F# introduced it. So, OCaml didn't really invent that operator. It's"
1889040,1896160," F# that invented that operator. And then OCaml kind of stole that from F#. Right. So,"
1896160,1900880," that's kind of an interesting thing. I do remember that time. So, I don't quite remember when it was"
1900880,1906000," introduced. Like, OCaml stdlib. So, it's actually take a look. So, the standard library should actually"
1906000,1913440," contain the date of introduction or at least the version at which it was introduced. So, if we search"
1913440,1921680," for the pipe operator... Right. So, here's the pipe operator. In scenes 4... Yeah. 0-1. Okay. OCaml releases."
1921680,1930400," OCaml releases. So, here are the releases. I want to take a look at the historical releases. So, it was introduced"
1931760,1944080," 4-0-1. Uh-huh. 4-0-1. Okay. So, what was the date? 2013. Right. But I programmed before that."
1944080,1950480," Uh... I think I remember programming in OCaml 3. Yeah. I vaguely remember programming in OCaml 3."
1950480,1961840," So, it was in 2011. Yeah. So, uh... I programmed in OCaml at this version. And that version, like, really"
1962800,1968640," was different kind of. Right. And it was different culturally. Right. So, things like OCaml, Dune,"
1968640,1973920," and some other stuff were not a thing. So, everyone was using, like, OCaml distribution directly and"
1973920,1980480," everything like that. So, yeah. Kind of interesting. So, the language of suddenly evolving and becoming"
1980480,1987200," popular for whatever reason. Okay. So, this is the execution. Right. So, the problem in OCaml is that you"
1987200,1995120," can't really have mutually recursive functions. Right. Because, um... it's a one-pass compiler. Right."
1995120,2000720," So, essentially, if you want to call... maybe here we don't even need to have a mutually recursive function."
2000720,2008880," Right. Because, uh... exec is not going to call to anything that is below it. Right. So, something... we"
2008880,2016240," probably will have to only call a skip. Right. And skip is going to basically skip the names until it finds the"
2016240,2022720," label that it cares about. And we'll call exec. Right. So, I think in that case, yeah, we don't really need"
2022720,2026960," the mutual recursion. Right. In case of mutual recursion. Right. If you want to have two functions"
2026960,2031200," to call each other, I think you have to put something like ""and"" in here. But then... don't quite remember."
2031200,2036720," But I don't think we need it in here anyway. Right. So, we're going to have blocks. Right."
2036720,2045920," So, and in here, since we do have a name, I don't think that name needs to be... needs to be that."
2045920,2051200," It needs to be option. We can just make it not option, which will actually simplify this entire stuff"
2051200,2056800," dramatically. So, we're going to do match. Oh, and by the way, here, we don't really call exec to itself."
2056800,2060080," So, we don't really need to reckon here. But whatever. The compiler will tell us probably."
2060080,2066400," Anyway. So, here, what we want to do... Right. We want to take a look at the blocks. Right. So,"
2066400,2074720," this is the blocks with... So, if we don't have anything in here, we're going to say that's it. We don't call..."
2074720,2085360," We don't do anything. All right. Then we're going to have the... this stuff. Right. So, and if"
2087040,2096400," name is equal to... We should call it an entry. That's for sure. If it's equal to an entry, then we have to"
2096400,2104320," just do exec where we're going to call this entire stuff like this. Right. Without any name or anything"
2104320,2109760," like that. Otherwise, we're going to keep skipping. Right. So, we're going to do... You know what?"
2109760,2119360," I think I want to call it rest. No, not this one, but rather rest. And then here, I'm going to just do"
2119360,2129760," blocks. And then I'm going to keep skipping the rest. Yeah. Yeah. That's cool. And then I'm going to"
2129760,2135920," here provide the entry. Right. So, I don't really care about this block in here. So, I think I'm going"
2135920,2141440," to actually ignore it. Right. There we go. So, I'm going to ignore it. And I think that's basically it."
2141440,2148080," Right. So, I'm looking for the entry. I'm looking for the entry. If I found it, I start executing this,"
2148080,2153920," like all of the blocks, including the first one that I got in here. If it's not equal, I just skip this"
2153920,2160720," entire thing. Right. And then, yeah. So, I basically split this entire logic into two separate functions."
2160720,2167760," And I think that should work. I kind of think. But we still need to have some sort of a logic that"
2167760,2173520," checks whether the name was provided or was not provided. Right. So, I'm going to just command this"
2173520,2181840," thing out super quick. And in here, we're going to do match name. And if it's none, we just execute the"
2181840,2192320," blocks, right, that we got in here. Right. Otherwise, if we have some entry, right, we have to skip the"
2192320,2197440," blocks for that specific entry. And that's going to be it. Right. I think it's a little bit easier to"
2197440,2205440," understand. Right. So, because we essentially split this entire stuff. Yeah, it still works. So, we can just"
2206000,2213360," go ahead and remove this entire thing. We can just go ahead and remove this entire thing."
2213360,2226480," That is actually... Huh. Where is the catch? Did I just accidentally... Yeah, I think I did..."
2227440,2236480," Yeah, I removed more than I... Yeah. So, I selected the whole block. And like Emacs selected stuff, including"
2236480,2243760," the catch. Seriously, Emacs? So, that's why I was confused like that. All right. So, what I wanted"
2243760,2250560," to do in here is just like... Imagine using Emacs in 2023. My gut. Anyway, so this seems to be working. All right."
2251360,2259440," So, that's pretty cool. So, this is how I personally would implement GoTo in a camel. Right. If you have"
2259440,2265120," better idea on how to implement it in a camel, please leave a comment and let me know. I'm going to upload"
2265120,2271680," all of that to GitHub and put the link in the description. And I guess that's it for today."
2271680,2277280," Thanks, who's watching right now. I really appreciate that. I hope it was fun. I hope it was educational. I hope it"
2277280,2284960," changed your perspective on GoTo's. Right. So, because it's sort of like a different way of thinking of GoTo."
2284960,2292320," Not like in terms of spaghetti, even though it still kind of is spaghetti, but in terms of, you know, separate"
2292320,2297840," states and transitions between the states. Right. Because it's a state machine and we're working with"
2297840,2303840," state machines like all the time. And that's why, by the way, GoTo's like in C, they're quite useful for"
2303840,2308640," parsing. Right. So, because you have a parser that switches the states and sometimes it's easier to"
2308640,2314960," just like use GoTo in that specific case. Right. So, yeah. Anyway, thanks everyone for watching,"
2314960,2319760," and I see you all on the next recreational programming session with Azuzin."
