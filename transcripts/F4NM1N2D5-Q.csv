start,end,text
0,5840," Looks like we're live! Hello everyone and welcome to yet another recreational programming session"
5840,15280," with Azuzan. Forgive me my tracksuit, I'm just Russian. It's a little bit cold inside so I had"
15280,21760," to just put something that is a little bit more warm than a t-shirt. There's also some problem"
21760,27760," with my windows so it's a little bit cold inside. Outside we can actually check out how much it is"
27760,35600," outside. So minus 28. It's actually a little bit warmer than it was yesterday. I think yesterday"
35600,42400," it was almost minus 40. So it's getting warmer. It's getting warmer so which is actually quite nice."
42400,49520," Which is actually quite nice. So let's make a little bit of an announcement. A red circle live on Twitch"
49520,55520," and the question is what are we doing today on twitch.at television website? Today we're"
55520,63360," hacking Erlang. That's right. I'm going to give the link to where we're doing all that twitch.tv/adsodding"
63360,67040," and I'm going to ping everyone who's interested in being pinged and there we go the stream has"
67040,74320," officially started. The stream has officially started. So today we're hacking Erlang. That's right. Does"
74320,80480," anybody know this beautiful beautiful programming language? So yeah it's a programming language for"
80480,85920," distributed systems right? So for concurrent distributed systems right? So it's a functional programming"
85920,93360," language right? And it has a prologue-like syntax right? So I've been requested to do something"
93360,100320," related to Erlang for quite some time specifically in the form of Elixir right? So the the younger brother of"
100320,108160," Erlang is Elixir right? Elixir. Is that the thing? Bootlin? I don't know what the f*ck is bootlin. But let's"
108160,114160," actually actually google up Elixir. So here's the website to Erlang right? So I'm going to copy paste it"
114160,120320," in the chat and for people on YouTube it's going to be in the description. So an Elixir is this thing."
120320,127440," Hopefully yeah okay so it's under HTTPS. So it's basically a younger brother of Erlang and the way they are"
127440,133920," related. They are related through the same virtual machine because Erlang is basically a managed"
133920,138880," programming language. It has its own virtual machine kind of similar to Java but the virtual machine of"
138880,146560," Erlang is different right? So and basically Elixir compiles to the same virtual machine right? And by the"
146560,154240," way it is the virtual machine I'm interested in today rather than a specific language. I want to explore the"
154240,161840," virtual machine of Erlang specifically. So here's Elixir like I don't know how different they are."
161840,168800," So for me Elixir just looks like a Ruby clone that compiles to Beam and Beam is the name of the virtual"
168800,175920," machine of Erlang right? It's called Beam and I think it's spelled like that right? So that's probably why"
175920,181440," I'm not really that interested in Elixir right? For me it's just like a different thing that compiles to"
181440,190320," Beam Beam right? So essentially Elixir is a Kotlin for Erlang right? So the original language was Java"
190320,195440," right? So and then you have Kotlin which compiles to the same virtual machine. So it's kind of a similar"
195440,200560," situation with Elixir. The original language was Erlang right? And Elixir is just like a different language"
200560,209840," that compiles to the same virtual machine. So yeah let's actually put Elixir here also in the description"
209840,217920," in the references. So specifically what's going to be my goal today? I want to generate some Beam files"
217920,227120," right? I want to generate some Beam files and I want to try to parse them. That's right. I want to try to parse and"
227120,235520," understand the format of Beam and maybe even find the sections where the bytecode is contained and try to"
235520,241440," understand what is going on in that bytecode. Furthermore if we have enough time and everything"
241440,250560," we can try to generate that bytecode right? So ideally but I'm not going to claim that I'm going to do that on"
250560,255280," today's string but ideally I would like to have a small like a stack-based programming language like"
255280,263040," a port-like thingy that compiles down to Erlang virtual machine to the bytecode of the Erlang virtual"
263040,269600," machine. That would have been kind of cool right? Nothing super fancy right? Not the entirety of the port but"
269600,279600," just an ability to do something like you know 34 35 plus print and then take this string and compile it to"
279600,284880," Beam file and then run it within the virtual machine of Erlang. That would have been kind of cool."
284880,291040," That is something that I aspire to do today but I'm not really sure if I'll be able to do that right?"
291040,295760," So maybe the the format of Erlang virtual machine is so complicated that we won't be able to do that"
295760,302560," but I have a couple of interesting things that may help us to to understand that format a little bit"
302560,309440," better right? So if I if I know if I knew for sure that I won't be able to do that within the stream"
309440,314960," I would not probably start this stream in the first place right? So that means I know a little bit about"
314960,319840," like how we're going to go about it so maybe the probability is rather high right? Otherwise I wouldn't"
319840,327520," even start streaming. Anyways so let's actually go ahead and try to write something in Erlang right? So let's"
327520,334800," try to write something in Erlang and so I'm going to put something in here so I don't know Erlang"
334800,342400," Erlang hello right? So here's going to be this thing and so essentially we're going to create a file"
342400,350960," main Erlang. If I'm not mistaken the main extension for Erlang is Erl right? So here is Erl and Emacs"
350960,356400," actually recognize it correctly it's it is in fact Erlang. So if I'm not mistaken right? If I'm not"
356400,361120," mistaken what you're supposed to do you're supposed to create like a function right? And here's the interesting"
361120,370800," thing um in in terms of entry point in terms of entry point into the Erlang program Erlang is kind of"
370800,379760," closer to Python rather it is close to Rust, C, C++ or any other compiled languages right? In the sense that"
379760,385440," you just start up the environment you just load something into the environment and you just run"
385440,390320," that thing in the environment and as far as if I understand correctly there is no really standardized"
390320,397760," entry point there's no really standardized entry point like in like just like in Python right? So and"
397760,402240," if we have any professional Erlang developers in the chat please correct me"
402240,406320," please let me know I might be wrong because I'm not an Erlang developer like at all"
406320,413120," so uh okay so we're going to create the function and uh so this is how we define the body of the function"
413120,418960," right here is the name of the function here is the basically parentheses where you put arguments of"
418960,424000," the functions right and then you put arrow and you start actually writing the body of the function"
424720,429680," in the body of the function how do you write it you write actions right so you write rather"
429680,436480," expressions that may have side effects right so you may have expression one then you write the next"
436480,442560," expression like separated by comma so this is the second expression this is the third expression and so on"
442560,451280," and so on and so forth and you end your list of expressions with dot so how Erlang evaluates your"
451280,458080," function it evaluates an expression one performing any side effects that may happen within expression one"
458080,465040," then proceeds to evaluate an expression two three and four and the result of the expression four becomes the"
465040,471200," result of the call to the function so it is an expression based language just like Erlang or a"
471200,477680," camel or Haskell or anything like that right so that's basically the syntax of Erlang essentially"
477680,483600," it's kind of goofy it's kind of silly but this is because it's based on the syntax of Prolog it's"
483600,489600," it's really close to Prolog and as far as I know when people were developing Erlang the first version"
489600,495440," of Erlang was essentially a library for Prolog then they realized that the Prolog is not really good"
495440,500560," language for this kind of stuff right so and they implemented their own language but they kind of preserved"
500560,505840," the syntax because they kind of got used to it right so that's why it kind of looks like a Prolog in Prolog"
505840,512240," by the way you write sort of clause uh like this right so you can have some arguments in a clause"
512240,518640," and then you put this kind of like this kind of iterator and within the iterator you kind of also put"
518640,522640," expressions in here like that so it's kind of similar to Prolog and you also end by the way"
522640,530000," with a dot uh right so it kind of mimics the Prolog syntax if I'm not mistaken okay so if you want to"
530000,538160," write hello world I don't quite remember how to um write hello world or how to print things in Erlang"
538160,545680," is there something like print uh all right so let me find Erlang hello world there should be something like to"
545680,549680," print uh print uh print things okay getting started getting farted"
549680,551680," um"
551680,557040," uh iof right okay so you're supposed to do iof right all right"
557040,563680," iof right uh and then so as you can see there is some sort of like a name spacing in here"
563680,573680," uh right it has uh names oh by the way iof format I kind of vaguely remember that yeah that's right iof format thank you thank you so let's do format instead uh it's gonna be hello"
573680,579600," stats uh it's gonna be hello hello world and there you go so you put a dot in here"
579600,587440," so if i understand correctly uh Emacs has uh sort of like an Erlang shell you can say Erlang"
587440,591680," shell and there we go so you can have Erlang shell within Emacs how about that"
591680,598640," how about that so it just i suppose it just runs an external Erl right i'm pretty sure that's that's"
598640,604480," what it does uh right so just runs external Erl and lets you put this kind of stuff within within"
604480,610320," the thing so the way you run the program the first thing you have to do you have to compile that specific"
610320,618000," module like this uh right and we cannot compile this thing because there is no module definition yeah so"
618000,622640," basically first first thing you need to do you need to say within the file that you're defining"
622640,628240," module with a certain name right so we're going to define a module with the same name as the program"
628240,633040," right so it's going to be main so the file itself is called main and we're going to say the module is"
633040,639360," also called main and on top of that you have to export the list of functions that you want to you know"
640160,646800," make visible outside of that specific module right so uh let's actually do export right and i'm going"
646800,652800," to say okay here's the list and i have to say hello and here comes an interesting thing so the way you"
652800,658560," describe signatures in Erlang is kind of similar to how you do that in prolog right if you never programmed"
658560,663600," in prolog it probably doesn't tell you anything but it's a dynamic language so that means it's like"
663600,673280," you do not assign types of arguments right but uh you can overload functions by the amount of arguments"
673280,679360," so and essentially to specify to say that okay i'm referring to function that has zero arguments you put"
679360,685280," slash zero and that means you're referring to the function hello that doesn't have any arguments you can"
685280,691520," have another version of hello that accepts one on argument and if you were referring to that function"
691520,696880," specifically you would say something like hello slash one so these are two different functions"
696880,706240," right so the format of referring to the signature of the function is name slash arity name slash arity"
706240,712640," and if you don't know whether the arity arity is a mathematical term which means the amount of arguments"
712640,721280," in the function right function f of x is the function with arity with arity zero function f of"
721280,729200," x of y is a function with arity i'm sorry one and f of x of y is a function with the arity term"
729200,735760," right so you describe a name slash arity so that's what you do essentially and that's why i put"
735760,743200," slash zero in there because i indicated the arity uh number of arguments in math yes so as far"
743200,750640," as i know arity is a mathematical term that uh basically leaked into programming right so quite often uh"
750640,755840," the developers of the languages of programming languages use the word arity to describe the"
755840,761600," amount of arguments of a particular function because that's how they do in um you know in map"
761600,770480," so uh all right all right all right so and essentially we defined the function and let's"
770480,777440," try to compile this thing one more time and as you can see it in fact compiled right so then we can actually"
777440,785120," call the function function hello like this right and as you can see it says hello world so we basically"
785120,794800," compiled uh the erlang file right and by compiling it uh we um created a module beam module and loaded it"
794800,801280," into the ripple and now we're able to to run this entire thing so as far as i know you can modify this"
801280,807440," into i think like full bar and you can just go ahead and recompile it uh right and then you can run main"
807440,813760," hello right and it's automatically recompiled as well so and one of the sort of like a killer feature of"
813760,818400," this language is that you can reload modules on the flyer without restarting the whole system"
818400,824160," right these days you can't really surprise anybody with this kind of feature because we had dynamic"
824160,831840," languages before but erlang is a very old language it is very old language how old is it actually erlang"
831840,836800," uh let's take a look at wikipedia so at the day at the time when it was developed it was like a"
836800,844880," revolutionary idea of having a language that you can hot reload apparently so it's 37 years it's older than"
844880,851920," python by the way it is older than python as far as i know first maybe python i don't quite remember but i think"
851920,859520," python is around like 90 or something like it's it's even older than me so yeah it is even older than me"
859520,864960," it's not as old as c but it's still relatively old language it is still relatively old language"
864960,874640," so yes so yes so yes but here is an interesting thing after we did that c uh name of the module look what happened"
879840,887440," it created main dot beam and as already mentioned beam is the name of the virtual machine of erlang"
887440,896960," so we already can try to analyze the byte code of beam because it's literally in front of us near the"
896960,901760," source code of the main program of the hello world program that we just compiled and look at the size of"
901760,911280," this thing 660 it's not even one kilobyte it's less than kilobyte so it's not not that much stuff in there"
911280,920720," to analyze so and that thing is already capable of producing hello world which is pretty cool i think"
920720,930480," right so um so the task of maybe creating a small compiler into the beam file is not impossible right if this"
930480,937120," is how much data you need to generate to do hello world right it's not that much uh we can go ahead"
937120,943040," and just try to open it this entire thing and that already looks like something like some sort of a format"
943040,950960," uh we can already see the magic number right so the the magic four bytes uh so the the encoding is probably"
950960,959200," horrible but i wonder if i can make it better uh maybe not i'm not sure if it made it better but i tried right so the first four bytes is four one"
959200,968080," one and this is probably the magic number for the um the bytecode file of beam right so another interesting"
968080,975520," thing we may notice is that after these four bytes for one we have some non-asci for other bytes"
975520,988000," non-asci for other bytes so and we can take a look at them so here they are the leading bytes are zero the leading bytes are zero and only the"
988000,995040," the uh lower bytes in here they have something in there so which probably means it's some sort of a"
995040,1002960," size it is a very common sort of pattern for indicating some sort of a size within the binary file format it"
1002960,1016480," would be nice to know what this specific size is equal to what is this specific size is equal to so we can try to do that so uh we could do python but in python it's not interesting right so"
1016480,1023200," okay so what if we can do that in erlang we already have an erlang ripple we can already have an erlang ripple"
1023200,1032240," maybe we can you know do all the calculations there so erlang uh hex literals how do you do hex literals in"
1032240,1038560," erlang so this is a very interesting question or a version of by the way that could be a version number"
1038560,1045360," this is also quite uh quite a common thing right it's also quite common thing um so data types"
1045360,1054400," uh hex uh i don't really see so there's only hex maybe there's some examples in here"
1055520,1067600," um so yeah okay so this 65 no this is probably character or something oh okay so oh this is"
1067600,1074640," actually kind of cool so you can put a base like this then hash and then the value so i can do something"
1074640,1080880," like this uh right so ff uh and yeah there we go so that's actually pretty cool can i have"
1080880,1089600," something like this yeah i can even have like a very exotic basis like 15. that's actually pretty cool"
1089600,1096640," right so this is how you do this little and this is actually kind of cool look in the majority of the"
1096640,1106800," languages uh you can't start the uh number literals um you can't start the variable identifiers with a"
1106800,1112960," digit because uh something that starts with digits is usually some sort of a number and they kind of"
1112960,1119760," follow this convention right so the base comes first and it is a number so you can't really confuse that"
1119760,1125120," with the identifier or anything like that so and it's actually super explicit i really like that i really"
1125120,1131840," like this syntax i like it more than 0x uh right or maybe even 0b or and stuff like that it's a little"
1131840,1138240," bit more explicit but anyway so uh let's actually take this entire thing uh let's actually take this"
1138240,1142240," entire thing and i'm going to copy paste it in here and i'm going to say okay let's interpret it as this"
1142240,1154240," stuff so uh what is this what is this uh can i uh that is bizarre why doesn't it why doesn't it"
1154240,1161920," work if i do something like c oh yeah okay i'm an idiot i'm supposed to put a dot at the end of the"
1161920,1179120," expression that's why it couldn't okay 652 652 the size of the file is 660. if we subtract this thing we get 8"
1181280,1189600," we get 8 which is literally the size of the whole file except the magic and these four"
1189600,1195840," bytes that denote the size of the file so it's basically the amount of bytes until the end of the file"
1195840,1204400," we already figured out first four bytes of the format without having any specifications"
1205360,1207040," we already figured it out so"
1207040,1214720," so you see we don't have any specification i don't even know where specification is right so but we"
1214720,1223520," already figured it out so uh not bad so the next four bytes is another magic right so uh which probably"
1223520,1232000," means that this entire file consists of different chunks right and that sort of magic indicates the type of"
1232000,1239360," some sort of chunks right and maybe those chunks are like uh the chunk of data or the chunk of code and"
1239360,1244640," stuff like that and we can see uh ascii data within the file format we can clearly see all of that so"
1244640,1251200," there's definitely some ascii data there's definitely some binary data and it's all very very much clear"
1251200,1256480," so uh the only thing we need to do we need to just understand what the hell is going on with this file"
1256480,1264000," right so i don't think we can go uh much further without proper specification right so we need to"
1264000,1270080," download the proper specification of this file format somewhere right um so that's what we need to do to"
1270080,1277520," proceed how do you know if it's not some constant and by chance it relates to the size of the file uh the"
1277520,1287680," the probability of that is extremely low okay good so um here's the thing um there is a very interesting"
1287680,1296720," uh piece of documentation online uh and it's called the bim book uh right it's called the bim book"
1296720,1305520," so let's try to find out uh and it's basically a description of the erlang runtime system erts and the virtual"
1305520,1312000," machine bim and it's kept relatively up to date so the last modification seven seven months ago right"
1312000,1319120," and uh there is an online version right so it's a it's literally a book actually it's an online book"
1319120,1328080," um so you can find it in here i hope i can open this into i think uh okay so there you go i'm sure if"
1328080,1335360," there is like a dark uh version of this entire thing but you can find uh this thing in here and for"
1335360,1344080," people who's watching on youtube potentially i'm gonna put it in here so the bim book so this is the bim book"
1344080,1350800," and there is a very interesting chapter within the bim book bim book"
1350800,1360000," modules and the bim file format"
1362400,1366880," sounds like exactly something we might be interested in doesn't it"
1366880,1376320," let's find out so and this is actually a relatively big book uh right and it goes into the internals of"
1376320,1383200," how erlang works and stuff like that so it's pretty hardcore uh i'll tell you that so but the the section"
1383200,1389520," that we're interested in is modules and the bim file format so and there you go the bim file format"
1390320,1395520," so the definition source of information about the bim file format is obviously the source code of bim lib"
1395520,1404720," dot erl uh okay so we can probably maybe get some stuff from here uh i wonder if this thing is even"
1404720,1411600," available for the um from the ripple maybe we can just load bim li okay it's a part of the standard"
1411600,1418160," library of otp or whatever the it is uh that means that we should be able to maybe call to some of these"
1418160,1422800," things but there's a lot of stuff in here right there's a lot of stuff in here uh the bim file"
1422800,1429120," format is based on the interchangeable file format uh with two small changes we'll get to those shortly"
1429120,1439120," okay whatever so bim uses the type bim a bim file header has the following layout doesn't it look familiar"
1441680,1448960," so we have some sort of interchangeable format header if header so it's a four one then size"
1448960,1457440," size and then bim again so it's also big engine right um so yeah and it uses like a very interesting"
1457440,1464880," format so it's something from um from erlang itself right so these kind of things"
1466080,1474160," in erlang they indicate some sort of like a byte arrays if i'm not mistaken so erlang is actually"
1474160,1481920," capable quite capable of parsing binary formats it has syntax and facilities to"
1481920,1488960," parse binary formats so we can actually google that erlang um byte arrays i think that's how they call it"
1488960,1496800," does anybody know uh right does anybody remember so there's byte arrays uh or something like that so"
1496800,1505840," there are arrays maybe beat arrays uh so here are arrays but the thing with the um bit strings yeah i"
1505840,1511520," think it's bit strings thank you so much uh x not uh famous thank you thank you thank you so let's actually"
1511520,1518400," google up beat strings so because i think that feature that is used in the book is a uh bit strict"
1518400,1526480," strings i think that's what yeah there we go so it uses this uh you know triangle brackets it uses this"
1526480,1531040," triangle brackets so we can read about a little bit more about that i never really used that feature"
1531040,1537440," but since the the book is using it so we probably need to be able to know uh this kind of thing so uh the"
1537440,1543040," the complete specification of the bit syntax is a reference manual in erlang a bin so they call it a"
1543040,1551680," bin is used for constructing binaries and matching binary patterns imagine language having facilities to"
1551680,1560080," match binary patterns so a bin is written in the following syntax so the triangular brackets expression one"
1560080,1567680," expression two uh separated by commas uh and yeah so you have n expressions in here a bin is a low level"
1567680,1574720," sequence of bits or bytes the purpose of being is to enable construction of binaries uh right so you can"
1574720,1580800," construct a new binary like that um all elements must be bound or much binary so you can then if you have"
1580800,1588640," some sort of a binary you can match it and sort of parse it so that's pretty cool isn't it so here bin is"
1588640,1596320," bound and elements are bound and bound yeah examples so uh a binary can be constructed from set of constants"
1596320,1607440," or string literals so let's actually see how we can do that um so uh we can do something like 69 uh 420 is"
1607440,1613360," probably not going to work because it's more than a byte but it kind of worked out right it kind of worked"
1613360,1623440," out anyway so if i do just for 420 so yeah so this is ascii but then what is exactly 420 so that's really"
1623440,1630960," interesting so this thing should have actually turned into several bytes then right into like two bytes"
1630960,1638400," one of the things we can do we can actually try to print f this entire thing and take a look at xxd"
1639200,1646720," and in fact it's actually three bytes all right it's actually three bytes so if i put something"
1646720,1656080," in here that is bigger than 255 it's going to be basically two bytes right so here i defined three"
1656080,1664160," bytes not two very interesting very interesting actually so in here i can also use like strings and"
1664160,1671920," what not right so uh if i do something like abc uh there we go uh what's funny is that what if i put"
1671920,1680320," like utf8 in here right cyrillic for instance that's kind of funny like why did it turn out to be like"
1680320,1689520," that uh maybe it doesn't really fully understand this really but yeah okay uh right so and you can convert"
1689520,1697120," like binary to list and list to binary and stuff like stuff like that um so similarly a binary can"
1697120,1703920," be constructed from a set of bound variables right so you have a b and c and then you provide like a"
1703920,1712080," colon in here let's give a binary size four uh right so i suppose you specify like amount of bits that should"
1712080,1718160," be taken by that specific variable if i'm not mistaken and if we take a look at this thing okay so this one is"
1718160,1724640," interesting so this starts to make sense now this starts to make sense right so this is probably the"
1724640,1732640," name of the variable this is the size uh the amount of uh i don't know why it is it four right if we"
1732640,1741600," specify the amount of bits it has to be 32 right it's four slash unit eight uh i don't know why it is like"
1741600,1748640," that but yeah there we go so that defines somehow four bytes and what is big our big is probably andianus"
1748640,1754240," yeah yeah so they say that's a big andianus you can also specify the andianus if you want to match it"
1754240,1762560," that is actually a very powerful language for parsing binary formats right so you can say okay so here is"
1762560,1769040," every 32 bits uh bind it to this specific variable bind it to these specific variables and interpret it as a"
1769040,1779120," big andian like that um a butterfly so this is actually quite surprising right uh this is actually quite"
1779120,1788720," surprising so and this language was developed for um telecom applications right uh by atnt ericsson it was"
1788720,1795520," developed by ericsson for uh telecom applications um right and i suppose a lot of formats that are used"
1795520,1801680," and they are they are binary formats so that's probably why uh it has all of these powerful facilities to"
1801680,1807520," to match all of these things um okay i do understand these things so this is basically"
1807520,1817360," uh the the size of this variable in bits and then this is the andianus right but uh if we put unit in the"
1817360,1823280," place of andianus what is that supposed to mean and why can you actually say eight in here like what is"
1823280,1828240," this additional thing this like i do not fully understand that right i do not fully understand"
1828240,1836480," that it's kind of kind of weird uh so let me let me see so maybe there is additional things okay so these"
1836480,1846400," are like the sizes it's actually a lot look at that so holy look at that you basically receive some sort of a"
1846400,1852160," data data data gram right from udp or something like that and then you can do case power magic and"
1852160,1858160," you can probably match it against this huge pattern and you can extract the ip version hln or something"
1858160,1865040," like that and because it's within the case if it doesn't match you can try to match it against something"
1865040,1879680," anything else um yo what the and this is the language from 80s oh well uh this is a good idea actually"
1879680,1887120," uh yeah eight by uh four by eight is 32 so that's basically what's going on here right so"
1888080,1899040," you have eight uh nibbles right so that is that is a really bizarre way of describing that but i mean"
1899040,1905840," maybe maybe that's exactly what you want to do in here so it expresses some sort of an intent that i do"
1905840,1913040," not fully understand but that's fine okay uh so lexical note uh segments okay"
1913040,1921920," so we have value size type specified list whatever that is type specified list um"
1921920,1930960," okay so this is very interesting they even freaking they even have this example in here uh right so"
1931840,1941360," you have x for little signed integer or unit it's it's like one of those or maybe it's like a list of"
1941360,1948240," the things that you can have in here it's a little engine signed integer and unit and unit is the"
1948240,1955600," the unit size is given as unit integer literally they allow the range is from 100 it is multiplied by the"
1955600,1963600," size specified to give the effective size of the segment so essentially you can provide the second"
1963600,1975280," size only if the type list contains unit right so it is the unit and you have eight units in here uh all right"
1975280,1983360," so that's the element has total size bits and it contains assigned integer little endian order"
1985600,1993520," okay so that is needed to express some sort of an intent in here um right it's needed maybe the"
1993520,2000800," actual unit here is eight right the actual unit here is eight bytes and you have four units with the size"
2000800,2006960," eight okay i finally understand what this means i finally understand what they were trying to say"
2006960,2017120," you have four units of the size eight right and unit is basically the character now i fully understand this"
2017120,2024080," pattern now i fully understand this pattern this is actually quite cool i'm yeah that's super cool actually"
2024080,2033680," so what the uh after the header multiple chunks can be found after the header multiple chunks can be found"
2033680,2039760," there we go that's exactly what i was talking about right so it feels like maybe it consists of"
2039760,2046000," several chunks and stuff like that right several chunks and stuff like that and the chunks have different types"
2047440,2052720," code atom string t lead t and so on and so forth"
2052720,2061040," there we go so and it's usually four characters as you can see so we can even take a look at what"
2061040,2067680," we have in there right we can take a look at what we have in there uh yeah so we have for one the size"
2067680,2075520," of the file and bim and then we have at u8 i have no idea what is at u8 and it don't they don't really mention"
2075520,2081520," at u8 in here right so it's somewhere in a dot dot dot right it's somewhere in the dot dot dot"
2081520,2089440," uh this file format prepends all areas with the size uh of the following area making it easy to parse"
2089440,2094640," the file directly while reading it from disk yeah so this is actually quite cool so it makes it super"
2094640,2100880," easy you know precisely the size of the header so you can read only the header right you can read only the"
2100880,2106720," header and then you can read the rest of the things you can read the rest of the thing or you can read"
2106720,2113520," the fixed size of the chunk the fixed size of the chunk and then you know how much more you have to"
2113520,2118080," read after that and what kind of chunks you have in here and that makes it actually super easy to skip"
2118080,2125520," the chunk right so you read the chunk header you uh see the by the type of the chunk that this is not"
2125520,2130400," something you're interested in this is not something you're interested in so you know exactly how much"
2130400,2134880," you have to skip because it's in the size of the chunk so you know exactly how much you have to skip"
2134880,2142800," so it's just like whatever um so you can basically like sort of stream read the format uh or maybe like"
2142800,2149440," if the file is so small right so it's it's not that big of a file you can read it um the hole into the"
2149440,2156560," memory and then skip it but maybe at the time when this thing was developed right so in 80s the amount"
2156560,2161120," of memory was actually limited right so the amount of memory was actually limited and because of that"
2161120,2167280," they need they would not read the whole file into the memory right so maybe they would just like read"
2167280,2170960," it like by chunks and skip some of the chunks to not to waste too much memory"
2170960,2178400," not enough memory to read the whole file crazy i mean what was the memory sizes in 80s"
2179440,2190080," so it's the language from uh 1986 what were the uh ram sizes back then uh i don't know like i was not"
2190080,2197600," born back then so i was born in 90s not in 80s and uh to be fair in 90s i didn't even know what is a"
2197600,2208400," computer i only got computer in zeros for megabytes uh 640 kilobytes was in the future i think it's too much for"
2208400,2215840," for 80s right but i don't know anyway um"
2215840,2223440," 640 kilobytes is enough for everyone exactly um so the file format prepends all the area with the"
2223440,2227520," size the following making it easy to parse the file directly while reading from disk yeah to illustrate"
2227520,2233840," the structure and the content of the beam files will write a small program that uh that extracts all the"
2233840,2240000," chunks from the beam file so you can erlang is capable of parsing itself um"
2240000,2251360," all right for memory uh for memory may figures 82 to 84 one kilobyte so it's around um well i mean"
2251360,2261840," that's actually pretty good i think you can fit relatively big programs in memory um right but i'm not 100% sure so"
2261840,2269440," obviously this um 600 bytes it's basically hello world the programs that are written in erlang they"
2269440,2274240," especially the ones that are used in telecom applications they're probably very complicated"
2274240,2277840," right they could be quite big right so"
2277840,2282880," uh i don't know it's kind of difficult to speculate on that"
2284320,2292640," so anyway uh okay apparently reading the file from uh like in erlang is as easy as this so you can just"
2292640,2301760," read it okay so and as you can see uh like this is tuple in curly braces in curly braces you denote a"
2301760,2309440," tuple kind of similar to how you denote the beat string with uh triangle brackets right so you denote tuples"
2309440,2316880," with curly braces right and tuple is a classical tuple like in functional languages right so uh let's actually"
2316880,2324320," try to do something like this one two three so there you go this is in fact a tuple uh right and reading"
2324320,2332960," from a file returns you a tuple of okay and file here is an interesting thing you may notice that they use"
2332960,2341520," uh symbols uh symbols uh with capital letter and a small letter interchangeably right this is because"
2341520,2348320," uh whatever starts with a capital letter is an actual variable it is an actual variable whatever"
2348320,2357360," starts with a small letter is not a variable it's a symbol it's an actual value it is an actual value and"
2357360,2364080," a symbol is similar to how you have symbols in lisp right so essentially if i try to do something like"
2364080,2371600," this it will tell you okay or your mom your mom is a valid expression in erlang it is a valid expression"
2371600,2378160," in erlang but if you capitalize your mom right so it will say that there is no such variable variable your mom"
2378160,2387040," is unbound you have you have to bind your mom first right you have to say something like 69 and only then"
2387040,2394560," right after your mom has been bound you can say to you can refer to this specific variable right so and"
2394560,2401040," so you can do symbolic computations uh with this language right so similar to to this"
2401600,2407840," and essentially if you manage to read the file successfully it will return you a symbol okay"
2407840,2412960," if you couldn't read the file it will probably return you a different symbol"
2412960,2417600," right so in this specific case you probably can treat them as enumerations or something like that we"
2417600,2424320," can try to read the file and see what's going to happen uh right so let's actually try to read that"
2424320,2428320," beam file that we've got i think it's kind of kind of interesting so we're going to do main"
2428960,2437440," uh beam right and what do we get we got symbol okay and the beat string the beat string that we"
2437440,2443520," were talking about there you go so and you can start pattern matching it right and in here as you can see"
2443520,2448400," we're first reading this entire thing and then pattern matching it with this beat string pattern but"
2448400,2454080," we could actually insert it in here and pattern match it simultaneously uh right you can do that i'm"
2454080,2457360," really curious what's going to happen if you try to provide something that doesn't exist"
2458720,2466720," right it returns error right but it still returns the tuple of two elements it still returns tuple"
2466720,2472800," of two elements which means that you can actually do a very interesting way of handling uh this kind"
2472800,2478720," of stuff right so let's actually read uh right you can do something like this and then you can do case"
2479920,2490080," of okay content and just start handling it right so to do uh and i think you have to yeah so then in"
2490080,2498080," case of an error in case of an error right you can maybe print that error so you see this is the reason"
2498080,2506480," why um it returns you uh you know stuff like that so it makes it easy to pattern match by a successful"
2506480,2513760," operation and then by the operation that failed all right at least this is how i understand that i don't"
2513760,2519360," remember how to close the case by the way i don't remember how to close the case who remembers how to"
2519360,2529360," close the case or long uh switch case right this you have to put something like end uh problem it doesn't"
2529360,2536800," automatically do this thing so case statements so let's actually google that uh so the case off right"
2536800,2542240," but so that means you have to not put this thing as the yeah there we go so this is how you close this"
2542880,2548960," this specific thing uh but what's interesting is that if you do the way they do that in here right"
2548960,2555600," if you do the way they do that in here if you won't be able to read the file this particular pattern just"
2555600,2563920," won't match so it's going to be a runtime error right so the case didn't match uh somebody says ESAC"
2566480,2572080," i don't think it's the case uh it's it's it's in bash right it's a bash thing not erlang thing but yeah"
2572080,2582000," so uh yeah there we go so so far so good uh so good uh so far all of that kind of makes sense"
2582000,2588080," doesn't it so far all of that kind of makes sense and as you can see here we're just powder matching this"
2588080,2596640," syntax stuff and then we can return the size uh right the size and the chunks right you can even"
2596640,2602720," actually say okay this is binary so it's going to be the rest of this stuff right it's going to be the"
2602720,2609680," rest of the stuff it's pretty cool so we can even specify like a file name as the parameter in here so"
2609680,2616160," right and we can even export uh this thing like that so as you can see i'm indicating that read"
2617040,2624000," has one argument right so that's why i put one in here so we can try to now go ahead and recompile"
2624000,2634160," this specific module right so c and c main.earl right and it works fine right so this is hello"
2634160,2640800," and uh the module is actually able to read itself right so if i do something like that as you can see"
2640800,2646720," there is no such function there is no function read slash zero because we didn't provide any argument"
2646720,2653040," right so but there is uh read where that accepts the file path right so we can provide main.beam"
2653040,2661600," there we go and we've got uh this specific thing so the size is bigger right so the size is already"
2661600,2666880," bigger because now the module contains right the module contains this specific function"
2666880,2673360," all right so the module contains this specific function so it's now bigger uh that's kind of funny actually"
2675120,2681520," so cool uh what if i provide something that doesn't exist right so that means this pattern matching is"
2681520,2688960," not gonna you know pass uh exception no matching of the right hand side error e no in that you know"
2688960,2698320," e no entry right so you know entering and to be fair this is a completely unreadable error honestly if i saw an"
2698320,2704720," error like that i would be what the fuck is that what the fuck is that though it does provide the"
2704720,2712880," location where it happened and if this is a common way of uh handling errors right in erlang you can kind"
2712880,2718720," of guess what's going on in here right if you have see error and in no end you may kind of quickly"
2718720,2724480," get out somebody's trying to read the file at that specific place let's actually go there and inspect and"
2724480,2729760," there you go so we couldn't read the file but honestly it would be better if it would just print"
2729760,2735920," something more readable um but to be fair to be fair as far as i can understand this language was not"
2735920,2743280," created for writing like um end user applications right so you wouldn't write a user application that"
2743280,2751040," you would install on a desktop machine or something like that it was written for servers right so and for"
2751040,2758880," servers right so maybe um you know user friendly error messages are not important so what's important is"
2758880,2763680," the developer friendly messages right if you know what i mean though to be fair that message is not"
2763680,2776720," developer friendly either uh so yesu yesu yesu so and then we also have uh different chunks in here"
2776720,2783920," right so then we provide the size and we provide the chunks and stuff like that to be fair um i ran out"
2783920,2790480," of tea already i kind of ran out of tea and uh it's getting a little bit cold in here there's a reason"
2790480,2797440," why i'm wearing a tracksuit right now not only because i'm russian but also it's because it's a little"
2797440,2805760," bit cold inside so i need to uh refill my tea i need a hot tea right i need hot tea to survive and"
2805760,2809840," so let's make a small break and after the break we're going to continue parsing this entire stuff"
2809840,2816480," and exploring this format so far so good i'm really glad that i'm learning something interesting something"
2816480,2824560," new and like apparently i discovered a pretty cool language for parsing binary formats that i may use in the"
2824560,2830960," future for something else this is not a bad idea so having something like that in your toolbox is"
2830960,2835680," actually super useful i mean it's just like parsing binary sheet in earlink is kind of pleasant honestly"
2835680,2842640," it's like yeah i can see myself using that outside of today's stream just to quickly parse some binary"
2842640,2850160," format like it's like it's easier than in c right so earlink is more suitable for parsing binary formats"
2850160,2857280," that then see honestly um it's quite surprising it's actually quite surprising to expect that"
2857280,2865040," so anyway let's make a small break and um all right so let's go ahead and try to maybe separate"
2865040,2871040," the hello world program and the program that we're going to use for parsing that hello world program right"
2871040,2876960," because i don't really like the fact that uh you know the program is changing as i'm developing the"
2876960,2883040," parser for it right so i think i want the test data to be stable right so let's actually separate all of"
2883040,2888400," that stuff in here so i'm going to create hello.earl and the module is going to be basically hello"
2888400,2897040," right and we're going to simply uh just export the hello function right so we're going to export the hello"
2897040,2905440," function and this is going to be the rate and there you go here is hello hello and uh what i'm thinking"
2905440,2913360," is that uh i want to rename main to something like beam uh right so you have a beam which is responsible"
2913360,2919440," for parsing and stuff like that and you have hello uh which is responsible for just printing hello world"
2920240,2928880," right so that is basically it uh and in the beam we only import that export that and we in here hello"
2928880,2936000," we only export that okay so let's go into the earl uh erlang thingy and i'm going to compile by the way"
2936000,2943120," i wonder if i can do ctrl c ctrl l usually there is a convention in emacs uh extensions that if you press"
2943120,2950560," ctrl c ctrl l it automatically loads the the thing but that didn't really work properly so i don't know"
2950560,2957120," how that's supposed to work uh ctrl c ctrl l in this specific case just opens the uh the ripple but it"
2957120,2964480," doesn't really reload the module i wonder if there is something like erlang compile okay there is a"
2964480,2972000," function called erlang compile let's actually see what it does erlang compile right so what's what's the"
2972000,2979920," function does ctrl c ctrl k all right compile module in the current okay so that makes it actually super"
2979920,2986560," easy to do and just like erlang compile function this is actually cool okay so ctrl c ctrl k all right"
2986560,2994480," look at that it just it literally called c a compile function for me right and called it in a very verbose"
2994480,3002640," way uh with a full path uh with setting output to the same path that is a very verbose way of doing"
3002640,3010560," that but i mean if it worked out why not i mean not bad it's actually pretty pretty cool so that means"
3010560,3019840," now i can do hello uh hello like this and it works and then i can change uh something like hello sailor"
3020480,3028080," ctrl c ctrl c ctrl that and then boom it works then back recompile and it can be super effective i can be"
3028080,3034320," super effective with my erlang application is it not poggers my dudes i think it is in fact poggers anyway"
3034320,3043520," so uh i'm sorry i can also recompile this entire thing uh main oh yeah let's actually call this thing"
3043520,3052320," bim uh beam uh read and we're going to be reading actually hello uh hello bim and we managed to read"
3052320,3058720," this entire thing and this thing is actually quite it's it's really bigger than uh than original hello"
3058720,3065440," world surprisingly let me actually remove this thing um why is this thing bigger though because i don't think"
3065440,3072960," yeah it's kind of weird but that's fine anyway so the next thing they do in here right the next thing they do"
3073520,3079920," uh they actually uh read the chunks they have a function that reads the chunks"
3079920,3094400," and they pass the chunks in here and what they do is that they match each individual variable in here"
3094400,3105120," separately name character by character n a m e which makes me question why why they do that that doesn't"
3105120,3112240," make any freaking sense to me but okay uh so one of the things i can try to do i can do read the chunks"
3113440,3122000," uh chunks uh chunks and just literally match this entire stuff like that name right uh all right and"
3122000,3129280," what i'm gonna do i'm gonna literally return whatever we manage to match in here all right so i'm gonna do"
3129280,3137280," read the chunks right read the chunks and yeah maybe i should call it read file but i mean i already"
3137920,3147600," i already have a different name for this entire thing uh okay so in function uh no function close"
3147600,3155760," matching read chunks that is very interesting is that because i define this function after is that the"
3155760,3166320," reason what if i define it like this and then try to do that no that is bizarre honestly"
3167360,3178000," um doesn't make any sense to me so let me double check that i'm calling this function correctly"
3178000,3182400," yeah i am calling this function uh pattern match"
3182400,3193440," so oh pattern match the rest yeah thank you thank you so much so uh let's actually do it like that yeah"
3193440,3201440," so you're right tail binary because they have this yeah so by just saying name i said it has to be"
3201440,3207360," exactly four bytes but this is not true i need to have some sort of a tail in here you're right you're"
3207360,3214880," right that that makes sense uh so here let's actually try to extract that and tail is unused and i wonder"
3214880,3222000," can i say underscore like so yeah that's an interesting way to do that right so ignore the rest of the binary things"
3222000,3229120," okay so let's try to run that okay so let's try to run that and we've got this kind of stuff"
3229120,3236800," right we've got this kind of stuff uh i wonder if uh i can convert this kind of stuff to"
3236800,3242160," maybe a string that would have been interesting actually but don't quite remember how to do that"
3243280,3251680," i don't quite remember so i suppose um there was a function that allowed me to do that um"
3251680,3257760," i remember to string"
3262720,3272880," binary to list can i have binary to string uh something like binary to string"
3272880,3284160," and in here i do 69 69 69 and there is no such thing unfortunately there's no such thing erling binary"
3284160,3288880," to string there should be something like that because there is a binary to string"
3288880,3298160," which in our up to list which in our case oh wait wait wait wait string is a list"
3298160,3303520," strings are lee okay"
3303520,3307680," all right"
3310640,3322880," um oh it even highlights it like that look at that uh so read that at u8 8 u8"
3322880,3333040," interestingly interestingly what we probably want to do we want to try to accumulate um"
3333040,3340480," accumulate different names of the chunks right and what's funny is that they're in the book"
3340640,3351040," they're using they're using recursion to do that right so after the chunk uh after the chunk name"
3351040,3354720," we have the size of the chunk and we know how much we have to skip"
3355360,3366240," right we know how much we have to skip um and align by four align each chunk on even four bytes"
3366240,3370240," uh i'm not sure how useful that is but i mean yeah"
3370240,3377680," anyway so and the idea is i uh like here i have an accumulator right so here i have an accumulator"
3378560,3389280," and then i said accumulated to empty list so this is sort of like a recursion uh that is tail tail call"
3389280,3394960," recursion right with it with an accumulator and stuff like that and here is an interesting thing uh read"
3394960,3405040," chunks has two clauses two patterns it's kind of similar to to haskell in that sense it is kind of similar to"
3405040,3412240," haskell in that sense uh right so essentially we consider two situations when we have this specific"
3412240,3420320," pattern in binary and when we have nothing in binary right and as soon as we have nothing in binary we"
3420320,3425040," probably want to return an accumulator one of the things they do in here they actually reverse in"
3425040,3430640," the accumulator because if you do recursion with accumulator like that you get stuff in a reversed order"
3431360,3437760," so because of that they like to do lists reverse in this case so we have to probably do something like"
3437760,3445840," that right there we go uh oh and by the way when you have several sort of patterns per function you"
3445840,3453360," separate them with semicolon right so you indicate that this is basically a sing definition of a single"
3453360,3459520," function it's a definition of a single function even though there's several patterns in here right so first"
3459520,3465680," pattern it's when you have something in here right so you have something in here and uh this pattern is"
3465680,3471040," when you actually exhausted all of your input and what we want to do in here in my opinion we want to"
3471040,3478160," collect all of the names of the chunks we want to collect all of the names of the chunks and essentially"
3478160,3489040," i want to continue the recursive call read chunks with the tail but i need to skip the size amount of bytes"
3489040,3496320," is this polymorphism polymorphism is kind of like a overused word that doesn't really mean anything"
3496320,3503680," anymore when you say polymorphism what exactly do you mean right so what exactly do you mean depending on the"
3503680,3510560," context people use this word to describe absolutely different things actually right absolutely these"
3510560,3516080," different things somebody says this is a pattern matching yeah it is true this is a pattern matching"
3516080,3520160," but whether it is a polymorphism i don't know what do you mean by polymorphism"
3522320,3532320," so how can we skip a certain thing so how can we skip a certain thing so we use align by four bytes uh and"
3532320,3539440," i don't really freaking understand why you need this kind of function honestly uh i don't really understand"
3539440,3548320," why you need this kind of function so you have a size uh and align each chunk on even four bytes do"
3548320,3554880," they even say anything about that i think we need to read about this kind of thing so uh after the header"
3554880,3560960," multiple after the header multiple chunks can be found the size of each chunk is aligned to the multiple"
3560960,3572160," of four and each chunk has its own header below um aligned to the multiple of four okay ah so okay"
3577120,3585680," so it gives you the size in bytes right it gives you the size in bytes but then at the end of the data"
3585680,3592160," right so let me actually do that right so you have the size then you have data which is the chunk size"
3592160,3601280," and then you have additional padding additional padding from zero to three to align it to uh to four bytes"
3602320,3608960," so but the chunk size contains the the actual size and bytes but then you always see i have to keep in"
3608960,3614800," mind the the padding in here i guess it makes sense right it's kind of an interesting way to to do that"
3614800,3621920," but yeah so you take the size um yeah and this is very interesting formula by the way this is a very"
3621920,3629280," interesting formula how they align this kind of stuff to to four right so let's actually see uh so let's take"
3629280,3634720," uh take a look at this formula that they use i may might actually copy paste the entire formula uh in"
3634720,3643120," here uh right like so so how do you do oh this is how you do comments in here imagine you have uh you know"
3643120,3654480," bytes so here are bytes so what does it mean aligned by four right so let's split all of the bytes in into"
3654480,3660400," groups of four right let's split all of them into groups of four and as you can see uh it's divisible"
3660400,3665920," the amount of bytes is divisible by four so everything is aligned by four so if you have"
3665920,3673280," like this amount of bytes this thing is not aligned by four the amount of bytes is not divisible by four"
3673280,3680640," to align align it by four you need to pad it with additional zeros so the total amount actually divisible by"
3680640,3688160," four this is how you align it so but here is an interesting thing you are given the amount of ace"
3688160,3694080," but you are not given the size of the padding you know the amount of ace"
3694080,3700080," but you don't know the full amount in here including the padding how can you figure it out"
3701120,3710720," how can you figure it out so here is an interesting thing if you divide this amount of ace this amount"
3710720,3720960," of ace by four uh using integer division using integer division you get one two three four the result is"
3720960,3728720," going to be four and this sort of small tail is going to be lost this small tail is going to be lost right"
3728720,3737200," so if you have n and um you divide it by four you will only get four chunks excluding the tail"
3737200,3745040," to get the size of the tail you have to use the mod operation or maybe percent how do you do the mod in"
3745040,3756160," erlang erlang erlang mod operation mod operation uh modular so how do you do modular or remainder in erlang"
3756160,3764640," it's called remainder okay so you have to do rem but in uh many programming languages like c javascript"
3764640,3770560," python doesn't matter it's usually percent you've probably seen a percent operator it's basically the"
3770560,3781120," operator that gives you this tail so-called remainder right it's it gives you this sort of thing so if you"
3781120,3787120," just do integer division you get all of these things without remainder the amount of these groups without"
3787120,3794240," the remainder and then by doing rem by doing rem you get the size of this thing so that's basically the"
3794240,3802320," difference between different ram okay but you want to figure out the size of the whole thing right but"
3802320,3809440," you know only the size of this thing what do you want to do so notice how the first thing they do in"
3809440,3816720," here they add plus three they add plus three so let's actually consider several uh situations the first"
3816720,3825680," situation is everything is aligned everything is aligned everything is aligned by um by four if you add"
3825680,3836080," three you basically turn this entire thing into that after that you divide it by four so you basically get"
3836080,3842960," rid of this thing and you get precisely four of them right you didn't have anything in here and uh you did the"
3842960,3849920," separation and it went back to normal uh the next situation it's when you have one this thing in here"
3849920,3858160," one this thing in here uh you add three effectively turning into that you divide by four you get the full"
3858160,3865520," thing you get the full thing so you get exactly what you want uh right another situation it's when you have"
3865520,3873360," two of them you add three right and you get extra one in here you divide by four and you get rid of that"
3873360,3880480," remainder you get what you want right so essentially the only situation when um you're not gonna get this"
3880480,3887520," additional thing is when everything is already aligned that is why they add four minus one in here"
3888160,3896240," they add four minus one in here right so basically they extend uh this uh tail so then after the next"
3896240,3902800," division the extra stuff will be removed away and you get exactly the full size including the padding"
3902800,3911120," including the alignment that's why it is like that that's how they do alignment by four so and usually"
3911120,3917440," here is not really three it's four minus one and you can even say you can even generalize this entire"
3917440,3925360," thing if you want to align by some other number m you can put that m in here like so that's how you align"
3925360,3936080," by any sort of number that's how you align by any sort of number uh so there we go so that's basically how it"
3936080,3942400," works it's basically how this entire thing works but in our case uh if the function already says align"
3942400,3949280," by four so we're gonna keep it like that so yeah it's a little bit involved but it's more about knowing"
3949280,3957680," the fundamental operation of division there is nothing specific to computing or programming in here honestly"
3957680,3964160," this is the uh this requires just understanding how the division operation works"
3965120,3970640," which to be fair looking at the current state of the educational system in many many countries"
3970640,3978720," could be too much to ask from people to be fair right how many people who basically got out of the"
3978720,3987440," high school really truly understand how division works right like intuitively not on a level of memorizing"
3987440,3994000," that stuff and like some tables and stuff like that but actually intuitively understanding a division the"
3994000,4002640," operation of the operation of division um not that many people right i had to teach myself same mohat same"
4002640,4010560," seriously uh even for me when i came out of school i still didn't fully understand division until i"
4010560,4016800," started to do a lot of competitive programming and that kind of helped me to intuitively understand division"
4017360,4023200," it kind of helped me to intuitively understand division uh right so and my intuitive understanding"
4023200,4032560," and division is actually um basically thinking about groups of things and divide basically thinking about"
4032560,4042000," uh things and dividing them into groups right essentially if you have um like a bunch of a's right and you want to divide"
4042720,4051360," uh a bunch of a's by for instance five right you want to divide them by five what that means what does it mean to"
4051360,4060240," divide these bunch of a's by five you divide them into groups of fives one two three four five this is the first group"
4061040,4069680," right this is uh another group this is uh another group uh this is another group uh this is another group"
4069680,4076480," uh this is another group and uh this is the last group and then you count how many groups you've got"
4076480,4083600," you've got six of them so the operation of division of all of this a's all of this a's let's actually call"
4083600,4092000," an the amount of a's is n divided by five is equal to six it is equal to six and the remainder of the"
4092000,4100160," operation division is two so the stuff that didn't fit into the uh bucket of five it didn't fit into the bucket"
4100160,4110800," of five so the remainder division of five is two so this is how i intuitively understand division uh right and what's funny is that"
4112240,4118960," you can this operation is sort of like interchangeable in the sense that you can divide this thing by six"
4118960,4126000," and you will get five right so let's actually go and divide this entire stuff by six uh like so"
4126000,4128160," it's going to be six"
4128160,4137040," and i really recommend to actually play with sort of like objects uh playing with actually tangible objects"
4137040,4142000," that you can like move around and shuffle really helpful in understanding this entire thing"
4142480,4147360," you've got five of them and what's funny the remainder still the same"
4147360,4163840," so i think the problem is that people quite often are ashamed to explore such a basic fundamental things"
4163840,4170960," with such childish basic notions right so i'm basically explaining division right now with apples"
4170960,4177520," and pears with apples and pears literally it's just instead of apple and pears i'm using ace but i could"
4177520,4184640," replace them with apples and pears i feel like we should not be ashamed go back to elementary school and start"
4184640,4192880," talking about basic arithmetic operations like that the fact that people are ashamed to do that is kind of the"
4192880,4199120," the reason why we can't like why we see grown up people who do not understand division because this kind of stuff"
4199120,4205840," literally had to be explained with apple and pears even for adults and there's nothing to be ashamed of"
4205840,4211520," i'm thinking about division in terms of apples and pears myself and i'm not ashamed of that"
4214880,4220800," so yeah i think it's important i think it's important if we're gonna stay ashamed we're gonna stay uneducated"
4220800,4222640," right"
4222640,4230560," and what's funny is that uh i worked at a company i worked at the company where we had a system"
4230560,4238480," administrator like old school system administrator and he needed to set up cron to do a periodic thing but to"
4238480,4243360," properly come up with the formula he needed to do mod and he couldn't understand mod"
4243360,4248160," he couldn't understand what he came out to me and just basically asked like"
4248160,4252080," here's the formula i googled up on the internet it uses mod and stuff like that"
4252080,4257360," i literally can't understand mod he was actually older than me like by by 10 years or something"
4257920,4264720," i literally started to explain him the division and mode operation like this he understood it perfectly"
4264720,4270480," like within 20 after 20 minutes of just showing him this he understood it perfectly and he never came"
4270480,4276000," back to me with this question and he configured everything perfectly he just needed like a 20 minute"
4276000,4282000," of quick explanation on the level of apples and pears and now he can do like periodic operations"
4282000,4286640," in chrome and stuff like that so yeah"
4286640,4296880," and it's fine it's fine and the reason why we got into that point is not because he's dumb or anything"
4296880,4303600," he's actually extremely smart the educational system sucks the educational system fucking sucks"
4307120,4314880," um so yeah okay go so good that uh we got that so let's take a look at what's the next thing we need"
4314880,4322720," to do so we managed to align uh things in here so we've got the yeah we've got the size uh one of"
4322720,4329760," the things i really apologize that i keep switching between bright thing in a dark thing right uh so there"
4329760,4336400," is no way to put like a dark mode in there okay so people keep telling me where is the okay people keep"
4336400,4340160," telling me to install dark reader let's let's install dark reader i don't know"
4340160,4349040," so the last time i installed dark reader it actually made all of the websites um slower for me so and i"
4349040,4358640," just like uninstalled it um uh the internet is already too slow for me as it is and just like making it"
4358640,4367360," making it making it slower is not is not helping it's not really helping so is it enabled already uh so"
4367360,4374080," it's already on uh okay so we're already in dark mode so maybe one of the things i'll have to do in here"
4374080,4383280," is to refresh the website ago is that better and we lost the anchor we kind of lost the anchor is that better"
4383280,4397360," now is that better maybe uh okay so um yeah so then one of the things we're doing here is we're matching"
4397360,4405440," this size the potential size in here so we got the name we got the name now we already do do that"
4406880,4414720," so chunk length and we just align uh align by four right we're lining the size by four and we get the"
4414720,4425120," actual length in here we get the actual length and the funny oh in the in this size this is actually"
4425120,4431600," kind of cool in defining the size of the patterns you can also use a variable so you have a variable that"
4431600,4439040," matches the content and then the size can also be a variable so then you can just you know chop it like"
4439040,4446720," that that is actually super cool so we can say that okay so the content of the chunk and here is the size"
4446720,4452240," of the chunk and it's a binary and i suppose if you put binary in here it's gonna be in bytes not really in"
4452240,4460800," bits but it bites all right and then you say uh here is the rest also in binary right the rest in binary"
4460800,4468000," and this is the tail right so there you go you've got a tail and uh here we are just collecting so"
4468000,4472960," they are collecting like all of the chunks in here but what i want to do is only maybe collect"
4472960,4481200," uh the names and the sizes right so do we collect uh we collect an aligned size which is which is"
4481200,4490560," actually a good idea i think uh which is actually a good idea so let me put rest in here all right"
4490560,4497760," right and in here so concatenation of a thing is done through this sort of operator it's done through"
4497760,4514720," this operator so this is gonna be a name right right and this is the size all right so and as you can see"
4514720,4521520," we're calling to read chunks recursively right there is no loops in erlang there is no loops in her links"
4521520,4528320," you're using the recursion tail call recursion right so you give a bunch of bytes to this thing"
4528320,4535920," we pattern match them right so we extract the name of the chunk the size and the rest of the things we"
4535920,4546880," of the chunk by four bytes getting the actual size in bytes then we take um um take the tail right then we"
4546880,4552880," basically skip the chunk the length of the chunks and we continue the recursion basically collecting"
4552880,4560960," all of these things in here right so it's kind of like how you would do that in haskell as well right so"
4560960,4566560," you parse things in haskell in a similar way you do that in a similar way so that's actually kind of cool"
4566560,4573680," uh all right so can we now recompile this entire thing so it didn't like oh yeah because i actually"
4573680,4583200," provided this kind of stuff in here so uh variable chunk is unused okay so that's fine uh we can just put"
4583200,4592320," something like this stuff in here uh what else do we have in here read chunks function read to uh"
4592320,4597760," function already defined this is because i have to put semicolon in here right because it's part of the"
4597760,4603200," same definition and there you go we managed to do that so okay we should be able to now um"
4603200,4609440," try to extract all of the chunks from the beam hello and here are all of the chunks"
4610560,4615680," here are all of the chunks which is actually kind of cool so we can basically take the size of the file"
4615680,4624800," and the chunks in here right so here are the chunks uh right and what's the uh lists lists length is that"
4624800,4632320," how we do that how can i get the length of the uh of the lists all right if we take a look at these"
4632320,4639040," things so can i see all of the uh all the functions within this stuff but maybe there is a function"
4639040,4644720," specifically for length of the spelling uh length of list there should be something like that"
4644720,4657040," so here is the module for lists there should be something for length is it just len"
4657040,4667840," uh or maybe it's size maybe it's size length flat length equivalent to oh"
4668560,4669120," but i mean"
4669120,4678240," it's just length without any module okay all right so we can do length and"
4678240,4689040," boom 13 chunks there's literally 13 chunks within hello world uh right so and there's a chunk at u8"
4689040,4698080," which contains 55 another chunk is code 75 and to be fair maybe the chunk that we're really interested"
4698080,4703680," in is the code right maybe the one that we're interested in is the code i want to see the byte code"
4703680,4710560," uh and stuff like that uh all right so maybe i'm going to include the chunks maybe i'm going to include"
4710560,4717440," the chunks into like the actual content of the chunks in here i think it's going to be very very useful so we"
4717440,4722320," so we have the name the size and the chunks right so let's actually try to recompile this entire thing"
4722320,4735120," and let me try to read this entire stuff right so there we go here is the code and we have some interesting"
4735120,4742640," stuff in here so here are all of the chunks it's pretty cool honestly it's actually super cool"
4742640,4749680," uh so let me maybe close some of the stuff in here so i don't care about that uh what's that"
4749680,4757600," it's a mod operator yeah now yeah because of the dark reader everything is extra slow"
4757600,4762560," like i'm just like opening it up look how much time it takes to just color this into i think that's"
4762560,4768320," why i removed um i removed a dark career a long time ago right because it's just like it just makes"
4768320,4777680," my computer slow for no reason is it even worth it uh and freaking out uh anyways so i suppose the next"
4777680,4782960," thing we need to do we need to take a look at some other tables so here is the like list of the chunks"
4782960,4790000," that we've got in here so nothing particularly special so atom table chunk either the chunk named atom"
4790000,4799360," or the chunk named at u8 is mandatory uh right it contains all atoms referred to by the module right"
4799360,4805200," and atom if i understand correctly it's the symbols so these things are not called symbols i call them"
4805200,4812080," symbols uh uh they are called atoms actually right and i suppose that's basically what they are uh so and"
4812080,4818960," if we take a look at the atom chunk uh right so it has the name atom uh let's take a look at uh some of"
4818960,4825360," these things so it's called 8 u8 so here is that one and apparently there is only one in here right"
4825360,4837200," so yeah so there's only one 8 at u8 and there's no atom right okay uh it's maybe 8 at u8 is the one"
4837200,4844080," with utf-8 encoding right maybe something like that i don't know really so it has atom and the size and then"
4844080,4849280," number of atoms right so it contains number of atoms right so it contains number of atoms and basically"
4849280,4856640," uh the list of atoms right the list of atoms so length of a single atom is"
4856640,4863520," byte a single byte so which means that the length of the atom cannot be bigger than 255"
4863520,4872400," right so yeah so then the atom name atom length units of eights okay so basically the um you know"
4873360,4880720," the characters and it is repeated this entire stuff is repeated by the number of atoms that's a very"
4880720,4885440," interesting pattern by the way that's a very interesting pattern so you can repeat groups of"
4885440,4891440," things you can effectively repeat groups of things but when you power and match this entire thing"
4891440,4898240," um is it somehow going to bind to a single like least variable or something like that i'm not really"
4898240,4905920," sure actually uh and then you have padding because this entire thing is padded uh to you know two to four"
4905920,4913360," um the format of the 8 u8 chunk is the same as a bow except that the name of the chunk is at u8 okay so"
4913360,4921120," this was just atom uh let us add a decoder for the atom chunks to our beam file uh reader we can try to do"
4921120,4928000," that but i'm not really interested the stuff i'm interested in is actually code right i'm interested"
4928000,4934560," in the code uh the chunk name xpt export table is mandatory and contains information about which"
4934560,4941920," function is exported okay so that's very cool uh all right so essentially here we have experts and that's"
4941920,4952000," probably what they are uh right so that's probably what they are um that's pretty cool uh expert table"
4952000,4957440," chunk uh import table chunk so i suppose another thing you can do in here you can also import things"
4957440,4961920," right from from different places import table is mandatory in this information but which functions are"
4961920,4971840," imported uh so if we take a look at all of these things you have the atoms you have the code imports and"
4971920,4978480," exports lead is probably literals right string literals and stuff like that um so lock is some"
4978480,4985360," sort of location attributes additional attributes uh line type uh maybe like additional system information"
4985360,4992240," so the most interesting one for me to be fair is still code right so it is still code and i would"
4992240,4998960," like to explore it a little bit more uh code chunks okay so here's the coaching the chunk named code contains"
4998960,5006720," the beam code for module and it is mandatory the the format of the of the chunk is name size subsize"
5006720,5014480," there is some sort of a subsize instruction set must match code version in the emulator"
5014480,5021680," right so there's different instruction sets and stuff like that opcode max label count oh labels are"
5021680,5026320," probably the things that you can jump to or something like that because it's sort of like assembly right"
5026320,5037440," so function count code so the actual code chunk size minus subsize all remaining data and the padding to"
5037440,5044480," two to eight all right so let's actually read what is a subsize the field subsize stores the number of"
5044480,5053520," words before the code starts this makes it possible to add new information fields in the code chunk without"
5053520,5055600," breaking all the loaders"
5055600,5058480," huh"
5058480,5063680," but how big it is so"
5063680,5069440," oh you can decide you can actually okay"
5069440,5073520," that's very cool"
5076560,5082560," so and the question is how this this is actually quite funny so yeah you can add additional things"
5082560,5090640," and stuff like that okay uh all right so this is the code and chunk minus subsize right so you skip a"
5090640,5100240," little bit and all right i'm sorry um um subsize the instruction sent field indicates which version of the"
5100240,5105600," the options that the file uses the version number is increased if any instruction is changed in an"
5105600,5114240," incompatible way the opcode max field indicates the highest number of any opcode used in the code new"
5114240,5120960," instructions can be added to the system in a way such that all the loaders still can load a newer files as"
5120960,5126320," as long as the instructions used in the file are within the range that the lawyer knows about"
5126320,5129760," makes sense huh that's that's interesting"
5129760,5134720," they're using very interesting trick for maintaining backward compatibility"
5134720,5138800," right i should probably take notes of that right so"
5138800,5143040," the next time i'm developing my virtual machine so this is actually pretty cool ideas"
5144240,5149680," uh right this is actually pretty cool ideas right so we have additional like extra space for future"
5149680,5155520," fields and also maintain that opcode max right so you can add additional things but"
5155520,5161280," your your file may be using like a smaller range and it's totally fine uh right so it's pretty cool"
5161280,5171440," so the field label count uh contains the number of labels so that loader can pre-allocate"
5172000,5177760," a label table of the right size in one call the field function count contains the number of"
5177760,5181760," functions so that the functions table can be pre-allocated efficiently yeah okay so that makes sense"
5181760,5188960," the code field contains instructions chained together where each instructions has the following format"
5188960,5200880," the instruction code one bytes beam as an encode argument and repeat arity okay so"
5201680,5208320," it's a single instruct okay you have a single instruction you have an argument a bunch of"
5208320,5219600," argument the arity arguments encoded in a certain way for beam asm okay that is very interesting okay"
5219600,5224560," here arity is is hard coded in a table which is generated from the ops tab by again"
5224560,5229520," ops script when the emulator is built from the source okay that's that's fine the encoding produced by"
5230240,5235120," beam asm encode is explained below compact term encoding section"
5235120,5244080," okay that is so they have a special encoding of the arguments they have a special encoding of the"
5244080,5251360," arguments for the each individual opcode uh we can parse out the decode chunk by adding uh the"
5251360,5261040," following code to our program okay that makes sense that is very very interesting isn't it that's very very"
5261040,5269840," interesting so uh i would like to work on parsing the chunk but first i need to actually uh get the chunk"
5269840,5276560," somehow i need to filter that chunk out of the uh out of the list of chunks right so let's actually do the"
5276560,5284560," the following thing uh i'm going to do size chunks and i'm going to just load the beam file right so"
5284560,5292080," here's the bunch of chunks um and i keep the okay so this is hello and the size so this is the chunks and"
5292080,5303600," this is the size oh why it didn't actually rebind them all right so no match right hand side oh"
5303600,5310560," because the size and chunks are already bound variables so you can't rebind them"
5311600,5322640," okay this is this is something that really sucks about uh erlang immutable but this is not about"
5322640,5331040," immutability this is not about immutability it's about shadowing right so like that is actually fine for"
5331040,5334720," instance in rust right so"
5338480,5345600," in rust you can quite easily just do why didn't you enable rust mode emacs stupid max right so you can"
5345600,5354240," have this right and then you can have x plus 35 uh all right and then you can have println x"
5354240,5362800," and if i'm not mistaken this is totally fine in rust so let's actually wait for for rust for instance no"
5362800,5373360," mutability by the way no mutability whatsoever so and uh right you see so where is mutability i'm not"
5373360,5378240," talking about mutability i'm not talking about mutability i'm talking about shadowing"
5378240,5388880," uh right so erlang could have just allowed that it could have just allowed it it could have just allowed"
5388880,5396000," it it didn't allow that that sucks uh so yeah what i'm thinking is that i need to google that erlang uh"
5396000,5405120," um all right so um unbind variables in ripple"
5405120,5415120," um how do you unbind variables in interactive erlang shell because this is another thing that sucks about a dark rear"
5415120,5420000," okay so"
5420000,5422240," unbind so"
5422240,5424240," unbind so when you unbind"
5424240,5429360," if we'll forget the value what what's the syntax what should i do in"
5429360,5431920," okay this is a bad response"
5431920,5434240," uh-huh"
5434240,5446800," okay so f a okay a variables unbind b f okay b don't get it use f and f"
5446800,5449040," var"
5449040,5452000," don't get it"
5455840,5463840," so you assign this thing if a variables unbound is the is f uh something from erlang"
5463840,5466720," f x or am i"
5466720,5470000," it freaking is"
5470000,5475360," holy they called built-in function f"
5475360,5483360," that is insane it's just i'm looking at the examples and i'm thinking f is just a random name you"
5483360,5489040," you know like full like full bar and my brain just farts so loudly like"
5489040,5497200," you don't deserve how what what am i even looking at it's just like oh it's it's a building holy"
5497200,5512240," a good one erlang good one"
5512240,5521360," uh all right all right all right so we have size and that's totally fine okay let me see"
5522320,5526480," so we have chunks and here are the chunks"
5526480,5534400," here are the chunks so let me see what can we do uh to filter out things so this is that i'm not"
5534400,5540160," really care about i don't really care about that stuff um so i'm interested about the filter"
5540160,5543120," holy that is so freaking slow"
5544400,5551760," uh filter we provide the predicate and we also provide the other stuff so here is an element"
5553120,5563520," um so why does it do t why does it do t this is such a weird signature this is such a weird signature"
5563520,5570400," what i would expect what is dot dot or the colon colon is that like a type yeah i suppose it's okay"
5570400,5578480," it's it's a type so even though it's dynamically typed there is some sort of like a type um annotations"
5578480,5585920," in this sort of style even though i didn't think it's a uh it's a proper syntax so erlang but in any case"
5585920,5594240," so we can do lists filter and the predicate comes first and how do i do"
5594240,5606320," the functions so can i do fun fun x and let's say it returns true right and the boolean is either true or false"
5606320,5620800," it's either true or false"
5620800,5633040," i'm sorry i just like can't dark reader this is literally the reason why i didn't install dark reader"
5633040,5639680," right the next time somebody asked me zozin just installed that no no no sorry"
5639680,5645680," um okay so it's either true or false it's it's literally like a symbol right it's literally like a"
5645680,5651280," symbol um right so it's going to be true and i probably have to put dot in here and there was"
5651280,5659280," like a problem with the syntax do i have to put end in here uh right so okay what i need to do"
5659840,5668400," uh what i need to do uh so i probably have to maybe put semicolons in here"
5668400,5672960," okay erlang anonymous functions"
5672960,5679520," erlang anonymous function can okay there are some functions in here"
5681680,5688400," yep yep yep yep yep yep yep show me just show me an example okay so you just put end in here um"
5688400,5695600," all right so yeah that's precisely what i did in here i think it still says that i have uh"
5695600,5703200," a syntax error okay so and if i put false in here it returns nothing so and essentially what i want to do"
5704080,5716560," is basically if uh name right so here we have name uh right and we can say that the name is equal to"
5716560,5725440," code right is that how you do this kind of stuff i wonder so no function close matching uh which is bush"
5725440,5733840," uh because one of them is actually the size uh no matching of the right hand side this has to be"
5733840,5740880," equals equals can okay there we go we found the code right so this is how we can find the code we can just"
5740880,5749600," filter out and we can get only the code all right so and essentially we can just have code in here"
5749920,5757760," uh the size that we don't care and uh basically the code chunk right we can assign it like that uh no"
5757760,5765280," matching right well i mean it's inside of the list and we got the code in here all right there we go so"
5765280,5773280," here is the by like binary of the code itself the binary of the code itself right so and we can start"
5773280,5779840," parsing that specific thing we can start parsing that specific thing uh all right so what"
5779840,5787840," are you still in for two hours and i didn't get into actually like learning and generating and stuff"
5787840,5796160," like that uh so but i kind of want to honestly i kind of want to so i suppose i'm gonna make a small"
5796160,5801760," break i'm gonna make a small break and i'm gonna make another cup of tea and we're gonna go for another"
5801760,5807360," hour and we'll try to parse each individual like uh instruction right because i want to get the list of"
5807360,5813440," the instructions if you know what i'm talking about i want to see the list of the instructions so uh after"
5813440,5818480," we get the list of the instructions we'll see maybe we can generate some of them right that will be"
5818480,5826080," interesting i think all right so let's make some break and um okay uh so let's actually try to parse"
5826080,5833360," the code changos right so let's try to parse code changos um maybe i'm gonna even say something like"
5833360,5841280," um yeah read read code right and this is where we're gonna accept this entire thing right so this is where"
5841280,5848240," we're gonna accept it um so but when we're filtering out the code like that the way we did in here right"
5848240,5857440," we don't get the name of the chunk and the size of the chunk right we don't get it um"
5857440,5865440," so that means we only have to parse the rest of these things in here so i might as well maybe create"
5865440,5872560," uh so the copy paste this thing as a reference and just keep it in here so i don't have to switch to"
5872560,5879600," the documentation uh over and over again so that means in here we have a subsize right so we've got"
5879600,5888960," the subsize of the chunks uh here is the subsize uh maybe then we have an instruction set uh right so"
5888960,5900400," this is the instruction set uh opcode all right opcode uh label count label count"
5902960,5910000," function count and then we get sort of the rest of the stuff can you see what i'm doing here you can't"
5910000,5916080," uh right so function count and then we have a code and the padding and stuff like that but i can say"
5916080,5921680," um i just accidentally copy paste it incorrectly i should have actually done it like that"
5921680,5927040," we can say basically tail binary right so this is the rest of the stuff we don't really care about it"
5927680,5933680," so and what i want to do i want to basically extract all of these values from here right so i want to"
5933680,5941920," put subsize in here then instruction set right instruction set like this but if i just do that"
5941920,5949120," i'll get just a bunch of numbers and it's really difficult to understand what each number means which"
5949120,5954320," one is going to be function count which one is going to be something else blah blah blah right so we need"
5954320,5960800," some sort of like a table associative array or what not if you know what i'm talking about uh right so"
5960800,5967120," we have unused tail i wonder if i can do something like that like in uh in rust just underscore in front"
5967120,5974320," of the name i can't do that but that's literally has to be a full underscore um right function read"
5974320,5980960," code is unusual ah this is not what it's complaining about it's complaining about this thing being unused we can"
5980960,5987520," try to go ahead and export this thing so it has our arity one right because it accepts only one argument"
5987520,5993440," right so that's that makes sense okay so that seems to be and prefixing underscore as you can see actually"
5993440,6000960," worked so we can use that um you know trick from rust to do this kind of stuff uh anyway so here's the code"
6000960,6008720," we've got from the hello this is not really what i wanted uh here's the code i can do uh bim read code"
6008720,6015280," code like so and this is the numbers that i've got as you can see i get a bunch of numbers there's they're"
6015280,6021840," not particularly useful so what i'm thinking we need to have some sort of like a table or associative array"
6021840,6031760," does erlang has anything like that erlang associative array if not we can resort to a list of pairs right"
6031760,6040880," so uh associative comparison of programming languages associative array from wikipedia so okay let's take a"
6040880,6056560," look at the list of pairs literally the thing i said and they even have uh helper functions that to to"
6056560,6066160," find the things with okay this is so funny freaking hilarious anyways so okay essentially what we can do in"
6066160,6074800," here is just something like this um i wonder if we could automate some of that stuff but i don't think"
6074800,6086880," we can easily do that so we can do subsize right instruction set this is another one opcode max another one"
6086880,6096000," label count another one another one function count another one so they're using strings"
6096000,6104400," as um the keys i'm using symbols or atoms uh instead of strings so now if i do something like that look"
6104400,6116240," what i got so subsize is 16 uh right uh what the f is going just a second um instruction set is zero the"
6116240,6125840," maximum opcode is uh 169 right so then the amount of labels we have seven and a function count is three which is"
6125840,6134400," which is kind of weird which is kind of weird right because i only exported um two functions right"
6134400,6139840," so one function hello maybe there are some other functions that are implicitly exported in there"
6139840,6147680," maybe there's some sort of i think i remember there there were some sort of like init functions"
6148400,6156560," erlang module init function so basically the function that is called when you load the module or something"
6156560,6165920," like that uh it's a preload code containing coordination of system startup um this module and now it's not that"
6168960,6174640," but i don't know but i don't know erlang"
6174640,6179280," list all functions of module and let's actually go to google"
6179280,6194560," uh so get list of modules exported functions m if module is named same accent then m or okay so m hello"
6196160,6204800," aha here they are module info all right so that means i can do hello uh module info and i just call"
6204800,6210720," this function and it gives me information about the module and module info some sort of stuff in here"
6210720,6217040," i suppose maybe i can provide the one of the keys in here right so for instance if i provide the"
6217760,6225520," module module like this yeah i can extract i can extract individual fields out of this thing right"
6225520,6233520," so this is basically experts and yeah so that is really funny that is really freaking funny i didn't"
6233520,6239840," know that so even though you export it like one function the actual expert also contains module info so"
6239840,6246480," which gives you like additional information about all these things okay so that explains"
6246480,6255840," that explains why when we read the code right as you can see here we read the code the function count is"
6255840,6263440," actually three the function count is actually three because there are additional two functions module and"
6263440,6269280," four for introspection for a reflection of modules and stuff like that i literally didn't know about that"
6269280,6276880," before the stream right so people ask me how do i learn things how they uh do i know so much stuff i just"
6276880,6287200," explore ship like that right in front i learned i already learned a lot uh like on today's stream right"
6287200,6290560," i already learned a lot on today's stream"
6290560,6300160," so people know it people know it i around i around until i found out and i found out that's actually pretty"
6300160,6306640," cool uh so but the reason why i even assumed that maybe there is uh like"
6306640,6311280," implicit functions is because i actually encountered something like that before in my"
6311280,6318320," sort of career right so a little bit of experience kind of helps you to explore things in the right"
6318320,6324080," direction if you know what i'm talking about right so the more experience you have the easier it is for"
6324080,6330720," you to explore things by fucking around because you can not only fuck around you can actually fuck around"
6331440,6338080," there directionally right so you can kind of know how exactly to fuck around right the more information"
6338080,6343760," you have the more efficient you're fucking around you know what i'm talking about you know what i'm talking"
6343760,6348480," about yeah so additional experience kind of helps to fuck around"
6349840,6358960," more information more information more good you fuck that's a good way to put it i suppose"
6360640,6378640," um so then we have a le code uh then we have a le code and what's funny is that uh so we take the chunk size we take the chunk size and then we subtract the subsize"
6378640,6387360," uh so we take the chunk size uh so we take the chunk size we take the chunk size and then we subtract the subsize"
6387360,6396080," and that is basically the rest of the remaining data but that is kind of not true isn't it"
6397440,6406800," because the actual code comes after the subsize doesn't it spelling it out like that implies that"
6406800,6417120," it comes right away it comes right away after the function count and then you should then include subsize"
6417120,6421520," within the padding but padding set to be uh from zero to three"
6421520,6425120," uh so"
6425120,6433440," this is a very weird uh you know representation of how the code is laid out so i suppose"
6433440,6436160," this is more like a pseudocode than the real pattern"
6436160,6441920," um right so it's more of a pseudocode than the real pattern at least that's what i would assume"
6444640,6452400," okay the field subsize stores the number of words before the code starts right so that means"
6452400,6459520," this subsize must be somewhere here right so have function count and there should be something like"
6459520,6472480," subsize of i don't know right so extension subsize binary something like that i think that's what it has to be"
6474640,6484240," right right so and i don't really know why they didn't properly sort of put that in there like i do"
6484240,6493040," not fully understand but anyway maybe we need to take a look at their code right let me take a look at their code"
6495520,6500160," so here parse chunk we get got then subsize chunk"
6500160,6504480," or maybe by the way"
6504480,6506880," ah"
6506880,6509360," okay"
6509360,6519920," it's pro that size probably includes that size probably includes uh all of these things"
6520560,6527360," right right so in our case the subsize was 16. all right so and what do we have in here"
6527360,6532880," we have four 32-bit values"
6532880,6542480," uh i mean i don't need python i don't know why i reached to python um right where is my where's my stuff"
6542480,6543600," 4 multiplied by 4"
6543600,6551360," 16. so subsize tells us"
6551360,6554880," the size of this thing"
6554880,6560880," that is really funny actually that is really funny"
6560880,6569120," so uh subsize is the size of this table of meta information about the code"
6569920,6572720," and that's why there is no additional padding in here"
6572720,6579520," you know what i'm talking about so that's why but we still kind of need to take that into account"
6579520,6587920," right so because maybe in the future right our loader our loader is going to"
6587920,6594400," encounter like new version right so and there are additional fields in here so what we have to do"
6594400,6599520," do we have to just read all of that information right all of that information and just skip subsize"
6599520,6605520," of things um right so that's probably what we have to do okay makes sense"
6605520,6611360," interestingly interestingly what i think is that"
6611360,6617920," we can even go further and just match only 16."
6619440,6626640," right essentially if we encounter anything that is not 16 um all right we can say we can't load that"
6626640,6630080," code we we just can't load that code we can do something like that"
6630080,6637920," that would have been interesting that would have been interesting funny enough what how they"
6637920,6646720," implemented they actually take um the code oh they've done a very funny thing actually"
6647360,6653440," they've done a very funny thing they accept the list of different chunks"
6653440,6662800," the list of different chunks so their parts chunks function can basically accept all of the chunks that we"
6662800,6670560," extracted from the file okay that is a very interesting way of doing that um"
6672960,6680000," that is really funny way of doing that i really like that so they have uh parse chunks and if you"
6680000,6685840," encounter a chunk that you're aware of you parse it and transform it to something else if you encounter"
6685840,6692160," chunk that you don't know yet we just leave it as it is we simply leave it as it is so none of"
6692160,6698880," that is sparse that is a very good way of approaching that i really like this book i really like this book i"
6698880,6704400," i suppose i think i want to read it more right just like i'm looking at one chapter and one chapter is"
6704400,6708960," actually contains a lot of like useful information and the code is organized in a really nice way"
6708960,6717040," so you can just like learn a lot from it uh and i really like that i really like that so that's already"
6717040,6723280," better than what i'm trying to come up with right so as you can see here uh they read the chunks right so they"
6723280,6733840," read the chunks uh and in here all right so we just do that do they parse the chunks afterwards they'll"
6733840,6740080," really parse them right it's sort of like a separate function and do they use them anywhere parse"
6740080,6750080," chunks aha so they actually ask yeah okay i see so they uh read the chunks and then they parse the chunks"
6751280,6756080," that makes a lot of sense okay so maybe we should do the same thing honestly i think it's kind of cool"
6756080,6762960," i think it is in fact kind of cool so parse uh parse the chunks"
6762960,6765520," parse the chunks"
6765520,6779680," so yes so yes so we read the code maybe this stuff is not particularly useful but uh that's totally fine"
6780320,6786400," so parse chunks uh and what we're accepting here we accept a single chunk"
6786400,6793040," and then the rest of these chunks so we can even do something like this okay so if we encounter"
6793040,6799680," an empty list we just transform it into an empty list not in particular it's funny how emacs automatically"
6799680,6808720," supports that it's really funny i can try to do that again look at that parse chunks uh right boom okay"
6809440,6818880," boom the next one the next part can your mouse pad do that can your mouse pad do that i don't think so"
6818880,6827440," uh anyways so here's the rest and what you're supposed to do so we actually build an accumulator out of that"
6827440,6832880," so we build an accumulator out of that but i'm not sure if i want to do it through an accumulator maybe i"
6832880,6840320," should maybe i should build an accumulator okay so let's let's do it like that so we go we're returning"
6840320,6847120," an accumulator but the list is going to be reversed uh all right and in here what do we do if we just"
6847120,6855840," encounter the chunk that we never seen before uh we simply just you know pass it next right so this is"
6855840,6863120," going to be rest and then chunk to accumulator and as we process all of them as we process all of them"
6863120,6869520," uh right we're going to just return that specific list i think i think that's a good way to do all of"
6869520,6879920," that uh and we don't really need to export read code anymore so and i can transform the code uh like read code"
6879920,6888320," read code as one of the cases in parse chunks right so i can do parse chunks and here what i encounter i"
6888320,6896720," encounter a chunk with the name code and with the size right so and with the size and then some content"
6896720,6904000," in here and that content is basically uh these things right it's basically these things so i can just move"
6904000,6912960," them in here and when i encounter those things uh i am using this specific sort of associative array"
6912960,6921680," uh right and i just return that so and i can might as well just put this stuff in here yeah that is a"
6921680,6927120," little bit better right so essentially the chunks that we don't know we just ignore them the chance we"
6927120,6933200," do know we transform them into something useful that we can maybe use for something right so like in for"
6933200,6940080," example in here and i wonder if i can maybe format that a little bit better is that something i can do"
6940080,6949200," uh like this because i don't kind of like how long it is um right so but it doesn't allow me to"
6949200,6957280," look at that that's not bad that's a really readable pattern i think that's a very readable pattern look at"
6957280,6966960," that chunky code from the beanbook sounds tasty yeah it does okay it doesn't compile okay it's cool"
6966960,6975840," yikes okay so what do we have in here um so a head mismatch right so we've got a head mismatch"
6975840,6981040," this is because we need to have the rest of these things right so uh we'll get the rest of these things"
6981040,6987920," and we need to proceed keep calling this function right we're calling it on rest and essentially what"
6987920,6992400," we're doing here we're just appending it to the accumulator right so that's how we're going to be doing"
6992400,7002400," all that um so i can maybe actually take this entire thing and assign it to some sort of variable right so"
7002400,7009840," because i don't want to make very chunky expression like that right so info let's assign this thing to"
7009840,7017760," info right or maybe we're going to call it code info code info so this is our small code info that's pretty"
7017760,7025680," cool and then we continue parsing things and i just append code info to this specific accumulator like so"
7026960,7033360," uh all right so let's try to compile that stuff uh so what you don't like head mismatch again"
7033360,7045200," really for for real ah yes okay so there should be okay i see i see so i should also accept an accumulator"
7045200,7051600," there we go that makes sense now okay so that's why there is a mismatch in there that's why okay"
7051600,7056720," now now we're talking now we're freaking talking so i don't really care about that specific function"
7056720,7062080," so i'm going to just look market like this and uh we're almost there so there is a function"
7062080,7070320," uh parse chunks two is unused which is kind of um yeah so this specific thing is unused you tell me"
7070320,7077040," right so maybe maybe we have to put it at the end somewhere right for for this thing to to work"
7077040,7085840," but that is kind of bizarre don't i use this function already i use it in here um so and i export it so"
7086480,7094160," i don't know why you're complaining so parse chunks ah i see because we have to do it like that"
7094160,7102080," okay finally i managed to compile all that so it is kind of difficult to compile for a dynamic language"
7102080,7109120," isn't it right it's a dynamically typed language and i kind of struggling to compile it um which is quite"
7109120,7118160," funny in my opinion which is quite funny quite ironic as well uh all right so okay so now i can try to do"
7118160,7127840," beam uh read file and i'm reading hello beam hello beam uh so oh yeah i supposed to put dot in here so"
7127840,7135120," instead of this thing uh and define function boom beam read okay so this is just read all right okay so we've"
7135120,7141200," got a bunch of chunks chunks that we don't care they are unparsed right so they they are unparsed"
7141200,7147360," the chunks that we do care here's the code chunk it is kind of parsed already all right so we extracted"
7147360,7155680," all of these things uh and everything so that's exactly what i wanted that is exactly what i wanted"
7155680,7162640," code chunk code chunk uh so and the question is how are we going to be parsing the code right so we've got"
7162640,7173120," the info uh the info oh and they basically group all of that info things like instruction set opcode max"
7173120,7181200," label count and function count into a single info thing and then the code which is quite cool i think"
7185200,7193760," and then they take up code size size size and uh and subsize minus eight i don't know why they do minus n in"
7193760,7197680," here uh eight is the size of cong"
7207680,7220000," um cong size what the fuck uh um length for real yeah so it's basically it is the size of the chunk"
7220000,7229840," size and a subsize okay so so here is the opcodes we're extracting the opcodes and then we're just parsing"
7229840,7236800," them in a separate function we're parsing them in a separate function which is reasonable thing to do"
7236800,7244240," i suppose which is a reasonable thing to do i really like this idea right so just do it like that so we"
7244240,7252320," have instructions subsize right so then you have info all right and you say that info is basically binary"
7252320,7259200," binary it's basically binary of the size of subsize and that's it so that's how you do that"
7259200,7266240," it's a really funny way of doing that right so you have subsize and then you instantly matching the"
7266240,7271920," this is kind of cool the fact that you can do that in early you can match a variable a certain variable"
7272480,7276880," and instantly use that variable in the next expression i think that's a thing you can do"
7276880,7284080," yeah okay let's actually see maybe maybe you can't do that and then being too cocky about that but uh"
7284080,7291760," yeah subsize we can then uh probably um get rid of all of that stuff in here and we can say this is"
7291760,7299280," the info right so that's basically the info uh right so i don't know what the i'm doing here and"
7299280,7307280," let's try to read that and yep you can do that that is very cool you can match a variable extract"
7307280,7314320," information and instantly use that variable in the next match so you know how many bytes you have to"
7314320,7322400," match you can match it on the next expression sibling expression that is so fucking cool holy fuck"
7323920,7334080," um i'm i'm telling you parsing binary is easy in erlang is easier in erlang than in c how crazy is that"
7334080,7345920," so after the info we basically i suppose we get the code right so we get the code"
7347920,7353360," right so that's what we can do but personally i don't like that they call that thing a code"
7353360,7363680," right well i mean technically it is code actually technically it is code um so maybe that's fine"
7363680,7374000," so the next thing they do the next thing they do uh size subsize and eight so we can just take that"
7375920,7386000," um still not fully understand how that works right so uh this is the full size of the whole chunk right"
7386000,7393200," it's the full size of the whole chunk and it does include the subsize right okay that's probably why"
7393200,7399120," they they do it like that i personally would like to do it like this maybe to emphasize right so we're"
7399120,7408160," subtracting the size of the info right so the subsize the size of the info and also the size of the subsize"
7408160,7416080," field right because size does include like it includes everything in here it literally includes everything"
7416080,7423200," here so that's why it is like that and after that uh we're just parsing out the the code right"
7423200,7430880," so there's the opcode size we get opcodes and then we get a line binary and stuff like that"
7430880,7437120," so and uh maybe we can just do opcodes so opcodes"
7437120,7439840," like so"
7442320,7449040," so let's see if we can compile this entire thing so info is not used which is kind of funny right so"
7449040,7458400," the pattern match info but oh they actually i see what's going on the parse code info and then opcodes"
7458400,7465520," i see i see i see what's going on like we already saw info so we probably don't have to parse that thing"
7466240,7475840," bit type binary binary as in defined okay all right so here's the opcodes and here are these opcodes"
7475840,7488080," so i'm more interested in parsing opcodes rather than the code info so and kind of the thing is done in here"
7488960,7495840," right um so the encoding produced by beam as in okay"
7495840,7505440," compact term encoding section okay so all right"
7505440,7517200," so they omit the parsing of specific opcodes in this section completely they omit that"
7518640,7525200," uh all right but we still managed to extract the you know the code section of this entire thing"
7525200,7531920," we still managed to extract it so the only thing we need to do we need to you know start parsing each"
7531920,7539760," individual instructions in there um all right so i think i'm gonna stop the stream in here i'm gonna stop"
7539760,7546640," the stream in here um right so what i'm gonna do i'm gonna probably schedule another stream and that next"
7546640,7553440," stream is gonna be entirely dedicated to parsing opcodes and maybe even generating opcodes and on that"
7553440,7559760," stream i'll try to prepare and see maybe on that second stream we're gonna actually write a simple"
7559760,7567200," programming language that compiles down to these opcodes right so today's stream was dedicated to"
7567200,7574160," exploring the beam format the beam format and i think we did it quite successfully we also learned enough"
7574160,7580240," erlang to do that efficiently right so i think it was extremely educational right so i wouldn't say"
7580240,7586240," that today's stream was a failure it was actually a win right we learned a lot of stuff in here right so"
7586240,7591920," and i can see myself using erlink in the future for just parsing binary it's actually very convenient"
7592640,7601760," um right so yeah that was pretty cool uh i guess that's it for today uh thanks everyone who's watching"
7601760,7606560," me right now i really appreciate that have a good one and i see you on the next recreation programming"
7606560,7612640," session where we're going to continue exploring the format of beam and hopefully maybe create a simple"
7612640,7620640," language that compiles down to uh this entire format the ultimate win is going to be creating a beam file"
7620640,7627760," out of our custom language and then just loading it with erlang repl running it and it will say something"
7627760,7632480," that we said in the original language that would have been an ultimate win i think"
7633440,7639440," uh we'll see how it goes okay thanks everyone i love you"
