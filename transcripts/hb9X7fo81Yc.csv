start,end,text
960,7120," Hello everyone, and welcome to yet another recreation programming session. How about that?"
7120,12720," So we're working on Google, which is Google for C, believe it or not, right? So essentially here is"
12720,20000," the idea. You have a command line utility, right? So I made it so right now you supply a file. For"
20000,26720," instance, I'm interested in Rayleap right now, right? And it's going to search within that file."
26720,32720," And the queries that you can make is essentially they have the following syntax. For instance,"
32720,37360," the classical example that I like to use is basically a function that accepts a caller"
37360,44640," and accepts a float and returns another caller. So that's essentially how it looks like, right?"
44640,51040," So and show me all of the functions that accept one caller float and returns another caller. So"
51040,56320," functions like that probably will modify some aspect of the caller, right? For instance,"
56320,61680," maybe alpha, maybe brightness, maybe something else. And you go ahead and search for it. And here are"
61680,66960," all the functions that match that specific query. You have a caller contrast, right? So it accepts a"
66960,73760," caller and float, caller alpha, fade, brightness, and also it matches some other things that are similar"
73760,79200," to that. For example, set, sound, pan, volume, pitch. And the first thing is a sound and the second"
79200,86000," one is float. So it not only strictly matches those things, right? It not only strictly matches those"
86000,93200," things, it actually matches them positively, right? So if you're not sure exactly how the type signature"
93200,99280," looks like, it will just like find something that is close to that. It will just find that that is close"
99280,106000," to that. So and it's a prototype, right? So it's completely unfinished. It may crash on unexpected"
106000,112160," things. And that is what happened when I was trying to use it for different things. For example, there is a"
112160,121920," thing along with the Raylib, in fact, it's RayMath, right? It's RayMath. It already has like a function"
121920,128240," vector to scale, right? So it accepts a vector and just like multiplies the scale that you're providing"
128240,134320," there to each individual component. I wanted to find something like that, but with addition instead"
134320,141440," of multiplication, right? So the easiest way to do for me, the easiest way for me to do that would be to"
141440,149520," ask the following thing. RayMath, like find all of the functions that return vector2, accept vector2,"
149520,154560," and accept float, right? So among them are going to have vector2 scale, but maybe there is going to be"
154560,162160," another function exactly like that, that adds things instead. And this entire thing crashed, right? So"
162160,167840," isn't that great? Like a really similar situation and it already crashed and it crashed for a very"
167840,175600," weird reason, right? So the traversal, right? Because we're using libclang to parse AST and then we're"
175600,185600," traversing AST. The traversal encountered like an expected kind of node, right? And the reason why it"
185600,194320," did like that, so let me show you. So essentially, let's imagine that we have an AST. It stands for"
194320,199440," abstract syntax tree, right? If you never encountered anything like that, it's an abstract syntax tree. So"
199440,206240," essentially, you take the source code, you analyze its syntax, and you build a tree that corresponds to"
206240,213520," that syntax, right? So if you are careful enough and you look at the code, you may notice that the source"
213520,219600," code has a lot of nested things, has a lot of nested things. Well, the entire source code can be represented"
219600,226960," as a tree as a tree, right? So essentially, maybe you have, you know, the function declaration, the function"
226960,235120," declaration, and then you have arguments like that, right? So each individual argument in here, and then"
235120,241600," maybe the entire function declaration is within a file, and like the entire source code can be represented"
241600,248320," as a tree, and such tree is called as an abstract syntax tree. So libclang, the library that we use to"
248320,256160," parse and analyze the tree, has a notion of a cursor, right? So, and it calls it CX cursor for whatever"
256160,263600," reason, probably Clang X, I don't know why it calls it CX, but it's called CX cursor, right? And it's"
263600,270080," just a pointer to the current node, and you, given that pointer, you can ask different questions about that"
270080,275680," pointer, that cursor, like for example, what's the type of the current node, what's the kind of the"
275680,283680," current node, how many children does it have, and so on and so forth. So the way we gather the arguments"
283680,287840," of the function, right, the way we gather the arguments of the function is basically, we have"
287840,293920," the pointer to the function declaration, and then we do recursive traversal down, right? We do recursive"
293920,300000," traversal down, and we collect all of the param declarations, right? So if you"
300000,306160," have a function declaration, and it has a child, which has a kind param declaration, it's probably an"
306160,313920," argument. So we collect that, we essentially collect that. But apparently, function declaration may have"
313920,322560," more different kinds of children's that are not arguments, especially if it returns like a type"
322560,329840," definition or something like that. So it's not this particular strategy of gathering arguments of the functions,"
330880,336960," it's not going to work that well. It is not going to work that well. So one of the things we can say is"
336960,346320," that essentially don't crash if you encounter an unknown kind of node. Maybe what we can do is essentially"
346320,354480," we can print a warning, right? So we can just say, warning unexpected child kind. And on top of that,"
354480,360000," we can maybe print the location of this entire thing. So we know where this warning has happened. So maybe we"
360000,368480," can, you know, handle that situation somehow, right? So here we can provide the file path, row and column. And we"
368480,378800," we do have file path somewhere in a function function, func file name, func row, func column, right? So I think crashing in this"
378800,387520," particular situation is not a great thing to do, right? It is not a great thing to do. So let's try to rebuild the entire thing. I'm going to do"
387520,394000," Linux and there we go. So we rebuild this entire stuff and I'm going to try to search one. Oh, okay."
394000,396960," God damn it. I forgot to put a new line."
398880,402720," Just a second. I need to kill my Emacs now. Okay. I don't have to kill."
402720,407280," Uh, I think, I think I don't have to kill Emacs. So let me just do that."
407280,412400," So we've got a little bit lucky. So it didn't completely kill my Emacs."
412400,417520," So essentially, if I didn't provide a new line, it will just print everything on a single line and Emacs"
417520,425840," doesn't like that. It's very difficult for Emacs to handle very long lines in 2023. It's a very old text editor, okay?"
426400,432720," So back in the days, they didn't have such long lines. So it doesn't know how to handle them. So, and"
432720,440640," okay, it kind of works. It kind of works. Um, but, uh, it just prints a lot of warnings. Also,"
440640,446800," it prints them in a really weird way. I wonder why. Uh, this is because we're supposed to print the kind"
446800,453840," at the end in here, right? So let's try to rebuild this one more time. And, uh, there we go. So there's a lot"
453840,460400," of warnings in here, but at the same time, it kind of works. So I can find, uh, things that I need. Okay."
460400,466640," So there is a subtract, subtract value, right? Which is almost like what we need, but it just subtracts"
466640,473520," it. And there is a similar thing at value, right? As you can see, it's very convenient, right? So I know"
473520,479840," precisely what I need. I know that there is a high probability of having that function because there is"
479840,485840," already function like that vector to scale. So there must be something with different kinds of operations."
485840,492480," So I just make a query. Okay. So find me something that looks just like that. And it's fine, right?"
492480,497440," So that's why I work, you know, this utility, because this is something that I really needed for quite some"
497440,503520," time. And something like that already existed for, for some time as well in the form of Google, but for"
503520,509520," language called Haskell, right? So if you're interested in what exactly inspired this tool,"
509520,515280," this is what inspired it, right? So it's called Hugo, right? And here I can take an integer"
515280,522160," and convert it to a string. And it found some function in some package that does that. I can invert that,"
522160,531040," so string to integer, right? And for example, utf8 encoded length, right? So I think something like"
531040,537600," just length would fit a little bit better, but I think length is specifically for any list. Yeah. So"
537600,544320," length is specifically for any list and string is a very specific list, right? So this is what inspired"
544320,550640," to create something like that, but for C. So right now it has a command line interface, but it may change,"
550640,556480," right? So the interface to this search engine is not as important as the search engine itself,"
556480,561280," right? So people keep asking me, how is it going to, how are you supposed to input this stuff? Is it"
561280,566160," going to be a command line? Is it going to be web? It doesn't matter, right? So what's important is the"
566160,571680," search engine itself working correctly, right? And as soon as you have the search engine working correctly,"
571680,577200," you can slap whatever interface you want in it, right? So it's just like, it's the most known problem"
577200,581600," problem that we have right now. What we have right now is the problem with the engine itself and how"
581600,590240," it parses things, okay? So learn how to think more abstractly, learn how to view a bigger picture. The"
590240,597680," interface where you put the text is not a bigger picture of the system. Anyway, so it's kind of cool,"
597680,603360," but the warnings are kind of annoying, right? So essentially, the fact that we need to put a"
603360,611680," warning means that we don't really know what we're doing. So we can have things that are not expected."
611680,618880," So what would be ideal is some sort of a way to basically ask, okay, I have a function declaration"
618880,623920," type. Give me all of the arguments of that type and nothing else. If you have some other children,"
623920,629040," like I don't care about them. I have a type of the function declaration. Just give me the arguments."
629040,636160," There should be something for that. And you know what? Like the reason why I implemented it like that is"
636160,642400," because LibClang API is S. And it's very difficult to find anything useful in it because they have these"
642400,647600," crazy naming conventions. They call things in a really different way. I know that there is a reason why"
647600,651120," they call it like that. But I mean, when you first encounter the code base, it's kind of like"
651120,663520," difficult to work with. So can we actually use this tool to analyze LibClang API and find something"
663520,671760," better, find a better approach. Can we use LibClang to defeat LibClang? Because I've been complaining"
671760,678080," about LibClang API for like two streams already. Right. But now we have a tool that allows us easily"
678080,686400," analyze LibClang. We can defeat, we can turn LibClang against itself and finally defeat that dragon."
686400,696960," By the way, isn't LLVM logo is literally a dragon? It is literally a dragon. Get fucking damn it. I mean..."
696960,704400," So the irony is so fucking huge, right? So it's just like here."
704400,712800," LibClang is literally a dragon that you need to defeat. Right. So we can turn that dragon against itself"
712800,718480," and use this tool to analyze LibClang API and find the things that we actually need. Okay."
718480,725760," So let's give it a try. So essentially, as far as I know, LibClang API is located somewhere in,"
725760,733200," you know, bindings generator in JAI. We're using JAI, by the way. So this is a non-existing language. If"
733200,738800," somebody never actually saw that before. Right. So it's a language that is enclosed beta. Right. Well,"
738800,746560," I'm one of the better testers. Right. So, and it has in the standard library LibClang. Believe it or not."
746560,752080," That's how awesome this language is. It has a LibClang in the standard library. How about that?"
752080,759200," Your Rust cannot do shit against that. So here it is. So this is the main sort of like an index.h"
759200,765840," and stuff like that. This is where... This is sort of like an entry point to the LibClang API. Right. So"
765840,774080," let's try to maybe find some things in there. Right. So I'm going to go back to Google and I'm going to"
774080,783920," try to give it the path to that file. So it's JAI modules bindings generator clang.c and we take an"
783920,791280," index.h and let's try to find the following thing. So for example, one function that takes CX cursor"
791760,799040," and returns CX type. The type of that cursor. Can we find something like that? There's a lot of warnings."
799040,806080," And okay. So we literally have functions clang cursor get receiver type. We can even jump there."
806080,811360," That's actually very convenient. And there is literally get cursor type. Right. So here we go."
811360,818080," So that's how easy it is to just like find that. I don't have to come up with like weird grabs or"
818080,823760," anything. Like I know that there should be a function that accepts a cursor and returns the type."
823760,828640," And I get that entire thing. That is very, very useful. And this is the function that we already use."
828640,833040," Right. So essentially, it's somewhere here. So we have a cursor. So this is the curve."
833680,838560," And we check its kind. And it's a function declaration. Right. So we know it's a function"
838560,844000," declaration. So we take its type. It should be a type of the function. And then we get a result type."
844000,850720," And then we just save it and stuff like that. So let's try to think logically. Let's try to think"
850720,859040," logically. If it's a function declaration type, it may have arguments. Arguments are a variable thing."
859040,864080," So you can have several of them. You can have zero of them. You can have one. You can have two. And so"
864080,871840," on and so forth. There must be a function. There must be a function that accepts type and returns you"
871840,878640," the amount of arguments that the type has. Right. It should accept cx type and return some sort of an"
878640,885680," integer or long size t or something like that. So what if we literally just go ahead"
886960,893040," and ask a question to the system? You accept cx type and return an integer. Do you have something"
893040,895680," like that? All right. So what do we have?"
895680,902720," Retrieve the number of non-variatic parameters associated with the function type."
907600,915520," 2Dragon has been defeated. Fuck you, LipClank API. Fuck you. You've been defeated. I'm not gonna actually"
915520,922400," fall into your bullshit. I have Google. Now I can ask meaningful questions to the source code and get"
922400,930400," meaningful answers. All right. So it's kind of interesting. So non-variatic. I didn't think about"
930400,936240," variatic arguments, by the way. So we'll have to think about how to incorporate variatic arguments into this"
936240,941520," entity, I think. But I suppose it should be pretty straightforward. Right. So syntactically, at least,"
941520,951520," if the function accepts variatic arguments, it could be just like one additional token. Right. So it's one"
951520,956800," additional token in here and you just match by that. So yeah, it shouldn't be a problem in my opinion."
957920,966640," So, and nearby, we have an associated function. GetArgType. Retrieve the type of the parameter of the"
966640,973680," function. So that's basically it. That is basically it. So we can take the amount of arguments. We can just"
973680,978560," iterate with the for loop. And for each of these things, we can just accept that. That's freaking"
978560,983840," perfect. Perfect. That's literally what we wanted. That is literally what we wanted. So let's go ahead"
983840,989920," and quickly do that. So instead of like taking the children and stuff like that, we really don't care"
989920,1001280," anymore. We really don't care anymore. So what we're essentially doing is clang get numArchType."
1001280,1007920," Right. And we probably want to save this entire thing to some sort of like an n. And we need to have"
1007920,1013920," the type of the function declaration. Unfortunately, I didn't save this entire thing. Maybe it would make"
1013920,1022080," sense to save this entire thing like so. Right. So here is the function. Here's the name. The return type."
1022080,1029360," So we get the result type out of this thing. We get the type spelling. And we copy and dispose. So"
1029360,1034640," everything is as usual. So everything below is probably going to be removed. So I'm going to put"
1034640,1040240," sort of a line indicating that this code is kind of irrelevant anymore. And we're going to start"
1040240,1046000," iterating through all of these things. Though this is quite important. Look what it says. It says that"
1046000,1055360," it's going to return minus one if you supply a non-function type. Right. But we explicitly checked that"
1055360,1061440," the cursor points at function declaration. So n is never going to return minus one in this specific"
1061440,1068640," situation unless it's a clang bug. Right. In that case, I think we need to check for something like"
1068640,1074960," like this. Right. So assertions are created specifically for this kind of situations,"
1074960,1081440," for situations that should never happen unless there is a bug somewhere in the code that you're calling."
1081440,1086720," Right. So because if you have a cursor of a function declaration, this thing will never"
1086720,1091040," return minus one unless there is a bug somewhere in all of these functions. And in that case,"
1091040,1095040," it's pretty safe to crash. Right. So because that's the situation that should never happen."
1095600,1102560," Right. But the the types of the API kind of imply that it may happen. Right. So asserts are really"
1102560,1109600," good for checking things that cannot be encoded easily in the types of the functions and like"
1109600,1115840," everything like that. Because the things that needs to be checked are actually runtime things. Right."
1115840,1121840," They're more of a runtime things. So essentially what we need to do, we need to get the type of the argument."
1121840,1127360," Right. So we're just going to take the, yeah, so this has to be the type."
1127360,1136720," This is the type and we're just doing it. So, and we have this argument. After that,"
1136720,1143280," we can just get the type spelling. Clang get type spelling."
1144800,1152240," And we copy that string and dispose. Right. So, and after that, we can just add,"
1152240,1157920," I could have just copy pasted this entire thing. Right. Because that's what adds the argument."
1157920,1167840," And in here we can just use the archetype. So this is the archetype. And that's it. So collecting the"
1167840,1174480," children's children is not that important anymore. So we also prepare the function signature."
1174480,1180800," And I think that is basically it. I think that is basically it. So this is actually super cool,"
1180800,1187120," believe it or not. This is actually super cool. So let's try to compile this entire thing. So I'm"
1187120,1193360," going to do Jai Linux and I'm going to do first Jai. So let's go to the compilation errors. This one,"
1193360,1199920," it doesn't number. Oh, okay. So we have like sign-ness mismatch. Can you just like, yeah."
1199920,1208080," So this thing returns unsigned thing, but this one turned to be signed. Oh, this is kind of funny."
1208080,1216080," This is the lipclang quirkiness. This thing returns a signed type, but the thing that accepts thing"
1216080,1223280," returns unsigned one. That's pretty funny. But we know that n is a greater or equal than zero."
1223280,1228880," So that means it's pretty safe to just cast it to, to whatever it wants. Right. So, and that seems to"
1228880,1234800," be working. So now if I try to query this thing one more time, it should work and we shouldn't really"
1234800,1240480," have any warnings. All right. So we don't have any warnings and everything seems to be working,"
1240480,1246960," though there is like an extra, an extra type, which I didn't really expect. This is,"
1246960,1253600," wait a second. This one is weird. What the hell is that? Why there is like an extra comma in here?"
1253600,1264080," Huh. So, uh, let me, let me see. So if I get number templates, so there's this still thing."
1265680,1276000," Yeah. So it may only happen. Oh yeah, of course, uh, because the ranges in Jai are inclusive. They"
1276000,1283040," include both of the ends. And so if you want to do, uh, like, you know, less than n, you have to do minus"
1283040,1289120," one, of course, of course. So that's, that gets me every time. That gets me every time, but it makes"
1289120,1295840," sense, I suppose. It does in fact, uh, make sense. Okay. That's pretty progress. I think that is pretty"
1295840,1301280," progress. There's no warnings and I can actually search within, uh, any sort of headers that I want."
1301280,1308240," Right. So whether it's like leap clang or I may go back to ray leap. Uh, all right. So this is a ray"
1308240,1315200," leap. Where is the ray leap? So here is include, uh, ray leap dot H and I can actually, I'm going to do"
1315200,1322880," ray math, right? So I can do vector two, give me a vector two that also accepts a float. And, uh,"
1322880,1330480," here it is. So this is the functions that I'm interested in. Isn't that a poggers? Isn't that a poggers?"
1330480,1337520," So that's basically an update that I wanted to make on this tool. This tool is getting more and more"
1337520,1344320," useful every single day. It is actually quite scary. Not gonna lie. It is actually quite scary."
1344320,1350320," So we managed to use this tool against leap clang. We literally used leap clang against leap clang."
1350320,1354640," And we finally defeated that dragon. So I'm not afraid of leap clang anymore."
1355360,1366400," I'm not afraid of it. Just come at me. All right. So that's it for today. Thanks everyone who's"
1366400,1371280," watching right now. Really appreciate it. Have a good one. And I see you on the next, uh,"
1371280,1375360," recreational programming session. I love you."
