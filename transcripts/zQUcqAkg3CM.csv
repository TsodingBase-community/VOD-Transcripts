start,end,text
0,10960," All right, it looks like we're live. Hello, everyone, and welcome to another"
10960,18660," Zozin session. How about that? How about that? So let's make a little bit of an announcement"
18660,26840," as a famous champion said. So we're gonna do that on our discord server. Hello, hello,"
26840,33760," everyone. Hello, to the prime. Hello, lazy 008 epic pics by your bird. Hello, hello. So we're"
33760,41060," gonna say red circle live on Twitch. And we're gonna say what we're doing today, we are developing"
41060,46660," a compiler today, but we're developing the compiler in a very special language called Python, right,"
46660,51560," we're developing a compiler in Python. So I'm going to give the link to the channel. So it's"
51560,59820," a twitch. Yeah, it's a twitch.tv/todding. And we're going to ping everyone who wants to"
59820,67400," be pinged. There we go. So we made a little bit of an announcement. All right. Hello, hello,"
67400,73280," everyone. Hello, Hamikovi. Hello, to the prime. I think I already said hello to you. So today,"
73280,79440," we're developing our programming language called port. It's basically like fourth, but in Python,"
79440,83900," you can find the source code of this language in the description if you're watching on YouTube,"
83900,91080," or you can find it in the chat if you're watching live right now. So and today, we're going to"
91080,98200," be solving a very specific problem that I encountered in my language, right, very specific one. And"
98200,103520," if we manage to solve that problem by the end of the stream, I'm going to call this stream as success."
103520,114800," Hello, extra big Chungus. Hello, I zero zero, Ellen, Zebis Naga three. Hello, hello, welcome, welcome, welcome."
114800,122340," So let me show you the specific problem that we're solving at today. Right. So we already started to develop the"
122340,128260," compiler in itself, right? So one of the goals of the of the development was that we're going to implement"
128260,134820," it in Python. And then once the language mature enough, we're going to implement it in itself. And as you can"
134820,140340," see, we have two files in here. The first one is Python dot by the original implementation of port. And the"
140340,147140," second one is port dot port, the implementation written in itself. Right. And it's currently in"
147140,152500," progress. It's not as big as the Python one, as you can see, you can compare the sizes. So we're getting"
152500,158900," closer to actually being able to compile the language with itself. And there's a lot of things in here,"
158900,164020," right? There's all the things in here, as you can see, we generate assembly and whatnot. And one of the"
164020,171460," problems that I have with this language right now is going to be super apparent if I try to compile a"
171460,180500," port port port dot port with port dot pi. Do you notice anything?"
193140,199460," Python is not slow, by the way. So I think it takes like 18 seconds. If I'm not mistaken, let's actually see."
199460,208820," Here as a person says on OMG, my first time watching you live. Yeah, you're watching me live. I can respond"
208820,216980," to your messages. Especially if you subscribe, wink, wink. I'm just joking, you don't have to. All right. So yeah,"
216980,222260," it's it's around 18 seconds, right? You can actually make it a little bit faster by using pipe"
222260,227460," pipe. But it's not going to be that much faster, I think. I don't think it's going to be that much"
227460,234420," faster. Yeah, it's it's actually faster. It's actually like twice as fast, maybe like more than"
234420,242820," twice as fast. But six seconds for such a simple thing is just like it's too much. C compilers can"
242820,250020," compile way more code with within a second within milliseconds. There's something wrong is going on in"
250020,260340," here. Probably I'm using lists instead of deck. Python is not slow. I'm just using the wrong data structure."
260340,265220," That's what's going on in here. Of course, yes, I keep forgetting about that. I'm just using the wrong"
265220,273460," data structure. So my hypothesis, which is actually true, by the way, because I confirmed it, is that the"
273460,280980," type checking process is slow. You can confirm that hypothesis by just taking this entire thing, right?"
280980,286580," And disable the type checking, right? So one of the things that language does, it actually checks"
286580,295140," that you don't put too much in this. Actually, you don't underflow the stack. And you don't mix up some"
295140,300340," of the types because different operations accept different types. And you don't want to mix them up to"
300340,306500," produce like some sort of undefined behavior. So we do some like rudimentary checks to avoid that."
306500,313460," And if you disable these kind of checks, it compiles faster than if you used PyPy, right? You see,"
313460,320740," I'm using CPython. I disabled the type checking and it compiles like within like it compiles way faster"
320740,329380," if you would use PyPy, right? So obviously, the bottleneck in this entire thing is the type checking."
329380,337860," So once we identify that, we need to understand what exactly is wrong with the type checking. So we need"
337860,344820," to understand how the type checking actually works, right? So here's the thing. I already did like a couple"
344820,352660," of streams on how type checking works. And we even implemented like type checking life. So if I go into"
352660,358580," the into the YouTube channel, by the way, if you're watching life, you can find the, you know, this thing"
358580,364180," in here. So here is the YouTube channel. If you're watching on YouTube, obviously, you know where you are."
364980,369620," All right, so there was a couple of streams where we were implementing the type system. So here's the"
369620,377540," episode 15 and episode 16 static type checking and advanced type checking. So I'm gonna actually link"
377540,386420," both of these things in the description. So this is going to be static type checking episode. There we go."
386420,395860," And advanced type checking episode. Right. So advanced one is this one, I'm going to copy paste this entire"
395860,401940," thing in here. All right. And for people who's watching live, I'm going to actually copy these two"
401940,407460," links right now in the chat. So you can put them into your two to watchlist if you want to, of course."
407460,416180," Right. And here's the thing. After the streams, I kind of fundamentally changed the way the type"
416180,422100," checking works in PORTH. And I did it off screen is because I needed that change because the original"
422100,428660," type checking implementation was kind of poopoo. Right. So I fixed it, but I didn't stream the fix"
428660,433940," because I thought because I thought that nobody would care. Apparently, there is a lot of people who"
433940,441060," actively play with the current implementation of PORTH and just experiment with it and just do different"
441060,448420," things. And they do care about how the all these things work. So and I recently received the email"
448420,454420," asking about how exactly that checking works. And I decided that I think I need to explain how it"
454420,463940," currently works. So the way it currently works is that we implement a BFS of the control flow execution."
464500,473860," So what is BFS? It's a graph algorithm. It's a graph algorithm that allows you to sort of like take a"
473860,484340," graph and just send a wave like in that graph. And the way sending that wave is actually one of the"
484340,491700," efficient ways to, for example, compute the shortest path between two points in the graph. And especially if"
491700,496820," you don't have any weights on the edges, right, if you have like weights on the edges, like just a"
496820,500900," simple BFS is not going to cut it, you will need something like the extra algorithm. But that's the"
500900,505700," details. Right. So and usually this is how it looks like, right? As you can see, you send in a wave and"
505700,511940," the wave just traverses through the entire graph. So we're doing something similar with the type checking."
511940,518980," So let me actually put the link to BFS article in here just in case you're interested and you want to read"
518980,526900," about that. Right. So essentially, how type checking fundamentally works, right? How does it work"
526900,534740," fundamentally? You have something like this, you have this simple program, right? So this program pushes 34"
534740,541780," on the stack, then 35 on the stack, then takes these two numbers on the top of the stack, sums them up and"
541780,546980," pushes the result back on the top of the stack, print, prints whatever you have at the top of the stack to"
546980,551540," the standard output and removes that from the stack. It's a very simple program, it just sums up two"
551540,557140," numbers and prints the results. So let's actually save this program. Let's actually do something like"
557140,565220," some let's call it nice. It's a nice program. So forth, there we go. Something weird has happened,"
565220,572740," maybe I have to actually rewrite it. Plus print. And there we go. So we have a nice program. And if you try to"
572740,582980," compile this and I think here is nice. There we go, it was compiled. And if I run this program, it says 69,"
582980,591140," as you can see, right. So it says 69. If I for instance, don't provide one number, right, I don't"
591140,597940," provide 35. And I will try to compile this program, it will not compile because it says not enough arguments for"
597940,606260," the plus operation, right? It is not enough arguments for the plus operation. So and the way it works,"
606260,612260," the type checking essentially performs something that I would personally call meta evaluation, right?"
612260,618500," It's not like an actual evaluation. It's like a meta evaluation. So essentially, it will go through"
618500,625700," all the operations and do them at compile time. But instead of pushing numbers, it will push types on the stack."
625700,634820," So instead of the stack of values, it has a stack of types, right? So and it encounters 34, it pushes"
634820,644500," integer on the stack. So now on the stack, you have integer, then it encounters 35, it pushes integer on"
644500,652420," the stack that in encounters a plus, and it knows that plus accepts two integers and returns an integer. So it"
652420,659460," takes these two types from the stack and pushes integer back. So print doesn't care about the type, it just"
659460,664740," removes that type from the stack. And there we go. At the end of the execution, we have an empty stack,"
664740,670260," we didn't perform any side effects, but we just checked that all of the types add up. And there's one"
670260,674820," of the requirement of our program that at the end of the execution, you don't have to have anything on the"
674820,681780," stack, you have to handle everything. Right? So for instance, if you don't print the value, right,"
681780,686660," your program also is not going compile because you have unhandled data on the stack, right? You see,"
686660,692420," you have one single integer on the stack. So first thing you have to do, like the last thing you have"
692420,697300," to do in your program, you either have to drop it, remove it completely from the stack. In that case,"
697300,702980," the program is kind of useless, or you can print that thing. In that case, it will do something useful."
702980,710100," So this is how our type checking fundamentally works, right? It maintains this like stack of types."
710100,718980," Okay, the thing gets very interesting when you go into the business of conditions in loops, right? How do"
718980,725060," you check conditions, right? So for instance, I want to check that this sum is equal to 69. This is how I"
725060,736420," do that. I'm sorry. I've been programming in Go off screen. So my reflexes actually didn't adjust yet."
736420,745060," So I still have a reflexes that after if I have to press curly braces and stuff like that. So yeah. So if"
745060,752100," it is equal to 69, we have to print something like we have to print nice, right? Let's actually print"
752100,758580," nice. And to be able to print things, we need to include the standard library. Otherwise, we're going"
758580,766420," to print not nice. There we go. So how can you even check something like this? Well, obviously,"
766420,772900," this program will compile and it will run. As you can see, it says nice. It doesn't print the new line"
772900,779060," for some reason. Let's actually put a new line. And if you, for instance, modify the center, I think it"
779060,784020," will say that this thing is not nice, right? Depending on this condition, it just prints two different"
784020,792340," things, right? And for instance, it's quite easy to leave something on the stack, right? So for instance,"
792340,799620," if you go to true and put some extra garbage on the stack, and this condition is true, you will have"
799620,806340," unhandled data on the stack. And if you go here, you won't have unhandled data on the stack. So how can"
806340,811300," we even type check that because we don't know what compile time whether it's true or not? Well, in this"
811300,816820," case, we can know whether it's true or not, because all of the values are known at compile time. But what"
816820,823380," if for instance, we don't write so we have an arc C, which returns how many command line arguments the"
823380,829700," user provided at runtime, and we're comparing it to something, right? So we're comparing it to 69. So"
829700,836820," compiler have no idea what the user is going to provide. So it has no opportunity to check whether"
836820,841700," it is going to be true or not. So it doesn't know. So it's whether going to have unhandled data at the"
841700,848580," end of the execution or it won't, right? How do you possibly check that at compile time, right? But"
848580,854500," what's interesting is that it will check that, right? It will tell you that you haven't handled data at"
854500,858580," the end of the stack. And that data was introduced in here, right? But what's interesting is that"
858580,866980," if you try to drop that data, you have you creating like a very interesting situation, right? What if the"
866980,874260," execution went into else, in that case, drop will not have any operation, right? There's uncertainty"
874260,880500," here, drop will be correct only if this thing is true, and incorrect, if it's false, and this thing"
880500,886660," goes into this execution, does it make any sense? Right? So it's kind of uncertain, how do you check for"
886660,891460," this kind of stuff. But what's interesting is that our compiler will check for that, right? So it will say"
891460,898020," that not enough arguments for the drop. So for this program to compile, both of the branches"
898020,903140," have to provide some value, both of them have to provide some value, and only then this will compile,"
903140,909700," because in both of the branches, drop has something to drop, and drop has something to print, right?"
909700,915460," For instance, here, we're going to have something like this. Unfortunately, I cannot, it's kind of difficult"
915460,923380," to provide 69 arguments for the program to actually confirm. Let's actually provide like a check for"
923380,928740," two of them, right? In that case, I only have to provide like one thing. ""Foo"", and as you can see,"
928740,934100," it says ""nice"", and if I don't provide ""Foo"", it says ""not nice"" for 20. So the question is, how does it"
934100,941860," check this really complicated, you know, uncertain situations, right? And the shed goes even more"
941860,947380," complicated when you have a chain things, right? Because you can chain ifs, you can have another"
947380,953780," condition in here, like this, and you can have another condition in another condition, and you need to check"
953780,958980," all of the branches, and the shed goes crazy. Like, how do you check all these things? What about while"
959700,964500," while loops, right? What about while loops with ifs and stuff like that? You just like have a shed ton of"
964500,973380," branching? Well, here's the answer. This is where BFFs comes in. So essentially, every time the meta evaluator"
973380,985860," encounters if, it splits the stack in two, right? So essentially, it splits the stack in two, you have two"
985860,994900," copies of the stack, and then it continues meta evaluation in true and false branch simultaneously."
994900,1004980," Simultaneously. So in if any of the branches, it finds a mistake, or some like inconsistency, it basically"
1004980,1012340," breaks the the compilation. So this is how it works. Every time it encounters ifs, it splits execution and"
1012340,1017620," continues like checking things. And in the code itself, right, in the code itself,"
1017620,1025860," port.py. So we have a function called type check program, type check program. And then here we have"
1025860,1031540," a list of contexts. And this is by the way, the reason why the program is so slow, because I'm using list of"
1031540,1038420," contexts instead of the deck of the context. If I used deck of the contents, this program, this entire"
1038420,1046020," program would have been faster than if it was written in C. Right. So that's the actual bottleneck in here,"
1046020,1051300," right? You see that, that's the real bottleneck. Anyway, I digress. So the context is basically the"
1051300,1057220," context of meta evaluation. And within the context of meta evaluation, we have the current data stack,"
1057220,1063140," right, the stack of types, the return stack, and return stack is very important for handling procedures,"
1063140,1069380," right. Because when you go inside of the procedure, and then you reach the end of the procedure, you have"
1069380,1075140," to return back to where you actually called it. So that's why we maintain the return stack in here."
1075140,1081140," And IP stands for instruction pointer. It's not internet protocol, it's instruction pointer,"
1081140,1086740," and points at the current instruction that you currently execute. So as you can see, we have a list of contexts,"
1087300,1093300," right. And at the beginning, we have only one context, the with the empty stack with the IP equal"
1093300,1098740," to zero, because this is where the program starts to execute in with the return stack empty, because"
1098740,1104340," you don't have to return anywhere. Right? And if you encounter if, right, if you encounter if"
1104340,1113140," what do we do, we create a copy of the context, you see, we take the stack of the current context,"
1113140,1118980," we copy it, and we have returned stack of the context, and we copy it, and we create another"
1118980,1126340," context, and we append it to the list of contexts. And then we continue execution, right. And at the"
1126340,1133140," beginning of this huge loop, at the beginning of this huge loop, we take the context at the top,"
1133140,1138020," we take the context of the top, we check that it didn't finish executing, and we continue working in it."
1138020,1143540," If it finished executing, we're popping out the context out of the list, and continue working on"
1143540,1150260," the next context. As you can see, we're implementing a BFS, right. So we have a wave of execution contexts"
1150260,1157140," that check all of the possible execution path, all of the possible execution paths. Right, so that's how it"
1157140,1165300," works. And this is kind of fundamentally different from how we initially implemented it in on the streams."
1165300,1169380," I just didn't want to explain that because I thought that nobody would give a shit. But apparently people"
1169380,1175460," do give a shit. And I actually really appreciate that. I was so fluttered that I received an email"
1175460,1180900," actually asking how the fuck this shit works, because I didn't think that no anybody would even"
1180900,1185940," fucking care. Thank you so much. Right, whoever sent that email. Thank you. I really,"
1185940,1191780," really fucking appreciate that. So people actually care."
1191780,1204740," All right. So and there's an interesting situation with the loops. Loops are kind of complicated to check."
1204740,1211220," Right. Because essentially, if you're just basically splitting the execution in two all the time,"
1212180,1216660," the type checking of the loop is going to go infinite. Right. So let's actually write a simple"
1216660,1228500," loop. Something like zero, while dupe is less than 10. Good fucking. Right. So"
1228500,1235780," and we are going to do that and then increment this entire thing. There we go."
1236580,1242260," So and I'm going to try to bring it and handle data on the stack yet because at the end of the stack,"
1242260,1247140," you just have this counter that you need to drop at the end. As you can see, we have a program that"
1247140,1255620," prints the stuff from zero to 10. Right. That's pretty cool. So and do in this particular context acts"
1255620,1262740," like if because what does it do? It looks at the top of the stack searches for a boolean. And if the"
1262740,1269620," boolean is true, it falls through and executes the body then reaches the end and goes back to the while."
1269620,1278980," If it is false, it jumps over the end and continues the execution. But here's an interesting thing. If we"
1278980,1284980," implement type check as the control flow BFS, that means the BFS is going to actually go in the loops"
1284980,1292180," forever. Right. So it's going to go in the loop forever and keep splitting the context in two until"
1292180,1298740," it runs out of memory. So you literally if you want to type check the loop with that approach, you literally"
1298740,1305140," have to go in the loop forever. And there's no way to break out of that. So the way I broke out of that"
1305140,1314980," is the following. When I encounter do, I mark that I already visited that do. I already visited that do."
1314980,1324660," And not only that, I also make a copy of the current stack and I save it and say that"
1324660,1331380," at that point of the execution, the stack was like this. Then I continue execution and I encounter do and"
1331380,1339940," I check. Did I visit that do before? And if I did, what was its stack? Okay, I take what was its stack"
1339940,1346260," and I take the current state of the stack and I compare them. And here I enforce a very interesting"
1346260,1353540," rule. I say that the loop should not modify the state of the stack. It should not modify the amount"
1353540,1359460," of the elements on the stack and the types that are on the stack. So basically, the loop can go as,"
1359460,1364500," you know, as much as it wants, but it should basically always go back to its original state"
1364500,1371300," when it reaches do. And once we encounter that, we just basically stop this context and continue"
1371300,1377780," executing the the false branch of the, you know, of the BFS. And that way we can break out of the loop."
1377780,1383940," Right. So this is basically how it works. And this is how we check for the for the loops. For instance,"
1383940,1390180," if you just push some garbage on the stack in the loop, it will not compile. Right. So as you can see,"
1390180,1395780," it will tell you a precise loops are not allowed to alter types and amount of elements on the stack."
1395780,1401460," So expected elements is this, but the actual elements were these, you have an extra integer in here. So you"
1401460,1406420," have to remove that integer. The error messages are kind of crappy, but we're going to fix them a little"
1406420,1416020," bit later. So this is basically how the type checking currently works. All right. So, but there is one"
1416020,1425700," problem with the procedures, right? How do you type check procedures? So you see this type checking dates"
1425700,1431700," back to the times when instead of procedures, we had macros. Right. So let's take a look at"
1431700,1436580," ports dot ports. We have a lot of procedures in here and we have a lot of big procedures."
1436580,1442340," Right. So let's actually find a relatively big procedure, which is like, you know, not big and"
1442340,1449540," not small. For example, CMD code. This procedure takes the list of the arguments and execute it as the shell"
1449540,1454980," command. Yes, this is what you can do in our language. You can take a sequence of arguments and execute"
1454980,1463940," it as a shell command. You can do that in port. And port generates native static executables that don't"
1463940,1468980," link with anything. They don't link with C. As a matter of fact, we don't even use a C library. Right."
1468980,1478020," So, and you can do that in this language. Anyway, so, and before this entire thing was a macro, right?"
1478020,1484180," We don't have a macro anymore, but it was a macro. And what macro means? Macro means that if you use this"
1484260,1491300," procedure anywhere, it will expand into its body. It will basically copy paste its body into here."
1491300,1498900," So that way, if you type checking, you basically go, the execution goes inside of this thing every time"
1498900,1505460," you call it. So to keep things as they were to maintain backward compatibility, I implemented the"
1505460,1514900," type checking in the procedure. So the type checker encounters the procedure. It literally goes and"
1514900,1523140," executes the body of the procedure continuing maintaining the stack. Right. And it does that every time you call"
1523140,1531700," the procedure. So every time you call a procedure, this entire thing goes inside of the procedure and checks"
1531700,1537460," everything. But here's an interesting thing. It needs to do that because at different points"
1537460,1544020," of the procedure call, at different points of the procedure call, you may have different states of the"
1544020,1552100," stack. You may have different states of the stack. It's not like you can check procedure once and just"
1552100,1557460," forget about it. No, no, no, no, no, no, no. At every state, you have different states of the stack. And"
1557460,1564820," essentially, every time you encounter a call, you have to go inside of the procedure and check if it works for"
1564820,1573860," this state of the stack. You have to do that. So essentially, we accidentally implemented type inference."
1573860,1582100," So that's what we did we in like accidentally implemented type inference. And because it has to go"
1582100,1588260," into like these procedures over and over again, and there is a lot of big procedures. You can imagine"
1588260,1594660," why the compilation of such a small program like 1000 lines 1000 lines, by the way, is a small"
1594660,1599940," program for all of UCS students out there who hasn't graduated and never worked in the Java"
1599940,1608820," interface. I'm telling you 1000 lines of code is a very tiny program. It's a micro program. It's a very,"
1608820,1614740," very small program. I'm telling you, trust me, when you graduate from UCS uni, you will understand what"
1614740,1624340," I'm talking about. So yeah, and you can imagine why compiling such a tiny program takes 18 seconds."
1624340,1634420," It does, in fact, takes 18 seconds. So one of the possible solutions that I see for this problem is to"
1634420,1642180," actually cache the inference of the procedures, right? So essentially, if we go into the procedure once,"
1642180,1648820," and we sort of figure out, we sort of figure out what are the types, what are the input types of"
1648820,1655300," the procedure, and what are the output types of the procedure, we remember them. And on the next call, we just"
1655300,1663140," check does the stack have the correct input types, and then we put the output types on the stack, right?"
1663140,1671220," This is one way to do that. But it gets complicated when we go into the business of recursion."
1673220,1679300," Oh, and by the way, I forgot to mention, with our current approach, we can't type check recursion."
1679300,1686500," You can have recursion, but you can't type check it. Because I still haven't figured out how to stop"
1686500,1691460," the type checking of recursion. Stopping type checking over loop is relatively simple, right? You just"
1691460,1696980," encounter do again, and that's it. But what if you have recursion that is not looping, but actually"
1696980,1705220," branching? How do you tap check that? Well, I'm pretty sure, like Haskell somehow figured that out,"
1705220,1712260," right? So because in Haskell, you can basically infer anything, even recursive, recursive things. But to be"
1712260,1718260," fair, I just want to implement a dumb self hosted language. And somehow, all of a sudden, I'm getting"
1718260,1725140," into business of like, you know, scientific research papers of how to infer types in Haskell style,"
1725140,1731220," or like, yeah, Hindley, Milner, Milner, Hindley Milner. Yeah. So I don't want to implement the"
1731220,1737460," Hindley Milner in like for my language at least right now. So it's kind of a no go. We can actually"
1737460,1743460," take a look at how our language reacts to recursion, just to like, you know, demonstrate what exactly I'm"
1743460,1752020," talking about. Right. So let's implement Fibonacci recursively. So we're gonna have a procedure. So here's"
1752020,1759060," a Fibonacci. And this entire thing is going to accept n, right, and it will return the nth Fibonacci"
1759060,1765460," number, right, it will return the nth Fibonacci number. So essentially, I'm going to duplicate n and"
1765460,1773140," I'm going to check if it is greater than one, right, if it's greater than one, that means we need to compute,"
1773700,1781460," you know, the n minus one and n minus two Fibonacci number and sum them up. If it's less or equal than"
1781460,1787300," one, that means the n is the nth Fibonacci number and we can straight up like fall through and return"
1787300,1796660," whatever the user provided to us. Right. So and what we're going to do, we're going to duplicate n,"
1797220,1805380," subtract one and call Fibonacci. And here we have n minus one Fibonacci number. Then I do,"
1805380,1813140," I suppose, over, right, because I need to bring n in here, here, maybe even not over,"
1813140,1820340," but basically swap just to bring n somewhere here, subtract two and call Fibonacci yet again."
1820340,1827380," So here, I'm going to have the Fibonacci n minus two. After that, I'm going to sum that up. And there"
1827380,1835380," we go, I have this entire thing. So such a simple function is not type checkable. It is not type"
1835380,1842580," checkable by our type checking process. So for instance, if I do something like, what's interesting"
1842580,1849060," is that I think if I do zero Fib, it is type checkable, because type checking, well, yeah,"
1849060,1854100," type checking is going to go inside of this entire thing. So let's actually do a loop"
1854100,1864740," dupe less than two. And then I'm going to do dupe Fib print one plus end and drop this entire thing."
1864740,1870980," And we're going to drop this entire thing. And I'm going to try to run the Fib. Right. So let's see."
1870980,1877940," There we go. And what's funny is that I even check for this kind of stuff type checking call limit"
1877940,1883380," exceeded I introduced type checking call limit. Are you trying to do recursion? We don't support"
1883380,1889860," type checking recursion properly yet consider using unsafe flag for now. Right. So our compiler tries"
1889860,1895140," to actually look, you know, catch this situation, right? Because the compiler knows what it's capable"
1895140,1901940," and not capable of doing and suggest the user alternatives. Right? How about that? So and in here,"
1901940,1906500," we're going to do unsafe. And in that case, it works. As you can see, you can generate sequence"
1906500,1913380," of Fibonacci numbers recursively. Right. So it can do that. Our language can do this kind of recursion,"
1913380,1920260," it just cannot type check it. Right. And if I'm going to start doing like a type inference and doing this"
1920260,1924900," kind of stuff is just like, I don't want to do that. Because eventually, I'll have to implement all of that in"
1924900,1931140," course. Right. Right. So the more I complicate the stuff, the more I have to reimplement in a pretty"
1931140,1941220," crappy language. So having said all that, I think I thought for quite some time about this problem."
1941220,1947140," Right. And I think the most appropriate solution here would be to finally introduce"
1948420,1957380," the type signatures of the procedures. That's right. I think the time has come. Somehow, I don't know how"
1957380,1962740," yet syntactically, but we're not going to go into the discussion of the syntax because otherwise chat"
1962740,1969060," won't shut up about the syntax because syntax is a bike shading of programming languages. Everyone has"
1969060,1974180," an opinion about the syntax, but nobody wants to think about actually difficult problems. So I'm not"
1974180,1979700," going to even discuss the syntax. Syntax is going to be the way it is going to be. The bike shed is"
1979700,1986580," going to be red. I'm really sorry about that. So yeah, so somehow we need to provide the input"
1986580,1995460," arguments. Right. So Fibonacci accepts the integer and it will return an integer. Right. And we want our type"
1995460,2001460," checker. We want our type checker to actually get that information without going inside of the procedure"
2001460,2009860," and just use that information to type check every time you call that procedure. Right. So, and that way,"
2009860,2016340," we never actually have to like, you know, do a lot of complicated stuff when we don't have to type check"
2016340,2023860," each individual call of the procedure. Right. We don't have to do that. So, and syntactically, I was"
2023860,2029380," thinking, I think I'm going to implement it pretty close to fourth. Right. Fourth doesn't have any types,"
2029380,2037620," types, by the way. Fourth is untyped language. Right. But there is this sort of convention in"
2037620,2045300," force to sort of like annotate in the comments, what are the input of the word? And what is the output"
2045300,2052020," of the word? Right. So fourth, I don't know, stack notation. I don't quite remember how it's called. Do we"
2052020,2058420," have any like force developers in the chat stack words?"
2060260,2066260," Uh, yeah, there we go. So here's the notation really. So, uh, we've got, uh, I suppose, a donation."
2068500,2078980," Type it for, yes. Uh, MJ, EC 116, then 80, 10 and 69, uh, $10, 69 cents saying typed forth. Thank you."
2078980,2084180," Thank you so much for the generous donation. And yeah, we're going to have type. It's already typed."
2084180,2089620," Actually it's, it's already typed. It's just like, we have no way to provide type annotations. So this is"
2089620,2098020," the, um, convention that force developers use, right? So here is the input, um, of the, uh, of the word"
2098020,2104340," rotate. And here is the output, right? They usually use double dash, but they suppose double dash was"
2104340,2110580," rendered by, uh, Google or maybe browser, but by somebody, but whatever software renders this thing"
2110580,2115780," as like a long dash, which as far as I know, not correct, right? The convention is that you use double dash."
2116420,2121540," So this is the top of the stack, the current state of the stack, and this is the output of the stack."
2121540,2125620," And we're going to use something similar. I was thinking, how can we implement that?"
2125620,2130740," Uh, so essentially we can implement it like so. So, so here you're going to have input, uh, types,"
2130740,2137460," right? So you provide the name of the procedure, then you provide the input parameters. Then you separate"
2137460,2143700," input parameters with dash dash, and here you provide the output parameters, and then you end the output"
2143700,2151220," parameters with the keyword in, right? So we have procedure name input parameters dash dash output"
2151220,2160340," parameters in, and then you have this entire thing, right? So the reason why I actually decided on this"
2160340,2166420," particular syntax is because when you're going to have a lot of input and output parameters,"
2166420,2172260," right? So you're starting to have a lot of things in here. Uh, it would be relatively easy to just take this"
2172260,2180660," thing, put it on the next line, right? Then separate the output parameters like this and put in, in here."
2180660,2186820," So basically you have some sort of like annotation in here. So here's the procedure. It takes this stuff"
2186820,2194980," from the stack. It returns this stack from the stack and here comes the body, right? So, uh, so this is how"
2194980,2199460," syntactically we're going to, uh, we're going to, uh, do that, right? And it's not going to be discussed."
2199460,2203620," It's going to be the way it's going to be. The bike shed is going to be red. I'm really sorry about that."
2204580,2218980," Uh, so, so does anyone have any questions so far?"
2218980,2235620," There is very bike shed. Yeah. So, and what kind of types are we going to have? Uh, so right now,"
2237380,2247620," OCaml, uh, gifted, uh, a tier one sub to Porth. Wait, what? So there is a user called Porth, uh, on Twitch."
2247620,2255220," Thank you so much for, uh, for gifting tier one sub to Porth. And Porth, finally, welcome to our epic,"
2255780,2263940," um, Porth club. I don't know who they are, but, uh, but apparently there is a user on Twitch called"
2263940,2271380," Porth. Uh, Porth is like a whale city as far as I know, right? So if you Google up all this Porth. I"
2271380,2279780," didn't know that Porth is, uh, like a city in, in UK, in Wales. Um, so apparently it is. Uh, I hope they"
2279780,2286180," don't mind that I'm, I'm using their like city as the, as the name of my language. Uh, it even is called"
2286180,2296420," why Porth. Yeah. That's a good question. Why Porth? All right. So, um, so right now our type system"
2296420,2302180," consists of three main types. The first step we have is an integer, basically 64 bit integer,"
2302180,2309620," the pointer, uh, the pointer in the memory, uh, and the Boolean, right? So these are the types"
2309780,2314340," that we have, and this is the types that we're going to use throughout the entire type checking."
2314340,2319620," So in the future, we're going to extend the amount of times, but that's basic, uh, you know, fundamental"
2319620,2326180," types we have, right? So, and, uh, for the Fibonacci, right? For the Fibonacci, Fibonacci accepts a single"
2326180,2333220," integer and returns a single integer, right? So this is how the type signature is going to look like."
2334100,2341540," Um, so I'm thinking that for functions that don't return anything and accept only accept things,"
2341540,2347060," we can make this dash dash thingy kind of like, uh, optional, right? Because if you have a function"
2347060,2352180," that only consumes, uh, things like a couple of integers and don't return anything, this is how"
2352180,2356980," it's going to look like, which is kind of dumb. So we might as well make it like optional because it's"
2356980,2362980," quite obvious. It's not ambiguous that, uh, we're done with the return, uh, with the return parameters when"
2362980,2368260," you encounter in, so we have full int int, and this function just accepts two integers, right? So it"
2368260,2374020," just sums them up and prints them. Uh, right. So you don't have to do anything. And maybe if you have"
2374020,2378980," a procedure that doesn't accept any arguments because of that, you can just write it like this. So it's"
2378980,2384100," going to be procedure foo in, and there we go. So we have procedure that doesn't accept anything. This"
2384100,2392180," is how it's going to look like, right? So yeah, looks reasonable to me. And, uh, let's go ahead and"
2392180,2402500," implement that. Let's go ahead and implement that. Right. Does anyone have any questions?"
2402500,2411300," What about no inputs, but some outputs? In that case, you just do that, right? So you have a function"
2411300,2417620," that doesn't accept anything and only print something while you indicate that with just dash dash, um, pretty"
2417620,2428660," step forward. I think the parameters should have optional names because they show what the procedures"
2428660,2437940," does. Uh, we'll think about that. Uh, so yeah, I don't try to think about the details unless I actually go"
2437940,2452020," into the details. What about as instead of in or is instead of in, uh, the bike shed is going to be"
2452020,2456900," red. So that's the answer to your question. Uh, the Lazarie does anyone have any other questions?"
2456900,2463860," The bike shed is red and it's not discussable, right? We're not. It's not new. New shade. New good. Yeah."
2464740,2466660," The color of the bike shed is red. That's it."
2466660,2474420," Type in the inference in the future. Maybe in the far, far, far future when I retire,"
2474420,2479380," I'm going to be 15. I'll go back to this project and I'll think, Hmm,"
2480580,2485380," you know what? I think I need to implement type inference for this thing. Yeah, sure. But later."
2485380,2489380," Um, yeah, what's up?"
2489380,2496340," What the fuck? I don't even have a bike. I don't even know how to ride a bike. Not everybody knows"
2496340,2504900," about that, but I don't know how to ride a bike. Sorry. The bike shed is covered in rust. Exactly."
2504900,2511780," It's a rusty bike shed. Wait, you too? Yes. Therefore, you also don't know how to ride a bike. Okay. So there we go."
2511780,2521540," Don't feel ashamed about that. Um, all right. So let's go ahead and implement this shite."
2521540,2530660," Um, don't worry about that. So there's a lot of people who don't know how to ride a bike."
2531860,2538820," So don't even stress about that. It's not that much of an important skill in 2021,"
2538820,2542740," especially with the self-driving cars and shite. I mean, come on. You don't even need to"
2542740,2547140," learn how to drive a car these days, right? Because it's going to be all automated anyway."
2547140,2555620," There's a lot of other things too, right? Gotcha, guys. Yes. You're goddamn right. You're goddamn right."
2556740,2563060," All right. So, uh, what we're going to do, we need to introduce, I suppose, some syntax highlighting,"
2563060,2572900," correct? So, uh, proc, uh, signature, uh, there we go. And I'm going to go into the editor and in the editor,"
2572900,2576020," right? We're going to have some stuff."
2577700,2585940," Hmm. I don't remember all of that. Also, at some point, we're going to be implementing LSP server for"
2585940,2592660," Porth. Uh, once Porth is mature enough and is completely rewritten in itself. And I have a"
2592660,2600420," couple of cool ideas for outer completion. In fact, the syntax of Porth makes it super easy to implement"
2600420,2605300," out of the completion. It's just, it's fucking insane. And say how insane, how like concatenative"
2605300,2611380," languages makes everything easier, right? Seriously, you want to out to complete something."
2611380,2617300," Okay. So you are at a particular, uh, state of a program at a particular point of the program,"
2617300,2622340," right? And you want to out to complete something you press like space or maybe out to completion is"
2622340,2627780," automatically triggered. So the only thing you have to do, you have to interpret the program"
2627780,2633060," up until this point, not even interpret, but meta-evaluate. And then you're going to have"
2633060,2638740," the stack of the types. You go through all of the available functions and you see what functions can"
2638740,2643860," actually consume that stack. And you compose a list of that function and suggest to the user"
2643860,2651060," what functions to put in here. It's insanely simple, right? People say that all P with its little dot"
2651060,2662900," has nothing on this thing. Like this thing makes it way simpler. It's just like way fucking simpler."
2662900,2670740," It's insane. Um, so yeah, and we're actually going to do that. I'm going to actually implement LSP that"
2670740,2677860," does support out the completion like that. Um, there we go. Um, anyways,"
2677860,2687380," so, um, I think I'm not going to highlight dash dash, even though the dash dash is going to be one of the"
2687380,2694820," keywords, but I'm going to highlight in, right. I'm definitely going to highlight in, uh, and, uh,"
2694820,2700580," we also need to do that for Vim, right? So let's not forget about the, uh, poor Vim users."
2700580,2706500," To be fair, the only reason why I support Vim is because I also like from time to time use Vim for"
2706500,2710580," different things, right? And I want to have a highlighting for parts in Vim too, just in case"
2710580,2718580," I'm using it. Um, all right. So, and let me actually copy paste this thing, uh, to my local"
2718580,2724020," folder and I'm going to put this thing in here. There we go. So I probably want to restart Emacs."
2724820,2728500," Oh boy. Oh boy. Where is my soy?"
2728500,2737140," Okay. So I'm trying to go to this thing and let's restart the Emacs."
2737140,2748660," Um, and if I go to ports dot ports and I try to use in, it does in fact highlight in. So let me think,"
2748660,2753060," I need, I think we need to come up with some sort of an example. I think we'll already have an example."
2753060,2758900," Uh, we had, right. So there was a Fibonacci. Um, let's re-implement Fibonacci yet again,"
2758900,2763780," because I think it's a pretty good example of like type checking and whatnot, or maybe"
2763780,2771700," let's do something like this, uh, print, uh, sum, uh, which accepts two integers and doesn't return"
2771700,2777940," anything. Uh, let's actually do again, print some, um, in,"
2777940,2786100," and in here, we're going to sum up these two integers, then duplicate it and then print it."
2786100,2791780," And this entire thing will print the number and also simultaneously return it. Right. So then we're"
2791780,2800820," going to do 3435 print some and then drop, right? There we go. So right now, if I try to, uh, compile"
2800820,2806500," this program, right? If I try to compile this nice, very nice program, it is not going to compile because"
2806500,2815220," it doesn't know a word, int you see. So because it interprets it like as body. So it doesn't know that"
2815220,2820500," this is a part of a signature, right? It doesn't know it's a part of the signature. So it thinks that,"
2820500,2825620," oh yeah, this is like a word that you're trying to use. Right. So, and there's no such word. So it kind"
2825620,2831220," of fails. Uh, okay. So I think we're going to start with introducing a couple of keywords to our"
2831220,2838580," language. Uh, so we have a list of keywords that we want to introduce where, where are keywords. So we"
2838580,2848660," have assert and, uh, we're going to introduce, I suppose, in, right. And dash dash is also going to be"
2848660,2854660," a special keyword, but the question is how we're going to call it. Uh, are we going to call it dash dash"
2855620,2863940," dash dash dash? I mean, why not? Sounds like a good name to me. Uh, so, and, uh, let's try to compile"
2863940,2869380," this into anything and see in what places it will fail. So it fails in here, prompting us to actually"
2869380,2879140," add the name for these things. And, uh, here we're going to have in, uh, right. Oh, the bay,"
2879140,2881540," the back shader bike shaders already rolled in."
2881540,2896420," I think I know how I'm going to call this thing actually, um, uh, bike shader. There we go. So"
2896420,2907300," this specific separator is officially called the bike shader. Yes. This is the official name for that"
2907300,2914580," small little separator of input and output parameters bike shader. And this is how we're going to refer to"
2914580,2923620," this thing throughout the documentation. Of course, this is a bike shader. Uh, all right. The bike shader"
2923620,2935300," separator. Um, so, uh, yeah, there we go. So where is the, this stuff, the bike shader. Okay. Um,"
2937300,2945700," um, bike shader. All right. So, and I forgot to actually update. So we added two keywords. So that"
2945700,2952900," means it's going to be a 15, right? So this is 15 words. So what do we have in here? So here, uh, this"
2952900,2960580," is the parsing process. Yeah. This is the parsing process. And interestingly enough, if you're just"
2960580,2968820," encountering, um, the bike shader and in by themselves, it is not, uh, a correct thing,"
2968820,2976180," right? So it's unexpected in there. The same way, um, things like offset and reset are not expected,"
2976180,2982500," uh, in non-constant context, right? So if you encounter offset and reset in a non-constant context,"
2982500,2991940," it's going to throw, uh, an exception and an error. So if we encounter, um, keyword in or a keyword,"
2991940,2997620," uh, bike shader, bike shader, we're going to throw a compilation error, right? So it's"
2997620,3003140," compound compiler error, uh, with the expansion stack. Well, this is kind of interesting. So"
3003140,3009700," the expansion stack is a terminology from the times when we had macros, right? Because each individual"
3009700,3018500," talker, a token had, uh, the expansion stack, basically the path, uh, that led to this token,"
3018500,3024420," because it's going to be a sequence of macro expansions. And since I removed the macros,"
3024420,3031220," the terminology actually still is in the code in some form or another. So this thing doesn't really"
3031220,3036900," do the expansion stack logging. Uh, but I was just too lazy to rename this entire thing. So whatever,"
3036900,3048740," at some point, I'm going to just rename it, uh, to, to, to, to, to, to, to include still expense. Nah,"
3048740,3057700," it doesn't, it doesn't expand anymore. Actually. Um, when you encounter the include, when you encounter"
3057700,3064740," the include, I just call parse program from file. Again, I don't expand it. I just call parsing"
3064740,3076740," recursively. So yeah. Um, so I actually changed that. And while I do that recursively, I, uh, also see how"
3076740,3082580," many times we include it. And if it's over the inclusion limit, I throw, uh, including it is"
3082580,3093700," exceeded and, you know, so on and so forth. Ah, all right. So, so we're going to say in here, um, keyword"
3097140,3107780," token text can be only used, um, let's actually say something like this, um, unexpected, uh, keyword"
3107780,3115940," like this. And, uh, then we're going to exit with, um, non-zero exit code. Uh, so, and in here, I would"
3115940,3122900," say that I successfully handled this thing, uh, unknown word int. Okay. This one is rather interesting."
3122900,3130420," So now we have to update the way we parse the procedures, right? So after we parse the name of"
3130420,3139540," the procedure, we have to, you know, parse the, uh, the arguments, right? We need to parse the arguments."
3139540,3146340," Also, I think I need to go and extend, um, the, um,"
3147860,3153540," the definition of the class procedures. So each individual procedure is stored in a data class called"
3153540,3161060," proc. It has an address where the procedure starts in intermediate representation. Location. Location"
3161060,3168820," is the location of this procedure in the source code file, uh, row and column. This is needed for, um,"
3168820,3174660," reporting purposes. Um, what are the local memories of the procedures? Because inside of the procedure,"
3174660,3180420," you can allocate local memory, right? So memory, let me see. Yeah, there we go. So if you have a"
3180420,3186740," procedure, you can actually allocate, uh, a little bit of memory on the return stack and just use it,"
3186740,3192100," uh, for like intermediate location and whatnot, which is rather convenient and how much of that memory you"
3192100,3196580," already allocated. So this is the definition of the procedure. So this is everything you need to know"
3196580,3203540," about procedure to compile it. And I think we need to introduce the input parameters and the output"
3203540,3210180," parameters, right? So, uh, we're going to have ints. Uh, so this is the input parameter and I suppose it's"
3210180,3215780," going to be a list of the data types. We have a special class, uh, actually enumeration thing,"
3215780,3221620," but it's also a class in Python anyway. Class data type. Yeah, there we go. So here are all of the, uh,"
3221620,3229220," supported types, right? So we have integer boolean and pointer. Uh, there we go. So data types. So these"
3229220,3236420," are inputs, and then maybe we're going to have outs, uh, list of not time, list of data type."
3236420,3243620," There we go. So, uh, maybe we're gonna actually have it as a signature."
3244820,3254420," So maybe we're gonna have like a separate class, uh, signature, uh, data class. Uh, and, uh, I'm gonna"
3254420,3260660," just put it like here. So it's more of a, like a procedure signature, but you know what, whatever"
3260660,3267620," we develop for type checking the procedures can be then used for type checking the intrinsics. So right"
3267620,3274340," now we have a pretty huge function, uh, that I was hesitating to compress, uh, that type checks the"
3274340,3278260," intrinsics. As you can see, there's a lot of copy pasting here. And the reason why there's a lot of"
3278260,3284100," copy pasting here, because I was not sure how exactly I want to structure it. And if I start"
3284100,3289780," structuring it and enforcing some specific way of doing things, I was afraid that I won't be able"
3289780,3295780," to extend that system. Right now I can see that whatever I'm developing for the procedures can be"
3295780,3302980," reused for the intrinsics as well. So I need to develop that with that thing in mind."
3303860,3309380," So it's more of a, like, it's not really signature. It's more of a, like, um, contract."
3309380,3317620," I think it's a pretty good name for this thing. Yeah. It's basically a word contract,"
3317620,3323380," right? So it expects these kinds of things on the stack and it outputs these kinds of things"
3323380,3329620," on the stack. And this kind of contract could be, uh, described by a procedure, or it could be baked in,"
3329620,3336740," into, uh, intrinsics or some of the keywords, not only intrinsics, but keywords can also have contracts."
3336740,3343700," Like if, uh, has a contract that it accepts a boolean, but doesn't return anything on the stack."
3343700,3349220," So these sort of things like what you can accept and what you can return are not particularly signatures."
3349220,3355220," They're more of like a contracts, right? And these contracts are applicable for different entities"
3355220,3362100," within the language. Right. So let's actually call them not a signature, but a contract, right? So,"
3362100,3368180," and that way we'll be able to reuse that mechanism for other things, not only procedures for intrinsics,"
3368180,3371540," for keywords, and so on and so forth. Um,"
3371540,3384740," so, uh, all right. So let me see, this is going to be contract. So this is the inputs. This is the output"
3384740,3388820," parameters. And in here we're going to have a contract."
3388820,3399620," So, all right. If I try to compile this entire thing, uh, so when we're creating a procedure,"
3399620,3405300," when we're creating a procedure, we missing the contract. And that's precisely what I expected to see."
3405300,3407140," Okay. That's actually pretty POG."
3407140,3411460," Isn't that POG? I think it's pretty POG."
3411460,3417140," So here we're trying to parse the procedures. So we put a skip procedure onto, into the intermediate"
3417140,3424100," representation. Then we put the, uh, prepare procedure. Uh, then we're looking for the name"
3424100,3431460," of the procedure, right? So we extracting the name, uh, and I suppose, okay. So we check that the name"
3431460,3439860," is a word, and then we extract, uh, this stuff and this stuff, we check that we're not redefining the,"
3439860,3445700," uh, the word. And I suppose after that, we need to have something like parse, uh,"
3445700,3453940," proc contract, right? So in here, we're going to accept tokens, right? So we're parsing the proc"
3453940,3459300," contract. It will accept the tokens. It will consume everything in here, and it will return the proc"
3459300,3466180," contract. There we go. Which we then can use in the, uh, procedure definition, right? So this is"
3466180,3473140," going to be contract equal proc, uh, contract. There we go. So, and here, as you can see,"
3473140,3480500," parse contract is not implemented. So we need to define such function. Uh, so this is going to be"
3480500,3485860," definition. This is a list of the tokens, uh, tokens. And this entire thing is going to"
3485860,3492260," return. Is that how we do that? I forgot. Yeah. So this is how we do that. Uh, we have to return,"
3493060,3498180," uh, deal. Uh, subscribe with Twitch. Fine. Thank you. Thank you so much for, uh, Twitch prime"
3498180,3507460," subscription and welcome to our epic port club. Mm. Mm. Uh, all right. Mm."
3507460,3517220," Uh, Killian de subscribed with, uh, another Twitch prime. Thank you. Thank you so much for Twitch prime."
3517220,3523860," Uh, so many new people in here today. Uh, welcome. Welcome to our epic force club. All right. So here's"
3523860,3534100," the contract and, uh, listen to, I think is not implemented yet. Uh, not implemented. Okay. So, um,"
3534100,3541620," yeah, so we hit here and as you can see, it is not implemented, uh, contract contract ins. We don't have"
3541620,3548420," any ins right now, and we don't have any outs right now. So what we need to do, we need to basically"
3548420,3557140," consume the tokens of our tokens until we encounter the bike shader or, uh, until we ran out of tokens."
3557140,3564980," So that's essentially what, uh, we have to do, right? While, uh, Len art tokens, uh, Len art tokens is"
3564980,3572180," greater than zero. What are we doing? Uh, we know that there are some tokens in here and if, uh, maybe"
3572180,3579540," we have to actually pop that token. So this is going to be our tokens, uh, pop, right. And the tokens can"
3579540,3589940," be of different types. So what kind of types, uh, can we have, uh, token type. So we are specifically"
3589940,3595620," looking for things like words because an integer pointer and Boolean are basically words, right?"
3595620,3605860," Um, token, uh, type word, and this is basically, uh, not implemented, uh, a word not implemented."
3605860,3612020," So the other things we're looking for, we're looking for keywords, right? We're looking either for bike"
3612020,3625220," shader or for the in, right? If the, uh, token type is, uh, token type keyword, uh, keyword, we're gonna also"
3625220,3634580," say that the keyword is not implemented. Otherwise we encountered the type of the token that is not allowed"
3634580,3639700," in the procedure definition, in the procedure signature. So we have to, we have to say that."
3639700,3645620," So I'm going to do compiler error with expansion stack and, uh, so it's going to be located at the token,"
3645620,3654900," right? And we're going to say unexpected, um, um, so let's actually put it this way, human, um,"
3654900,3667540," human, uh, to, to the, to token type. And, um, I forgot how you do that. Uh, so it's going to be"
3667540,3677460," deaf human, uh, number. So human, um, human number is going to be plural, right? So basically it will"
3677460,3683780," take the token type and transform it into human readable, uh, object into human readable noun. Uh,"
3683780,3693860," yes, maybe I should rename this stuff into Humber. Yeah. I think human number is a Humber, right? So in"
3693860,3700420," here, I want to say, if it's a word, I want to say words are not allowed in, uh, token definition,"
3700420,3706100," right? So, and to generate such a thing, I have to provide plural in here, right? And for different"
3706100,3711940," kinds of tokens, it will say words, integer, strings, C strings, characters, and so on and so forth. So"
3711940,3725620," this thing is, uh, are not allowed in pro procedure definition, right? Expected, um, expected human, um,"
3725620,3737700," so this is, has to be something like this, uh, human talking type, uh, word or human, uh, token type"
3738420,3745540," keyword. And it doesn't really say, uh, what kind of keyword, right? So, because we expect"
3745540,3755380," specifically to cure or keywords, either bike share, or the, um, or the in, right? Either bike share or the in."
3761460,3768500," So, uh, yeah. So because of that, I'm not going to say that, right? Because of that, I'm not going to"
3768500,3773300," say that. So these things are not allowed in procedure definition, and then I'm going to just exit with this"
3773300,3780980," entire thing. All right. So, uh, now if we encounter word, right, if we encounter word, uh, we're"
3780980,3789220," specifically looking for three kinds of words, it's either integer, uh, Boolean or pointer, and these are"
3789220,3800180," related to the data types, right? So we have class, uh, data type. It's a class data type. Uh, and, uh, so I"
3800180,3807700," think we need to maintain a table of the names of the different data types, right? Uh, the same way we do"
3807700,3811780," that for the keywords, right? The same way we do that for the keywords, for instance, here, we have"
3811780,3820900," a table of the names and whatnot. Uh, right. So let's go ahead and do that. So we're going to have, um, data"
3820900,3827940," type names, right? And this is going to be a dictionary, uh, that accepts a string and returns the data type."
3827940,3832340," I suppose, uh, I want to actually do something like this, right? So this is going to be a data type."
3833380,3838580," Uh, and in here, we're going to do the following thing. Actually, it's the other way around. So we"
3838580,3844820," want to convert the data type into its name, right? That's what we want to do. Also, I'm not sure if I"
3844820,3851460," want to have this dash in here. So here's an integer and, uh, we're gonna, I keep forgetting that I need to"
3851460,3861220," do the other way. So data type, uh, integer and, uh, this is going to be an integer. So data type, uh, boolean"
3861220,3867060," and this is going to be a boolean. And then in here, we're going to have a pointer and the pointer."
3867060,3873780," Uh, what's the difference between enum and int enum? This is a good question. So essentially the difference is"
3873780,3881060," that, uh, enum doesn't act like an integer and you cannot use it as an index in an array. Um,"
3881060,3888020," which actually reminded me, that means I can probably just use, um, at least in here."
3888020,3895860," Uh, but yeah, so yeah, so max silver star actually, um, said the correct thing, uh, int enum can be"
3895860,3900660," cast to integer. And because of that, it can be used in the context where an integer is expected."
3901300,3908980," Uh, right. Um, so I dunno, I don't remember why I mixed these things up. So there's no really reason"
3908980,3913380," for me to use, uh, integers. It's just like I, something that I wanted to try at some point."
3913380,3920020," And it's just like in the, in the source code, right? So it's like a leftovers of the evolution"
3920020,3926740," of the, uh, of the code. It's like a DNA, right? You know that in DNA, in the human DNA or any animal or"
3926740,3933700," living species, there's a lot of like this leftovers, uh, of the evolution, right? There don't serve any"
3933700,3939540," purpose, right? But there's just like, you know, leftovers, they are not needed, but they're there."
3939540,3946580," So the same thing is here. Why data type is int enum, but intrinsics is enum when in both of the cases,"
3946580,3951940," we gonna use a dictionary. There's no reason, but it's just there because of some processes throughout the"
3951940,3959460," development and going and like, uh, illuminating all of these, uh, inconsistencies is just like too"
3959460,3965540," expensive and to be fair, not needed because it does not affect the execution of the program whatsoever."
3965540,3971700," It's just like there. Um, you know, like here's an interesting thing as you program more and more"
3971700,3977140," in big projects, right? Especially the projects that are several people are working on. You,"
3977140,3983540," you tend to basically ignore this kind of stuff. You encounter something that is really off and"
3983540,3989540," it is something weird. And you learn that there's no reason to actually, you know, rat hole about"
3989540,3995620," that because it's probably because of some reasons, like maybe it's not needed, uh, but nobody thinks that"
3995620,4002020," it doesn't hurt anyone. It's just there. So whatever, right. Um,"
4002020,4013780," so yeah, it's kind of, I dunno, doesn't, doesn't affect anything. Uh, anyways, so here, what we have in"
4013780,4027620," here and let's see, uh, so data type names, uh, so in here I want to see if token value, uh, first of all,"
4027620,4032900," if this thing is a word, token value has to be a string, right? It has to be a string. So we have to"
4032900,4039540," assert is instance str. If it's not a string, that means it's a box somewhere in the parsing process,"
4039540,4052420," right? So, um, and if token value is in data type names, right? If it's in data type names, uh, we want to check,"
4053860,4066340," um, um, we do data type, um, oh shit, uh, I'm gonna get, yeah, um,"
4066340,4075860," so I need the other way around actually. I need the other way around. Data type by name."
4075860,4083140," I wonder if I can use a little bit of Emacs magic to actually fix this problem. Can I?"
4083860,4094100," Can I have just a tiny bit of Emacs magic to refactor this entire stuff back? Uh, just basically like so."
4094100,4105060," Basically like so. Cool. So data type by name, uh, parse proc contracts, uh, data type by name. If"
4105060,4113700," this thing is there, uh, we take data type by name, token value. And here is the data type. And essentially"
4113700,4120820," what we have to do, we have to add that thing to, uh, the list of the inputs of the contract, right?"
4120820,4125620," So we're adding that to the list of the contracts. Otherwise we have to throw an error, right? So this"
4125620,4132020," is going to be a compiler error, uh, compiler error with the expansion stack. So this is going to be the token."
4132020,4140820," Uh, so what we're going to say, uh, unknown, uh, data type, and we're going to just say, um,"
4142100,4150180," unknown data type token value and then exit with a non-zero exit code. Okay. So I think that's pretty"
4150180,4155860," much everything I want you to say, uh, to, to do in here, right. In terms of parsing. And then if we"
4155860,4161300," encounter a keyword, we want to see what kind of keyword is that, right?"
4163700,4171380," What kind of keyword is that? Uh, so if it's bike shader, right? If it's a bike shader, we have to"
4171380,4179700," continue execution of the, um, we have to continue parsing of the outputs. If it's in, uh, we have to"
4179700,4187780," stop and return like everything. So if, um, if token value, uh, first of all, token value has to be the"
4187780,4194820," instance of the, uh, of the keyword, these instance, uh, and what is going to be the keyword, right?"
4194820,4202260," So this is a keyword. If the value is the keyword, uh, bike shader, right? If it's a bike shader,"
4202260,4209220," we basically break, um, right and continue execution. So here we're going to parse the output parameters."
4209780,4219940," Uh, otherwise if it's, um, keyword, um, in, we're going to instantly return whatever we have in the"
4219940,4227060," contract, right? See, so if it's a bike shader, we continue. If it's not, uh, we just, uh, return as"
4227060,4234820," keeping like everything straight up. Uh, so, and here's an interesting thing. So this is parsing of the"
4234820,4243220," inputs, right? Um, parsing inputs, the outputs is kind of the same. And this is kind of the problem"
4243220,4251780," with, uh, reusing the code and whatnot. So parsing the outputs is literally the same, except one small"
4251780,4261620," change. Um, you only expect the in and you always return contract when you encounter it. And, uh, I"
4261620,4268820," suppose I forgot to do the else, uh, right. So here we can do the else, uh, here we can say compiler error"
4268820,4277540," with expansion stack token, uh, unexpected keyword, uh, unexpected keyword. And we're going to say"
4277540,4288020," something like, uh, keyword, uh, names and we're going to write token value, right? So the difference between"
4288020,4297300," these two codes is like one single branch, right? That's a huge problem with the reusing the code,"
4297300,4303860," if you know what I'm talking about, right? So it's kind of, it's kind of hard to reuse the code because of"
4303860,4311780," that, right? Because the only difference here is just like one single branch. Hmm. But I think we can do"
4311780,4320740," something about that. I think we can, we can extract both of the pieces of code into a function and"
4320740,4328900," accept a list of keyword stoppers, right? We can accept the list of the keyword stoppers. And, uh,"
4328900,4335540," for instance, for the inputs, you, you have two keyword stoppers, the bike shutter and the in, and for the"
4335540,4342740," outputs, you have only one, uh, you know, stopper, which is in. And when the stopper is encountered,"
4342740,4349940," it's also returned as the result of this parsing function. So whoever called that function can decide"
4349940,4355940," whether continue parsing outputs or not. So this is how you can compress these two pieces of code,"
4355940,4360580," right? So, uh, let's actually try to do that because that sounds like a pretty good idea,"
4360580,4364500," because I don't want to keep these two chunks of similar chunks of codes around and it's just like,"
4364500,4376820," okay, parse, um, um, how can you say contract, uh, contract list, right? So you accept the tokens,"
4376820,4383940," and this is going to be least tokens and, uh, stoppers, right? And it's a list of keywords. Uh, and on top of"
4383940,4392260," that it is, it will return the specific stopper that was encountered, whether it's a bike shader or in,"
4392260,4396660," right? And based on that result, we're going to actually, you know, make a decision. Though here,"
4396660,4402260," we need to return two things. We need to return the list of data types and the stopper. So let's"
4402260,4408420," actually return a tuple, right? Um, so this is the keywords. This is the stopper. And the first thing is"
4408420,4415620," going to be a list of the data types, right? The list of the data types. So, and the procedure is"
4415620,4421380," basically going to be this, right? So I'm going to just put this thing in here and, uh, I'm going to"
4421380,4429140," remove these two things. Okay. So now I'm going to take this function and strand."
4430740,4438660," Uh, okay. Uh, so here I provide the tokens and I provide, provide the stoppers. The first stopper"
4438660,4448420," is going to be keyword, uh, bike shader and keyword in, uh, so, and in here we encounter the, can you do"
4448420,4462740," something like contract, uh, hints, um, stopper. Uh, so, uh, azure, azure, akumori, um, donated 100 bits"
4462740,4467140," saying port port. Thank you so much for 100 bits. I really, really appreciate that. Right. And here,"
4467140,4477540," what we have, if the stopper is equal to, to the bike shader, right? Actually, if it's equal to keyword in,"
4478980,4486820," we simply return contracts, right? We simply return contracts. Okay. So, um, if after that the stopper"
4486820,4495540," was encountered that is in, we do that. Otherwise we do contract out, uh, stopper and, uh, we just do"
4495540,4505620," something like this, which is, yeah. So we encounter this thing like that. So, um, and then we may try to"
4505620,4511780," assert that the stopper was keyword in for whatever reason, and then return the contract. So as you can"
4511780,4516980," see, we managed to compress these two pieces of code, right? So we have extra branch, but this extra"
4516980,4523700," branch is compressible with this kind of approach. I think it's an all right approach. So, um, one thing"
4523700,4530100," we can do in here, we can basically, uh, type check this entire thing, and just see what kind of problems"
4530100,4530740," we have in here."
4530740,4546660," Is port a single file project? No, it is not. We have one, two, three, also a lot of files in here."
4548260,4555940," Uh, also one file in here. We have a bunch of examples. So a lot of files in here, also a lot"
4555940,4562980," of files in here and also some editor stuff, right? So as you can see, it's definitely not a single file"
4562980,4578180," project. Hmm. All right. So, uh, what do we have in here? So missing return statement. Okay. So yeah,"
4578180,4587780," here I'll have to maintain the, um, I don't know, the arguments contract list, let's call them args,"
4587780,4594740," right? So this is going to be a list of data types, uh, and we're going to make it empty. So here I'm"
4594740,4600740," going to create a place contract ins, uh, args, boom. And that's pretty much it. So data type by name,"
4601460,4608420," uh, and in here when I encounter one of the stoppers. Okay. So if a token value is, uh, in"
4608420,4616500," stoppers, right, it's in stoppers, uh, we essentially straight up, um,"
4616500,4626100," return the contract and the stopper keyword. Otherwise we say we have an expected keyword in"
4626100,4633700," here. Okay. So that's looks pretty reasonable to me. Uh, okay. Missing return statement. And then after"
4633700,4640580," that, after we actually parsed everything, this one is really strange because we do expect, uh,"
4640580,4649460," the stopper. So you need the stopper to stop the parsing of the list, uh, to stop the parsing of the"
4649460,4658580," list. So maybe we have to do a compiler error in here, right? Um, compilers expansion stack. Uh,"
4658580,4664180," so expected, uh, keywords, um,"
4664180,4672020," expected keywords and we can probably provide, um, something in there."
4675220,4684020," Uh, unexpected, uh, uh, end of file, expected, uh, keywords, expected keywords. And we can just go"
4684020,4692260," through the stoppers, uh, keyword in stoppers and just do compile a note, uh, on the token location,"
4692260,4704020," uh, token location saying something like F keyword names, keyword names. And what we have to provide,"
4704020,4710660," we have to provide the, um, keyword in here, right? So this is going to be the specific name. So the"
4710660,4718820," compiler note, and after that, we're going to exit with one. Uh, cool. So yes, yes. So data type by name."
4718820,4729140," Uh, so what is the difference? Okay. Data type by name. Hmm. Is that because it's just located, it's not above."
4730980,4738660," Yeah. Yeah. It's located somewhere, uh, somewhere down below. So that means I have to, uh, data"
4738660,4751780," by name. I see names. So this is just, uh, all right. So name contract and we have to return"
4751780,4760740," orgs. Okay. Okie dokie. There we go. So we fixed everything. We fixed everything. So now if I try to"
4760740,4768020," compile this into, I think it will say unknown day. Oh shit. This mother flipper is already working."
4768020,4775860," Right. So it already went into the standard library and now it tries to parse the standard library."
4775860,4781860," Right. And of course this is a mistake, right? Because you don't have it in right. So at pointer,"
4781860,4788500," as far as I know, it accepts a pointer, uh, and reads the word from that pointer and just returns a pointer."
4788500,4796020," So this is the signature of, uh, at point, right? So that's what we want to have in here. Uh, and"
4796020,4801860," integers are not allowed in procedure definition. Okay. So as you can see, it's already, I think this is a"
4801860,4806580," pretty good testing for our pasta, right? Because I'm pretty sure we're going to encounter a shit ton"
4806580,4811140," of different cases that we were checking. Right. So that's actually pretty cool. I really like that."
4811140,4818660," So in here, uh, what I'm accepting. So this is the field and it accepts a pointer and will return a"
4818660,4825780," pointer. Right. So, uh, yeah, it basically upsets the pointer. That's what it does. Um, right. So let's"
4825780,4831700," actually do it like that. So follow all of the procs. And I wonder if I can just do something like"
4831860,4839140," that. Yeah. Yeah. I'll have to do it like that. Uh huh. Then I have to jump in here and boom."
4839140,4847940," Emacs magic, by the way, Emacs magic. If you freaking epic. Can I align?"
4847940,4856020," There we go. Look at that. And I forgot ins. That's for sure. Uh, I forgot ins."
4859140,4863780," Look at that. Look at that beauty. Isn't that cool? I think it's pretty freaking cool."
4863780,4871540," So in here we accept the pointer essentially. And, uh, we return an integer if I'm not mistaken."
4871540,4878260," There we go. So that's the special function in here. Uh, so the constants don't require anything. So"
4878260,4884900," it even looks all right. I really like that. I really like the in, uh, because it just denotes where the"
4884900,4892900," function actually starts. All right. So let me, let me see unknown data type. Okay. That's cool."
4892900,4900340," Thank you very much. Thank you very much. That is very, very cool. Uh, so I think I know how I'm"
4900340,4906260," going to fix all. Oh shit. For the different syscalls, for the different syscalls, we have to have different"
4906260,4914180," types. Though I think it doesn't matter because we don't do type checking yet. Yeah, we don't do any type"
4914180,4918420," checking yet. So that means we can just do in everywhere in here. So it doesn't matter. So the"
4918420,4924180," only thing we're trying to do right now is to pass the parsing step, right? So I think I should not"
4924180,4928900," bother with specific types, at least right now, uh, because that's kind of not the point."
4928900,4938900," a known data type. So in here is just an in, in. Oh shit. What's going to be the data type for"
4938900,4947620," things like to drop and because they're kind of generic, aren't they? We can introduce something"
4947620,4957540," like any, right? Any, any, uh, any, any, any, any, any, right? So, but we erase the types if we introduce"
4957540,4963380," any, right? Because to tube, uh, like you, you may have like a bunch of integers, like integer and a"
4963380,4973780," pointer and to do is supposed to do this. So it keeps tracking of the types on the stack. And there's no"
4973780,4978980," easy way to do that. So you literally need generics to keep, holy."
4978980,4990340," I was going on this entire adventure just to avoid implementing the Hindley Miller. And now I need"
4990340,4998820," generics."
4998820,5008820," Now what?"
5008820,5015860," How many of them do we have? Like, I don't think we have that many generic procedures."
5015860,5023220," Uh, shouldn't be that difficult to implement, by the way, if you think about it, you just introduce"
5023220,5031220," like, okay. Um, uh, high X zero subscribe to tier one. Thank you so much for seven months"
5031220,5034580," of tier one subscription. Thank you. Thank you. Thank you. And welcome to a big port."
5038340,5047140," So, uh, we could do something like proc to dupe and you would say a, B, a, B, a, B. But then you'll"
5047140,5054020," have to denote that those things are generics, right? So in OCaml, you put like a prime in here,"
5054020,5060740," but our parser won't be able to actually parse that. We can put something like this, right? And then you"
5060740,5067140," apply the same type checking process as with specific, uh, specific types. So I don't think"
5067140,5072180," it's that hard to implement, but implementing all of that is going to be like outside of the scope of"
5072180,5076100," what we're trying to do right now. So probably not going to do that. Okay."
5076100,5083140," Or make them strings. That's a pretty cool idea actually. Yeah. So a,"
5083140,5093700," I like that. So that way you don't really have to do anything from the point of parsing. Uh,"
5093700,5098500," Harrison subscribed at tier one. Thank you so much for a tier one subscription, your first subscription,"
5098500,5107540," but thank you and welcome to our epic portal. Uh, so, um, yeah, so we're going to postpone that and"
5107540,5112900," continue. Uh, we're going to just ignore, we're just going to pretend that we never saw this problem."
5113140,5118980," ever. This problem does not exist, right? You don't need generics, right? You, we're going to pull"
5118980,5124180," off the go developer move. We're going to just close our eyes and pretend that you don't need generics."
5124180,5131860," No, no, no, no, no. Interfaces, interfaces, interfaces. No, no, no, no, no, no, no, no. So this is what we're going to do, uh,"
5131860,5136740," okay."
5140260,5145460," Got it. Uh, so here we're going to have another thing. Um,"
5145460,5152660," All right. So what would they have to do? I just have to go through all of the procedures. Maybe I can,"
5152660,5159780," uh, I can just do it like that. Can I just query replace this mother flippers? Can I? Uh, okay."
5159780,5167780," Query replace proc. Then you have something like this and then the space, right? And then you can say proc,"
5168260,5176020," uh, maybe, um, uh, maybe it has to be something like this, right? So we want to be a little bit greedy"
5176020,5183940," and then the space and we're going to replace it with proc one in, uh, yeah, it's almost there. It's just"
5183940,5192260," like I need an extra space after in there we go. Now we're talking, look at that automation of our nation."
5197060,5202180," Okay. Unknown data type dup and it didn't work for, for this one, which is kind of,"
5202180,5210340," wait, what? Ah, because it doesn't have a space in here. All right. Unknown data type dup and another one,"
5210340,5218020," uh, unknown word to dup. Well, I mean, you can always, okay, query place to dup over, over."
5219140,5229940," There we go. We're going to pretend that we don't need these keywords, right? Uh, yep, yep, yep, yep. Cast int."
5229940,5236740," Okay. So let me query replace, uh, this thing, but now this time, uh, it is not going to be space. It is"
5236740,5247780," going to be, uh, end of the line and there we go. Yikes. Okay. Finally, it compiled. Wait, it actually"
5247780,5256660," fucking compiled. All right. So this thing compiled, but it didn't perform any type checking. That's"
5256660,5263620," what's interesting about that. We successfully did it, but we didn't perform anything. Okay. So that makes"
5263620,5273380," sense. Um, so I think one of the things I want to do, uh, we want to print some of the, you know,"
5273380,5278260," type declarations and whatnot. Uh, so this is a nice problem to be fair for the nice program. We don't"
5278260,5284580," need the standard library because we only use the print intrinsic. So that's fine. And, uh, then in the"
5284580,5305060," port. I'm going to think, um, I want to find the place where we call this thing. So parse proc contracts, um,"
5306340,5316740," dev parse program from tokens. I want to print all of the contracts. I just want to print them, uh,"
5316740,5320740," and see what's going to happen. Proc in, um, program,"
5320740,5330020," program prox, uh, prox and just print this entire shit. Is it going to work? Uh,"
5331060,5341540," it's not called program. What is it called? Um, I, I, it is called the context, I suppose."
5341540,5351940," Yes. It's called context, uh, prox in. So it's basically city X prox in city X and it didn't. Oh,"
5351940,5359060," okay. Look, look at, look at that. Look at that. So here's a print sum. That's pretty pogue. Uh,"
5359060,5372340," maybe we want to do something like items. Uh, maybe proc name, proc name, contract, contract."
5377540,5389140," City X. Okay. So here's the contract for our function, right? Ins is two integer outs is one"
5389140,5396900," integer. That's what we have in here. Ins and outs. Uh, we can change this kind of stuff. We can say"
5396900,5402260," that it's going to be, uh, in Boolean, in Boolean, and it returns pointers. So we can do that because we"
5402260,5409620," don't type check that anyway. Right. So, uh, int Boolean int Boolean, uh, and outs is pointer. So as"
5409620,5415380," you can see, we actually parse everything successfully. So, yeah, so we can syntactically"
5415380,5421380," finally define some of these things and, uh, can I do something like this? Right. So if the signatures"
5421380,5427300," becomes too big, you can always split it this way. And as you can see, now you can nicely see what are the"
5427300,5432180," inputs of your, of your procedure and what are the outputs. And you can have like a lot of them and"
5432180,5436980," you can also have a lot of, uh, outputs, right? So in, you can just basically format them in a very"
5436980,5442740," compact way. So, um, that's precisely the reason why I'm choosing this kind of syntax, because it allows"
5442740,5447300," you to do this kind of stuff. If you have too many inputs and too many outputs, you can just like"
5447300,5453860," format them nicely more or less. And, uh, let's actually confirm that, um, our compiler can parse this"
5453860,5457860," this kind of shit. Yep. It can parse that. As you can see here are all of the, uh, types that were"
5457860,5464340," parsed. Cool. So let's go back to the original thing. So here we have two integers and you're"
5464340,5471780," going to get one integer. Uh, we need to now, um, type check this entire thing, right? So how about that?"
5471780,5480740," We need to type check this entire thing. So to do that, we need to go to the type check program procedure."
5482900,5486180," Uh, by the way, are invited types called a breach of contract?"
5486180,5495940," We can call it like that. Why not? So thank you. That's actually pretty cool terminology. Yeah."
5495940,5502180," So other programs will call it a type checking error. Uh, we're going to have a breach of contract."
5502180,5508260," Uh, but it will require a lot of renaming, but I'll keep that in mind. Thank you. Thank you so much."
5511380,5519300," Breach of the contract. All right. Um, okay. So better error reporting on type checking errors"
5519300,5524820," of intrinsics reported expected and actual types with location that introduced. Yeah. So it's who cares"
5524820,5532180," about good error messages, right? Um, so let's find the call, right? So when we encounter a call,"
5534020,5539860," what we have to do, all right, we have to type check this entire thing, I suppose we don't need to type"
5539860,5546420," check, uh, call limit, right? So I'm going to straight up remove this entire thing. Um, I think the easiest"
5546420,5557060," thing to do in this particular case, here's the stuff, uh, the type checking thing,"
5558420,5565380," the type checking thing doesn't know the contracts of the procedures. That's the problem. It doesn't"
5565380,5572740," know the contracts of the procedures. Not implemented. So this is going to be too dumb."
5572740,5580340," So not implemented. So we need to pass the information of the, about the procedures,"
5580340,5588420," right. But the, the prox, uh, the prox dictionary that it, that we have maps the procedure name"
5588420,5595300," to the specific procedure, but we don't know any names at the type checking step because type checking"
5595300,5601940," step accepts the, uh, intermediate presentation. So intermediate presentation doesn't have any types,"
5601940,5610020," any names, right? So maybe we'll have to do a trick where we generate a different dictionary"
5610020,5617220," that accepts, um, that basically accepts OP address and maps it to the proc, right? Or maybe we can have"
5617220,5625940," something like, uh, dictionary OP address maps to a contract, right? So basically we'll need a function"
5625940,5633380," that takes this kind of, uh, dictionary and produces this dictionary out of that, right? So, uh, let me see"
5633380,5643620," input, uh, dictionary, uh, str, proc, uh, and something like this, but I have no idea how to call such thing."
5643620,5658260," So yeah, essentially what it's going to do, it's going to, um, iterate through the items like for,"
5658260,5672260," I suppose, name proc in, uh, procs, in procs items. And what it is going to produce is essentially proc"
5674180,5680420," uh, we don't even need to do that. Can I just have values, right? Can I have values? I don't"
5680420,5685940," know if I can, but the compiler will tell me if I can. So, and in here we're going to have map and address"
5685940,5692420," to, uh, a contract to a specific contract, and then we can construct a dictionary out of that,"
5692420,5697060," right? So I want to have something like this, right? But the question is like, I have no idea"
5697060,5701620," how to call such function later. Um,"
5701620,5714820," So, but maybe this implementation is so simple that I shouldn't have a function for that,"
5714820,5722580," right? So yeah, because I can just copy paste this entire thing inside and whatever. Uh,"
5722580,5727380," so this is probably what I'm going to do. All right. Going back to, uh, type checking, right?"
5727380,5735620," So when we type check a program, we need to have the contracts, uh, proc procs contracts, maybe proc"
5735620,5741220," contracts. And this is going to be a dictionary that maps the address of the procedure to this"
5741220,5749940," corresponding contract, right? Something like this to ex corresponding contract. Uh, and this is the thing"
5749940,5754980," that we're going to use in here, right? So if I do to do, uh, not, let's actually go to call,"
5754980,5765380," uh, call, there we go. Right. So this is the call. And that means that operand of that, uh, operation"
5765380,5774820," is an OP address. So we have to assert that is instance, uh, OP address, then we can do proc, uh,"
5774820,5780900," contract, proc contract, and we can, uh, grab the contract of that specific procedure."
5780900,5791060," So then we need to test that contract against the current context. So, um, let's introduce a function"
5791060,5801220," type check, uh, type check contract actually. Yeah. It accepts the current context of the execution. You"
5801220,5806980," remember how at the beginning of the stream, I said that we do a BFS of all of the control flow"
5806980,5811860," and each individual control flow is represented by this context that maintains the stack."
5811860,5817940," Right. So we're going to have a function that takes the context and the contract and just checks against"
5817940,5822900," it. And this thing can be reused not only for the procedures, but also for the intrinsics."
5823860,5830340," Yes. Because as you can see, this function doesn't accept anything procedure related, right? It doesn't"
5830340,5835780," accept the procedure name, the procedure, you know, stuff or anything. It just accepts the current state"
5835780,5843380," of the execution and the contract what's expected on the stack and what's going to be put on the stack back."
5843380,5847860," And it could be anything actually. So it's a very generic way of type checking that doesn't"
5847860,5853220," care whether it's a procedure intrinsic or keyword. This is fucking cool. What the fuck?"
5853220,5864740," The fuck? I really like that. I'm actually so glad that is that I decided not to compress"
5864740,5870260," all of this intrinsic type checking, because if I compressed it, I would definitely do it a different"
5870260,5875620," way. I would have do a different way. I wouldn't implement this contract system or anything like that"
5875620,5882020," that is reusable for procedures. So that's why I tend to not compress the copy paste too earlier,"
5882020,5887540," because you don't know what to expect. You don't know what's going to happen, right? And how the"
5887540,5894980," development will turn. And now, once I implement that, compressing this thing is going to be trivial,"
5894980,5898820," but at the same time, it's going to be compressed with a mechanism that is reusable not only for the"
5898820,5906740," intrinsics, but also for the procedures. That is so cool. I really like that. All right. So yeah,"
5906740,5914260," a lot of developers these days, they are too eager to compress the code and get rid of the duplicates"
5914260,5920820," as soon as possible. But doing so, you're actually limiting yourself. You're losing a lot of information"
5920820,5929060," that can be useful in the future. So anyway, whatever. CTX IP plus one. So after the call,"
5929060,5933780," we go next. Catsbyte, thank you so much for Twitch Prime subscription. Thank you. Thank you. Thank you."
5933780,5945060," And welcome to our epic Porthclaw. I'm sorry. I think I'm already tired. My brain is just like shutting"
5945060,5951860," down. Instead of like doing something, it starts to produce like weird noises and whatnot. So I really"
5951860,5957860," apologize for that. So here's the context. And then we're going to accept the contract. All right. So"
5957860,5965540," here's the contract. And holy shit, for the intrinsics, we can create a dictionary that accepts an intrinsic"
5965540,5973540," and returns a contract. Right. And then you can just use the same function to type check intrinsics and"
5973540,5982580," with contracts and shit like that. Oh, that's so cool. Well, you can say that doing things this way is"
5982580,5989220," obvious, but I would argue that it's obvious because we went this entire path of copy pasting and"
5989220,5995860," researching and doing things. Of course, it is obvious right now. It is not obvious when you have"
5995860,6000980," an empty file. Right. So when you source code, when you haven't written a single line of code,"
6000980,6007700," this kind of stuff is not particularly obvious. It is obvious right now because we've done a lot of work"
6007700,6016900," to make it obvious. Right. So I don't know who I'm arguing with. I'm sorry. So anyway, um, so and tap"
6016900,6022100," checking is going to be a cat's bite is gifting five tier one subs. Thank you. Thank you so much for"
6022100,6028420," gifting five tier, uh, tier fives, tier one subs. And everyone who got the sub welcome to epic"
6028420,6038260," port club. All right."
6038260,6051780," Premature abstraction, premature optimization, premature dry all bets. Nah, I would say that dogmas are bad."
6052340,6059540," All of these things dry solid premature optimization. They're dogmas. It's not that they're bad by"
6059540,6068900," themselves. They're bad because they became dogmas. So yeah, dogmas are bad, not the specific instances of it."
6068900,6082180," Um, so arguing with me, my arguing with you. Okay, sure. Cool. This is your first message in the chat that"
6082180,6091460," I've ever read. So I'm really glad that I'm arguing with you. Um, I didn't know it go do do do five times."
6091460,6099140," Well, I mean, this is just, uh, I need to create a sense of achievement on my stream, right? So you"
6099140,6104660," donated something, you affected the stream and it's just like you, you feel the power over the streamer,"
6104660,6110820," right? You throw money and you have a power of destructing the streamer. So, and that feels good."
6110820,6115860," Supposedly. I don't know if it actually does. Maybe it does for some people, but thank you. Thank you so"
6115860,6122900," much for, for the subs. I really appreciate that. Um, all right. So, uh, let me, let me see. So this is"
6122900,6132660," going to be assert, uh, false, uh, do not implement it. There we go. So what do we have in here? Uh, contract"
6132660,6138420," is not defined. All right. So where is it defined? It's probably defined somewhere, uh, down below"
6139780,6148340," in the comments down below. Do you like and subscribe? Oh, okay. Type check, uh, type check"
6148340,6156180," program. Okay. So this is cool. Uh, we accept the program and the program is the stuff that, uh, we"
6156180,6163620," extracted from the parsing context. So we need to do pro contracts and this is how we're going to do that."
6163620,6172660," We're going to take the parse context and the procs and for, um, brock in values. I still don't know"
6172660,6176740," if the values will work, but again, the, uh, the interpreter will tell me if it's not going to work"
6176740,6184180," or not. So this is the address and the, uh, what the contract, this is the contract, of course,"
6185460,6191860," this is the contract. So if I try to compile this entire stuff, so it says invalid syntax."
6191860,6200340," Do I have to, I think I have to make it a tuple, uh, rust scan subscribe with Twitch prime. Thank you."
6200340,6207540," Thank you so much. Uh, so, okay. Let me see. Python, uh, Dick comprehension,"
6209220,6223780," comprehension. Dick comprehension. Gotcha. Um, okay. So, oh, you have to use a colon. I see. Okay."
6223780,6234980," So do I have to do it like that? Uh, we'll go missing one requirement and then I can do proc contracts,"
6234980,6244820," contracts and do we have anything else. Look at that type check contracts. We finally hit"
6244820,6254020," the to do not implemented. And the question is, what do we have to do in here? Dick comprehension."
6254020,6259380," Yes. Chat like that. I can see that."
6263540,6271380," I stream on Twitch for more than five years, maybe less actually. I don't remember, but it's"
6271380,6279780," pretty close to five years. And I know for sure the chat likes the dick jokes and that's how we become,"
6279780,6286100," became a partner. That's the secret, right? So if you want to become a partner on Twitch, remember chat"
6286100,6292900," likes the dick jokes. Uh, it doesn't matter what you're doing on Twitch. As long as you do dick jokes,"
6292900,6300820," jokes, jokes, uh, you're going to become popular. So yeah. Anyways, uh, what we need to do in here, uh, we need to"
6300820,6311300," basically see if the, uh, tail of the, you know, context stack is the same as the contracts input."
6312980,6325700," Um, so I wonder how we can do all of that. If I know, if I know the size of the stack,"
6325700,6334820," can I use, uh, slice syntax to just sort of, uh, and, uh, compare it with what expected."
6334820,6341860," I think I can, right. So I always have a, like a hard time comprehending"
6341860,6349380," dick because it's dick comprehension. No, I, I have a hard time comprehending the, uh, slice syntax quite"
6349380,6357300," often. So I don't quite understand it. Uh, but yeah, let me, let me see what we can do. So if we have one, two, three, four,"
6357300,6365300," five, whatever, right. And I want to take N last elements of this thing. Do I do it like minus three?"
6366580,6372660," Uh, it gives me the third one. But if I put this thing, it gives me, it gives me this too. But if I"
6372660,6380900," put it here, it gives me last three. So you see, like, I can't, I don't understand the, uh, slicing"
6380900,6388340," syntax by heart. Every time I want to, um, do something with it, I have to just brute force it."
6388340,6394420," Maybe I'm just dumb. I don't know, but I just saying that it's not particularly intuitive. So every"
6394420,6398980," time, okay, I want to do this thing. I just brute force the, the indices and yeah, this is how we do"
6398980,6407220," that. So last N is basically the first one, uh, but negative, right? So cool. Uh, I'm really, really"
6407220,6413300," happy. Um, so if you don't have enough of these things, right? If you, if I do 10, it gives you the,"
6413300,6419780," okay, this is actually perfect. So we can, we can make it like so. So the contract, uh, um, actually"
6419780,6439540," like this, right? Like this, right? So that's what we do. And if these things are not equal to each"
6439540,6447700," other, they're not equal to each other. Well, we're actually missing a lot of opportunity to properly"
6447700,6455700," report things, right? Uh, so my original idea was to, um, basically take both of the stacks,"
6455700,6463220," maybe copies of these stacks and pop their tops, uh, one by one and constantly comparing them."
6463220,6472020," Right. And if I encounter a thing that is not equal, I have enough information to actually give, uh, to the"
6472020,6479940," user, right? I can report, okay, look, we expected one type, but got another one. And that another one"
6479940,6486820," was introduced there. So actually popping one by one from the top, um, pop the top."
6486820,6497460," Anyway, so chat is truly horny. Like, I'm really glad that YouTube people don't see what's going on in the"
6497460,6505620," chat. So yeah. Um, so it will give us enough information."
6505620,6514820," I think I need to make a small break. Uh, right. So already streaming for almost two hours. Chat"
6514820,6521460," needs to, needs to be boink. Chat needs to be boink. All right. So, um, we're almost there, by the way, we're"
6521460,6528900," already, um, parsing the procedure signatures and we're almost have written the type checking for them."
6528900,6534740," Right. So once we've done that, we'll have to go through the code and just put the appropriate,"
6534740,6542100," uh, you know, signatures and see if that sped up the compilation of ports dot port, because that's the"
6542100,6547700," goal of today's stream. I'm not going to finish the stream until, uh, we, uh, sped up the compilation"
6547700,6554260," of ports dot port. And I think it is possible. Okay. Let's make a small break and all right."
6554260,6559940," So let's go ahead and implement it, uh, slightly differently. Right. So I want to implement, uh,"
6559940,6569220," like basically pop the things one by one. Uh, so while, uh, length of city X stack is greater than zero."
6569220,6578340," Right. Right. And, uh, length of the contract ins is great. Well, here's the thing. Uh, we don't want"
6578340,6584900," to modify the ins because the contract can be reused several times. So we need to have a copy of ins."
6584900,6595300," Right. So we need to copy, uh, this entire thing. Furthermore, I think we need to copy this stack as well."
6595300,6601460," Right. We need to copy this stack as well because, um, intrinsics, if we're going to reuse this entire"
6601460,6607780," thing for intrinsics, intrinsics have overloaded contracts, right? They have overloaded contracts."
6607780,6615060," And, um, because of that, we need to be able to check several contracts and pick the one that actually"
6615060,6619380," fits there. But to be fair, it's kind of outside of the scope of what we're doing right now. So probably"
6619380,6626740," I'm not going to bother. So I'm going to only have a copy of this in, uh, so yeah, here we're going to"
6626740,6634660," have something like this. So the actual thing in here, oh, it depends on the stack. So data, uh, stack,"
6634660,6642100," uh, it's, it accepts data type and the token where that data type was introduced. Okay. So, um,"
6642900,6653060," so data type, the actual and the basically talking location, right? So, uh, C T X stack pop and the"
6653060,6660100," expected data type is expected is in ins. So we're going to do pop. And here is this thing. If the actual"
6660100,6669780," not equal to expect it, right? This is the perfect time to report an error, right? So compiler error with"
6669780,6673780," the expansion stack, so we're going to do, um, so what we're going to do actually."
6673780,6683460," So, yeah, we can actually point at the token location, right? So we're going to point at the"
6683460,6691140," location where an expected type was introduced, right? So we know where that actual type was introduced."
6691140,6697620," We can use it as the location of the report, right? And what we're going to say in here, uh, unexpected,"
6698980,6706260," uh, data type, right? So here's an expected data type. Um, and what we can do in here, I suppose we"
6706260,6714260," can just do, uh, actual, right? So here's the actual, and, uh, then we can say something like expected,"
6714260,6719460," uh, expected, right? Expected, expected, and then we're going to exit with this thing."
6719460,6727140," Okay. And basically we keep popping, we keep popping the elements until one of them becomes empty, right?"
6727140,6732900," Until one of them becomes empty. So, and the question is like, depending on which one became empty,"
6732900,6736580," we'll have to report different errors, uh, right? If"
6736580,6746980," CTX stack became empty. Well, this one is rather interesting, right? So we need to check that some of"
6746980,6752660," them is empty and some of them are not. But since this, because of this condition, because of this"
6752660,6757780," condition, we know that one of them, at least one of them is zero. So the way we're going to do that."
6757780,6764020," Okay. So if the length of this thing is greater than the length of this thing, that means that this thing"
6764020,6771940," is zero, right? That means this thing is zero. And, uh, that means we have unhandled data on the stack,"
6771940,6777700," right? So we're doing, does it really matter?"
6780660,6786340," no, I don't think so. Right. So the stack can actually have more things. Um,"
6786340,6790740," um,"
6790740,6802420," yeah, so that kind of makes sense. For some reason, I don't quite comprehend, like, should"
6803220,6807700," this stack be, I think it doesn't matter, right? So if the stack"
6807700,6816020," becomes that, so I think this is the thing that we care about. If stack became zero, but you still"
6816020,6822260," have some stuff in the ins, that means you have to do something, right? So this is definitely an error"
6822260,6827460," that you have to report. And how are we going to report that error? That's a good question."
6829140,6836500," So we have some ins. Where exactly do we want to report that? Um, so I think we want to report that"
6836500,6843380," in the place where you call this thing, right? So we can provide the location and this is the location"
6843380,6857620," that we're going to use. Um, not enough arguments, uh, not enough arguments provided, um, expected,"
6859700,6865780," and then we can iterate through the rest of the stuff we have in here. So the, uh, it's going to be"
6865780,6877540," type in ins. And then as a compiler note, we can say, uh, location and F and this is going to be type."
6877540,6886500," And then we're going to exit with one. And I think that is it, but not really, right? If, uh,"
6887860,6894260," ins is zero, if ins the zero, that means we consume everything. And now we have to take the stack"
6894260,6900820," and append the contract outs, the contract outs."
6900820,6908260," That is very cool. But here's the thing. It's not going to pass because the stack also accepts the"
6908260,6916420," location where those things were introduced. Those things were introduced in here. So, but it actually"
6916420,6922420," accepts the location in the form of a token. So that means here we have to provide this thing as a token,"
6922420,6932980," introduced, uh, token, uh, token location or something like that. Introduced token location."
6932980,6939780," Uh, so that means this one with expansion stack intro, let's actually call it intro talking location."
6940500,6951060," Um, maybe just intro talking, uh, token. So this is the token that introduced. So this is the intro"
6951060,6963540," token. Uh, huh. And intro talking location outs. We need to map this into, I think, right? So for type in out,"
6964580,6974500," uh, we're going to do, uh, type and intro talking. So that's how we're going to do that. Right? So I think"
6974500,6979380," this is the whole type checking process. I don't think we need to implement anything else in here,"
6979380,6987620," hopefully. So let's go ahead and, uh, compile the entire thing. So, uh, this thing expects more. And the"
6987620,6994820," token that introduced is the token that is part of the current OP. Don't freaking tell me that it just"
6994820,6998980," worked first try. Don't freaking tell me that it worked first try. I do not believe that."
6999780,7015300," Uh, okay. Okay. So if I remove this thing. Fuck sake, it worked first try. What the fuck?"
7015300,7023780," No, I can't believe that there should be. Oh, I remembered. I think I remembered. We didn't type"
7023780,7030900," check the procedures themselves. I think, right? You can do something like this, like 100 and it's"
7030900,7038100," going to, yeah, it is going to work. And as you can see, it's summed up the things. Uh, and I think"
7038100,7045620," one of the things we need to do in here is just like, yeah, uh, mass plus subscribe with tweet prime."
7045620,7050180," Thank you so much for three months of tweet prime subscription and welcome to our epic fourth club."
7050180,7057940," Okay. Excuse me. Here's the thing. We don't go inside of the procedures, right? So that's one"
7057940,7063380," of the problems we have. We don't go inside of the procedures. Uh, so how can we go inside of the"
7063380,7070260," procedures? That's a very good question. Um, to go inside of the procedures. Oh, fuck."
7076660,7087860," Well, since we have the BFS of the context, we can basically add the context for each individual"
7087860,7093700," procedure. Since like when we type check the call, we don't go inside of it. So we never actually"
7093700,7100820," type check the internal procedures. So what we can do, we have procedure contracts. Let's add additional"
7100820,7106180," context to the wave. So wave also goes inside of the procedures and tap check them without going inside."
7106180,7112820," And oh, the current way of type checking actually fits perfectly for what I'm doing right now. Like"
7112820,7121300," That's really weird how all of the pieces just come together very nicely. I didn't expect that."
7121300,7128500," Like the type checking system works out for the intrinsics and it's really easy to now"
7128500,7134500," go inside. Okay. So how can we do that? Um, I'm going to go through all the procedures. So it's going to be four."
7135700,7144020," Uh, PROC address, right? PROC address and we don't really care about the PROC contract per se, do we?"
7144020,7152500," We, holy fucking shit. Oh my God. We do care about the contract because the contract of the procedure"
7152500,7160420," denotes the current state of the stack, right? So when we start the context execution for type checking"
7160420,7167860," inside of the procedure, we know the specific state of the stack. Here it is. Here is the expected state of"
7167860,7172580," the stack and we can just grab this as the current stack of the stack and continue type checking."
7173460,7179700," So this thing just provides this stack to use to start type checking things. Holy fuck."
7179700,7182500," This is so cool."
7182500,7193140," Yo, I like that. And this is what is expected. This is what is expected in here."
7194740,7204180," Yo. Okay. I'm sorry. Um, so we iterate through all these things, uh, in, uh, PROC contracts,"
7204180,7212900," right? And, uh, we take the items in here, right? And basically for the contexts, uh, we append, uh,"
7212900,7221940," the context, the initial stack of which is the PROC contract input INS, right?"
7221940,7236420," INS and, uh, the IP, we know that the IP is the address, right? The IP is the address. You know what?"
7236420,7242500," Since we don't go inside of the procedures, right? The context doesn't need the return stack."
7243300,7250020," It just doesn't need it because we never actually like go there and go out. So the only thing you need"
7250020,7260980," is, um, the stack and IP. But how do we test inside? Okay. So inside of the procedure, we reach the end."
7260980,7269860," How do we test that we expect this state of the stack? How do we expect it, uh, like this?"
7272100,7280020," We have to make it. Okay. Here's the thing. So we finish, we pop the current type checking context"
7280020,7286740," when the stack becomes empty. So when the stack becomes empty, I think we can have outs in here,"
7286740,7293460," that says, that say what kind of things we expect on the top of the stack. So we expect the list of data"
7293460,7303780," types. Oh, and this thing is applicable for the context outside of the procedures, right? Because"
7303780,7310420," outside of the procedures at the end of the program, we expect no output, right? So you cannot just push"
7310420,7315700," something on the stack and finish the program. You have to process everything. And that could be part of"
7315700,7322580," the expected outputs within the context, right? So when we start the execution, we say that for the whole"
7322580,7329300," program, so this is the whole program context, we expect no outputs, but for specific procedures,"
7329300,7339300," the outputs are going to be the outputs of the contract. That's so cool. I really like that. Okay. So the outs"
7339300,7346420," is the, uh, proc contracts, uh, outs. There we go. So this is how we're going to do all of that shite."
7347860,7355060," So, and I just remembered stack accepts also the tokens, but these ins are not the tokens. So we need"
7355060,7364580," to know where those things were provided. Fuck. Um, that is very, very interesting. So maybe for now,"
7364580,7372100," it would be kind of cool to actually use the locations of these tokens as the location where the data was"
7372100,7379700," introduced, right? So for instance, if you have like a pointer in here and you do something like,"
7379700,7385780," I don't know, what's not compatible with the pointer or like Boolean, right? And you do plus one. And this,"
7385780,7391460," the compilation step will say, okay, you cannot add integer and Boolean. And it will say the integer and"
7391460,7395780," Boolean are introduced in here because we know the locations of this token. That will be actually kind of"
7395780,7406500," cool. I think, I think that will be kind of cool. Hmm. You just check the program as independent your"
7406500,7413140," proc as independent program. Yes. Kind of, kind of, it's kind of like that. Uh, but for the proc, you"
7413140,7420260," have different expected outputs for the main program. There's zero outputs expected. And for the proc,"
7420260,7425540," there is very specific outputs expected. What's interesting is that if we going to introduce"
7425540,7431220," the following thing that the main program, uh, expects the exit code, right? So you always have"
7431220,7438020," to have at least like one, um, integer on the stack and that integer is going to be used as the exit code."
7438020,7444660," It would be trivial to enforce that basically for the main program, just say that you expect data type"
7444660,7450980," integer as the whole program. And there you go. So, and then that integer is going to be used as the exit code."
7451780,7459540," Um, that is really cool. So everything just like fits together. This is unsettling actually, the fuck."
7459540,7468660," So yeah, you know, it feels like when you play in a video game and you encounter enemies, right? And that"
7468660,7473060," means you, you going in the right direction. That's what it feels like, right? It feels like I'm going in the"
7473060,7480580," right direction. Uh, so yeah, that's pretty cool. Um, okay. So for the ins here, we'll have to probably do"
7480580,7485780," something special because we need to introduce the tokens. Uh, but for now we don't really have enough"
7485780,7493540," information to introduce it. So I'm going to do for, uh, type in this thing, right? So this is the stack"
7493540,7500660," and this is going to be type, uh, and the token, we can always take the procedure address, right? We take"
7500660,7508740," the procedure address and we take the operation where the procedure starts, right? This is where it starts."
7510260,7516020," Uh, and then since we have OP, we know what token introduced that OP so we can use that as the location."
7516020,7523700," Uh, so it's not pretty, but it's something, it's at least something. Okay. So let's try to, uh, to compile"
7523700,7531140," this entire thing. And, uh, what do we get? Um, uh, unexpected returns that, yeah, we don't have a return"
7531140,7540020," stack anymore as I said, uh, uh, contexts, uh, it's a plural thing. Uh, and another thing ins. Okay."
7540020,7553860," Dict has no attribute ins. So contract. Oh, it's a single one. Uh, contract. Oh, it's actually,"
7553860,7558340," it's actually super easy to confuse this entire stuff. So maybe I should get rid of those."
7559780,7563940," Uh, it's going to be kind of difficult. Okay. So I already, I already started doing this thing."
7563940,7571540," Um, okay. Uh, so what are we doing here? Compile them? Oh yeah. Okay."
7571540,7581300," So here is an intrinsic and we do plus and invalid blah, blah, blah. So what does it say? Um,"
7584020,7589860," Oh, oh yeah. So now we have to go through all of the context. Okay. I think I need to just type,"
7589860,7594340," check this entire thing. Right. So, because I'm checking types at runtime, but I'm obviously need"
7594340,7599300," to check them at compile time. So I need to statically check everything. Uh, all right. So finally, okay."
7599300,7608180," Compiler notes. Uh, what do we have in here? Oh shit. Uh, compile note."
7610340,7620500," All right. Uh, okay. So return stack. Okay. So this thing has to be re-implemented to do re-implement."
7620500,7628980," Right. So this is the re-implement next one. Uh, compile a path. Uh, oh,"
7630580,7638580," Oh, we have a special. Yeah. Okay. Here's the thing. Since our execution always goes inside of the"
7638580,7646660," procedures, right? Uh, like a BFS. If we encounter an error deep inside of some function, this error is"
7646660,7653460," kind of useless unless you know the whole path of the execution. You see what I'm talking about? It's kind of"
7653460,7660900," useless. So that's why I also keep track of the whole path of the execution that led to that error."
7660900,7667860," So I can report it as a stack trace telling the programmer, uh, where like what exactly caused that"
7667860,7674740," thing. So this is how the meta execution went, but since we have signatures, it is not needed anymore."
7675940,7682260," Like we don't have to do that. Right. So, because the, the, the errors will be catch as early as possible."
7682260,7688980," So we have to refactor this entire thing. So we have to get rid of the compiler error with call path."
7688980,7696420," All right. So we have to replace it with just a regular thing. Uh, yes, yes, yes. We're freaking there."
7696420,7708020," So, uh, we need to replace this call, uh, with just a thing with expansion stack, expansion stack,"
7708020,7716100," which accepts, uh, just the token. So this is basically what we have to do in all of these places."
7716100,7722340," So that will require a little bit of Emacs magic to do the, uh, substitution by a regular expression. So"
7722980,7731940," let me quickly see how we can do that. Uh, so to be fair, it should be as easy as taking this thing"
7731940,7743940," and replacing it with, uh, something like this. Yeah. So because we're using the same names everywhere."
7743940,7754900," So we're going to query replace this thing. Uh, uh, Oh shit. Oh fuck. Oh damn. Uh, query replace. Uh,"
7754900,7762260," it's not even have to be, um, regular expression. We have to replace this thing with, uh, this thing."
7762260,7770100," Boom, boom. And let's just do that everywhere. Right. Straight up everywhere. Uh, is that fine?"
7770100,7777300," Okay. So an expected word key stack. We say we, okay. So here's the if, right. And when we split"
7777300,7782100," the execution for the, if we copy the return stack, we don't have a return stack. We don't have to do"
7782100,7788260," that anymore, but we have to copy the out. Okay. That one is interesting. So maybe I can do a little bit"
7788260,7794340," over Emacs magic yet. Again, I'm going to replace this thing with just outs. Ah, Emacs, Emacs is done."
7794340,7801540," Um, uh, didn't allow me to properly select this thing and do outs. Come on. You can do that. Okay."
7801540,7813540," Okay. So there's a last thing in here. So, oh yeah, here's the thing. Oh shit."
7814340,7822660," You guys remember how I said that I type check while loops by testing whether I already visited that do or"
7822660,7829060," not. That actually introduced like a lot of problems when I introduce procedures. Okay."
7829060,7837380," So imagine that I have, uh, fourth mode while dupe, uh, less than 10. And we just do some stuff in here."
7837380,7846180," Right. Uh, imagine that this thing inside of the procedure, right. Uh, F in something like this."
7846180,7854260," And imagine that you call this procedure several times. So on the first call, you visited do twice."
7854260,7858580," And on the second call, you visited do second time."
7860580,7866180," So like you also keep repeating that process and this actually creates a lot of problems. So,"
7866180,7873860," uh, when I keep track of whether I visited do, I also keep track whether I visited it by a particular"
7873860,7880900," call path. So the execution path that led to the, to that do is part of the key that I used to keep"
7880900,7887060," track of whether I visited that do or not. So as you can see, this entire stuff became even more"
7887060,7892740," complicated, but now again, we don't have to do that. So that means I can just simplify that because we're"
7892740,7898660," never going to have different execution paths that led to the same do, uh, because we don't go inside"
7898660,7904500," of the procedures anymore. So that simplifies everything. Uh, so we have visited do, right."
7904500,7911140," And the key of visit do is a call path. So I can replace it with the OP address. There we go."
7911140,7918180," So let's actually go through the, uh, compilation errors. So context doesn't have this stuff. Uh,"
7918180,7925620," all right. So this is the call, uh, path. So instead of call path, I can just use CTX IP, um,"
7930660,7951700," do we do anything else? Uh, missing positional. Okay. So this is another thing."
7951700,7973540," Uh, so this is the contracts. So program contracts, uh, the fuck is this? Uh, and then we have to provide"
7973540,7981060," the pro contracts. There we go. We're almost there. Hopefully, uh, used to. Okay. So everything type"
7981060,7986820," checks. All right. So let's try to run this entire thing. Invalid argument to type for plus separate way."
7986820,7993940," Did it freaking just worked first time again? Disgusting. Okay. So"
7997700,8003460," really it, it just freaking worked, uh, invalid expected int or pointer, but we'll click. Okay."
8003460,8009780," So I'm going to remove that stuff and okay. Yes, of course, uh, we need to re-implement return."
8009780,8013540," We need to re-implement return. This is very important. Um,"
8013540,8022260," this is almost the last thing that we need to check, I think,"
8022260,8027540," because after that, we also need to check the end of the execution, right? We need to check the end of the"
8027540,8035380," execution. Um, so how are we going to do that? So let me take a look at the original implementation"
8035380,8048660," of OP type return. Uh, uh, uh, uh, OP type correct. So what did we have in here is we just pop"
8048660,8055780," the return stack and continue the execution, but this is not what we need to do. This is definitely not"
8055780,8062260," what we need to do. What we need to do in here is take a look at the current stack"
8062260,8070260," and just check that it has the same outputs as in the contract. So outs, uh, copy."
8070260,8078260," Oh, we already have outputs, so we don't have to do anything. So this is going to be while"
8078900,8084260," the length of the CTX stack is greater than zero and length of the..."
8084260,8097620," Yeah, that's fine. Uh, it's kind of the same code as for the type, uh, check contract or something, except..."
8101220,8107140," Can I just reuse that shit? But it's requires kind of a different contract."
8107140,8111140," Huh."
8111140,8121460," Can I just reuse that? So intra token. Okay. So that's fine. OP token. So here is the current context."
8122900,8133300," Um, and the contract in this case is going to be... So inside of the contract, um, I'm using only INS and..."
8133300,8138820," INS and outputs and for the stack..."
8138820,8146260," Uh-huh. So here, by the way, this stack is incorrect. I have to use the... I don't know. It's fine."
8148740,8150420," Uh-huh. I'm just thinking..."
8150420,8154820," How can it be done?"
8154820,8166820," Right. Because in that case, the outputs become the inputs, right, for the return."
8166820,8175060," So I think the type checking of this thing should be slightly different."
8177620,8184180," I think we should pass the only INS, but not OUT, because in the contract..."
8184180,8186580," Well, in the contract OUT, we still use them."
8186580,8191060," We still use them."
8191060,8196900," This one is really strange, but I think I should be able to do that."
8196900,8201780," Um, all right. OP type"
8204020,8215060," return. So in that case, contract INS are the context OUT, but the OUT is nothing. We don't output"
8215060,8215540," anything."
8215540,8219300," And that is basically it."
8219300,8225540," After that, we want to pop that context from the context, right? So this is going to be"
8226100,8233620," context. Uh, pop. And we continue the execution, right? So the output becomes the expected inputs of"
8233620,8235460," the contract. So that creates a new contract."
8235460,8243700," Shit. I like that. So that's a very interesting way of doing that. And handle data on the stack."
8244500,8249460," Uh, okay. All right. So that's cool. And it printed"
8251060,8258820," actually one, which is not correct by the way. Something is screwed up completely."
8258820,8265140," All right. That's, that's cool. So we have two things in here."
8266660,8275940," Um, oh yeah, it's duplicated. Uh, okay. So it's summed up two numbers, duplicated that one number"
8275940,8284260," and just printed one and then it returned. Okay. That's actually correct. Almost."
8284260,8294020," Um, but if I print twice, not enough arguments for the print. Okay. That's very strange. Okay. Something"
8294020,8301140," went wrong. Uh, so yes. Oh my God. I'm already streaming for two and half of an hour."
8301140,8312260," All right. Let me, let me see. Um, of course I'm already tired. I'm kind of tired."
8312260,8322900," Let me do the following thing. I'm going to do assert false and I'm going to print the current context."
8322900,8326260," I just want to see what's the state of the current context and whatnot."
8326260,8333780," So in the current context, what do we have? Uh, what do we have in the current context? So this is going"
8333780,8344660," to be this thing. So this is the stack. Uh, and then we have IP six and outs. This is the expected outs."
8345780,8353780," Uh, all right. So we have two of these things, right? We have two of these things classic. Oh,"
8353780,8354420," shit. I see."
8354420,8361460," But is it classic bug? I don't think it's a classic bug."
8362980,8368340," I don't think so because we're popping the context out. So, and if we forgot to do"
8368340,8373140," city X plus one, uh, IP plus one, it would just go indefinitely."
8373140,8379460," So I don't think it's that that's the case. I don't think it's the case because as soon as we"
8379460,8383140," reach return, that's it. We don't do anything. So I don't think it's, it's the case."
8384340,8391620," That's definitely not the case. Okay. So we have, um, integer was introduced by plus and then another"
8391620,8401140," integer at the end. Uh, oh, I see what's going on here. Yeah. Checking out outs is not the same as"
8401140,8408340," checking out inputs because I see. So the, the bug is, was the mistake of me using this thing for,"
8408340,8413380," for type checking final thing. Uh, all right. So we have to do that properly. Right. So I want you"
8413380,8420020," to cheat a little bit, you know, forcing CD and stuff, but didn't work out. You can't reuse type"
8420020,8425700," check contract for checking expected outputs. You can use it for checking expected inputs. Right. But"
8425700,8431780," for the expected outputs, you can't really use it, uh, because you have to use up the whole stack. Uh,"
8431780,8439940," right. Uh, furthermore that makes it actually kind of easier. Right. So you can take the stack and you can"
8439940,8447380," strip off all of the locations, right? So you can do something like, um, for, um, what is that?"
8447380,8453620," So it has a type and then the token, but we don't give a shit about it. Uh, right. And we return on the"
8453620,8460820," types, right? So here's the thing. And then we compare it with the, uh, CTX outs. Right. Um,"
8461780,8467780," and then, uh, we're going to print it like that. Uh, so I'm going to do actual outs. Uh, so here is"
8467780,8473300," the actual outs. And this is what we have in the stack, actual outs. If those things are not equal to"
8473300,8480580," each other, we're going to say, uh, compiler error, uh, compiler error with expansion stack. So we're going to"
8480580,8493620," provide the, uh, the talking here, um, um, unexpected, uh, data on the stack. Right. So this is going to be"
8493620,8506580," that, uh, compiler nodes, uh, OP token, um, F expected, uh, this thing, which is the CTX outs. This is what we"
8506580,8514420," expected, uh, but the actual was this thing, right? And in that case, we just do exit one and we don't"
8514420,8522260," have to do CTX, uh, plus one. We have to do contexts pop. We're not continuing the execution of the current"
8522260,8527620," context. We're just straight up removing it, right? Because we're done with that context. It reached"
8527620,8534900," the return. It went to void. Right. So, all right. Can we execute that, uh, unexpected word context? Okay."
8534900,8540020," So that makes sense. Thank you so much. Uh, all right. Unsupported operand blah, blah, blah, blah."
8540020,8550020," Uh, where did that happen? Compiler diagnostic, uh, type check, uh, uh, compiler node, because that"
8550020,8558420," shit has to be location. Of course. Uh, yes, yes. Unexpected, uh, data on the stack expected, but"
8558420,8568740," actually, okay, cool. Uh, that is very interesting. So I suppose it didn't compare it properly."
8568740,8579060," Am I, oh yeah, I'm gonna do it. Okay. So actual outs, uh, actual outs. Uh, okay. Now we're talking,"
8579060,8584020," I'll go, look at that unexpected data. And it's like expected one integer, actual two integers,"
8584020,8589460," and we fail the compilation of our nation. Isn't that cool? I think it's pretty cool."
8589460,8599700," Uh, we can actually go even further. So, uh, we can give you the locations of those things."
8599700,8607540," I think that will be actually very useful. So for, um, this is not how we do that. Uh, because of that,"
8607540,8620340," we can just do it like this. Uh-huh. For, uh, token, maybe talk, uh, in ctx stack,"
8620340,8628740," and it's going to be compiler note, uh, this one is going to be simply, uh, out. We need to have a type."
8628740,8634260," Uh-huh. Talk. And this is going to be the type."
8634260,8640260," Uh-huh."
8643060,8651540," Can I just do something like this? Uh-huh. Well, I wanted to have something like wrapper,"
8651540,8658660," right? Yeah, there we go. Cool. So expected one thing, but the actual was one. That one"
8658660,8664820," was introduced by plus. The second one was introduced by plus one. That's basically what happened. Cool."
8666180,8671860," Uh, and now we have 69, 69. That's actually pretty cool. So that's precisely what I expected in here,"
8671860,8677780," right? So it's, this procedure summed up, uh, 34 and 35, duplicated it and printed it,"
8677780,8681860," and then it returned the duplicate, and then the duplicate was printed the second time."
8681860,8689540," So, yeah, so we have a type checking in here. So you can even do something like this, boolean,"
8689540,8695940," right? It will sell invalid argument type for the plus intrinsic. So, and, but if I drop"
8696660,8703460," the boolean in here, uh, it will say that yeah, expected data type, um, okay."
8703460,8710100," Uh, we need to work a little bit better on the error reporting, uh, messages, right?"
8710100,8718100," So, because they don't make much sense, but the functionality is there, right? The functionality"
8718100,8725860," is there. Um, yep. So expected data int, uh, unexpected data int, expected boolean."
8725860,8730100," Okay. So as you can see, the first thing here was expected as a boolean, but if I provide true,"
8730100,8734500," um, I think you cannot just probably true if you didn't include the, um,"
8734500,8740020," if you didn't include the standard input. So that means I'm going to do something like"
8740020,8745860," one, uh, cast to boolean. And I think that that will work. There we go. That fucking works. Holy"
8745860,8753700," shit. It works. All right. So what we need to do now, we probably need to go to the entire standard"
8753700,8762500," library and just fix the contracts there. Uh, okay. So we print those things somewhere. Let me see where"
8762500,8767300," we print all of that. Oh boy. I don't even know where I print all of that. Um,"
8767300,8772740," shit. I forgot where I print this thing."
8772740,8783300," Ah, uh, print contract. So is that where we print that? So we iterate, uh, through the whole thing."
8783300,8787860," Let me, let me check. Yeah. Yeah. That was the case. So it was for the, for debugging purposes,"
8787860,8795700," not enough arguments for this thing. Holy shit. It works. It works precisely as you would expect it."
8795700,8803940," Yes. Because you don't have this. Yeah. Right. Because in the memory copy, you accept the size,"
8803940,8808980," the pointer, the pointer, and you don't return anything. Right. You just don't return anything."
8808980,8815220," And that's why you just didn't have enough arguments for this thing. Holy fuck. That's pretty tough."
8815220,8823940," Uh, invited argument of a type GT. Uh, I wonder why? Because"
8825700,8836020," why is this an invalid argument? That's a good question."
8836020,8846260," Uh, because we, yeah, we basically consumed all of them, right? We consumed all of them and yeah."
8846260,8853700," So we probably have to just go to, uh, this place, invited argument type for GT intrinsic and just"
8853700,8860500," like debug this entire stuff. Um, right. And let's just see what's, what's there."
8860500,8871220," Um, I'm going to print a type and B type, uh, integer and pointer, integer and pointer,"
8871220,8879540," like how the fuck it is an integer. Uh, let me see. So you duplicate."
8883700,8908660," Um, so I would presume that, okay, here's the pointer and the pointer and we consumed both of them."
8908660,8914420," We consumed both of them. And then this is the zero and"
8914420,8922900," I'm not freaking sure. Like really, I think I'm already tired. I'm really, really fucking tired."
8922900,8929060," I don't really usually stream for that long. So it's difficult for me to continue, but we already kind"
8929060,8937700," of there, um, it's just like really unclear why the fuck, uh, the order of type, uh, reverse somehow,"
8937700,8944180," maybe. So if I put something like integer, uh, right. No, no, it's, it still says that."
8944180,8953620," So if I make all of them integers, uh, inverted GT, no, it doesn't do that. Is it something with dupe?"
8956420,8964100," It doesn't matter how I invert them. All right. Um, so it's something else. It's something super dumb"
8964100,8975460," that I don't notice. Uh, and I'm not freaking sure. 16 is broken. I don't think it's broken per se."
8977540,8989060," Um, so it's supposed to, yeah. Okay. So here's the first pointer and you push the second pointer in here"
8989060,8997060," and you just consume that and just should be nothing. Oh boy. All right. So let me see, uh,"
8998420,9012420," store 64, store 64. Um, okay. We're almost there. We're almost there. That's the, that's the most"
9012420,9019860," infuriating thing. It's I'm almost there. I'm just like too tired to, um, to fix this problem. Uh, is mem,"
9019860,9026420," by the way, wait, is mem copy the only thing that like complains about that? Right. So what if I just"
9026420,9031940," commented out, is it going to be the same for other things? Uh, all right. So put you,"
9031940,9043780," um, right. Specifically, uh, it will accept an integer and I suppose it will return nothing. Uh, right."
9046180,9052820," Because F put you, okay. So we'll have to go through all of these things and just like, uh, fix all of"
9052820,9063700," that. Uh, we'll just have to fix all of that. Uh, so yeah, but I think the main thing here is done."
9063700,9069380," Okay. So I've got an idea how to, uh, how to test all of these things. All right. So I've got an idea how"
9069380,9077700," the test of that we can go to nice program, right? So here's that, uh, and in here I can now to do this"
9077700,9084260," unexpected data on the stack. So we have data int pointer and so on and so forth. So then I can do memory,"
9085700,9095460," um, um, DST, uh, size of pointer, uh, and, uh, well, if in fact size of pointer is actually const eight,"
9095460,9106260," it's a const eight, then SRC, uh, and then I do DST 64. So that should result in that then do SRC"
9107140,9114260," 64. That makes sense. Right. And you're left with an integer. Then, uh, in the original STD, what do we"
9114260,9122180," do in the original STD? Uh, while we duplicate this, maybe we're going to do it like this while dupe, uh,"
9122180,9130100," zero, um, greater if, and then end, and in here we're going to do what we're going to just drop this"
9130100,9136900," entire thing and that should compile. Uh, uh, and that didn't really, oh, okay. So we can just"
9137860,9147140," dupe print and that should leave an integer, which we then drop an expected data and, uh,"
9147140,9160900," okay. Uh, expected boolean. And this is because we have a boolean in here, uh, which we drop and so"
9160900,9166740," on and so forth. Everything compiles. Okay. This thing works. Maybe"
9167860,9170260," there's something wrong with this shit."
9170260,9179300," No, there's nothing wrong with this shit. It could be that, um, in a standard thing."
9181140,9189300," Yeah. All right. So you have an integer, you duplicate it, you check it. So then we cast."
9189860,9200580," Oh, I know. I know. I know precisely what's the problem. Do you guys get it?"
9200580,9208660," Inc. 64 doesn't accept and doesn't return anything. So it was never consumed."
9210260,9217860," So the fix for this entire thing is actually like providing saying that inc. 64 accepts a pointer"
9217860,9222980," and doesn't return anything. That's the fix. Believe it or not."
9222980,9232100," or not. So this was the bug. So, and the reason we didn't see that, the reason we didn't see that is"
9232100,9239380," because we didn't continue checking things. Well, we probably need to remove the entire stuff. Otherwise,"
9239380,9244580," it will complain about the implementation, but nonetheless, uh, expected data."
9244820,9252660," Yeah. So if I remove this entire stuff, um, it doesn't complain about mem copy anymore,"
9252660,9257220," right? It doesn't complain about mem copy anymore, but it complains about the other things. So,"
9257220,9266100," essentially it didn't, it checked the consistency of this procedure before it checked inc. 64."
9266100,9274100," That is very interesting, which creates a very interesting situation. You see,"
9274100,9280020," so if we checked the inc. 64 first, it would have known that it's not a correct, like it's not proper"
9280020,9287060," thing to do. Um, how can we solve that? We can continue the type checking process until"
9287060,9296500," like we collected as many errors as possible. That one way we can do that. We can also try to check"
9296500,9302740," them in the order. Like we can build a graph in a particular order, but it's too, it's too complicated."
9302740,9309220," In Limeone time, why? We already solved the problem. We already have a proper type checking. It's just,"
9309220,9313860," it simply doesn't generate useful error messages and we need to figure out how to generate useful error messages."
9314740,9318340," But the type checking checks incorrect problems properly."
9318340,9325860," So, yeah, it's kind of interesting."
9325860,9333780," Yeah, so everything seems to be working. We can try to continue just working on the standard library and"
9333780,9342020," make standard library compile. Why not? But because the ultimate goal is to speed up the compilation of the"
9342020,9348660," port that port, right? So that's the ultimate goal. So put you accepts an integer, right? And it doesn't"
9348660,9354660," return anything, right? So I can just do int, he put you also accept an integer and doesn't return anything."
9354660,9361620," So we can do it like that. Uh, right. And we need to go to F put you an F put you accepts two things."
9361620,9369140," It accepts an integer and a value that you want to print, uh, negative numbers. Okay. So that way,"
9369780,9378900," uh, okay. So what do we have in here F put you. So maybe we should go through all of the procedures in"
9378900,9385780," here and just like fix them properly first because they're checked. Okay. I have an idea. I think I know"
9385780,9393780," why this kind of shit happens. I think I know precisely why, uh, that type check contract."
9395300,9406660," Uh, let's push the contracts into the context in a reversed order. Here's the thing. We parsed the"
9406660,9412020," procedures. We pushed them into the stack. So we started checking them from the bottom,"
9412020,9418340," which makes it kind of confusing, at least for now, let's reverse them and push them in reverse"
9418340,9423860," order. So they checked from top to bottom. So at least it makes sense, right? So it's not ideal"
9423860,9428020," solution, but it will make it a little bit easier because now they're checked from bottom to top and"
9428020,9433620," it just like, doesn't make any sense. Like what the fuck? Uh, so that could be a good temporary solution."
9433620,9436100," Uh, so dict item is not reversible. Thank you so much."
9439540,9450900," Isn't items basically a list or something. I mean, it's not that, uh, you know, often an operation. So"
9450900,9458980," uh, Cisco, okay, finally, right Cisco. So that makes a little bit more sense, right? Except what"
9458980,9467940," it accepts the size of the buffer, the pointer to the buffer and the file descriptor. And it returns an"
9467940,9476260," integer as the result, right? So we can take a look at the right, right Cisco. So size of the buffer buffer"
9476260,9484980," and the file descriptor. Cool. The read is the same. The read is the same. Okay, not enough arguments for"
9484980,9492260," system four. Okay, so now we need to provide the signatures for all of these things. So open at"
9493780,9501220," So open at, I think we're using like extended signature of open at, which is four, right? So we have a mode flex"
9501220,9508420," path and the deer of D and this entire thing returns to that. Okay. So that's going to be like this."
9508420,9519220," Uh, okay. F stats, F stats, F stats, F stats, F stats. Uh, and in F stat, we have pointer NFDS. So pointer,"
9519220,9526420," fd return an integer close. If I remember correctly, it accepts an integer returns an integer exit on the"
9526420,9531700," other hand, accepts an integer and doesn't return anything. So we can just say that it's exit int"
9531700,9539860," M map. M map is interesting. Uh, M map. Um, so there's a six parameters in here. Um,"
9540740,9545300," I've set F D flags, brought length address"
9545300,9557220," Uh, returns an integer. Okay. So that's cool. Uh, clock nano speeds. Holy fucking shit. Okay. Um,"
9557220,9568020," remain request, flex cock ID. Okay. So it's a pointer pointer integer. Uh, integer. There we go. So fork,"
9568020,9574100," uh, as far as I know, it doesn't accept anything, but it returns the child get P, uh, get P doesn't accept"
9574100,9587860," anything, returns the child. Uh, so exec exec V e, uh, accepts environment args file name returns an integer,"
9588420,9602980," uh, uh, wait for. Okay. Wait for accepts for arguments. Duh. Uh, pointer options. W status. Pid returns an integer."
9602980,9612820," Okay. Wait for it. Haha. Not enough arguments for diff mode. Um, well, yeah, so this one accepts an integer,"
9612820,9618580," returns an integer. That's easy. Integer integer. And that's the same for all of these modaflippers."
9618580,9625540," Uh, two, two, two, two. Okay. So checking all of that in that specific order was actually a good idea."
9625540,9631060," I think not enough arguments would you, ah, yeah, it's actually double"
9631060,9637060," integer and argument. I think this one accepts"
9638740,9645140," integer and returns a pointer if I remember correctly. I think that's what it does. Uh, okay."
9645140,9651540," Esther len. So it accepts a pointer, returns an integer. Uh, this one is interesting. So"
9651540,9657380," well, it accepts two pointers, returns an integer. Actually it returns a boolean."
9661380,9672580," So a sister to Esther. Okay. So it accepts pointer and returns integer pointer because the string in, um,"
9672580,9678820," in port is the size. So first size of the string, then the string itself. Okay, cool."
9678820,9687860," Uh, all right. So what do we have in here? F puts, if puts accepts the integer and then the size of the"
9687860,9691300," point, uh, the buffer and then the buffer. And I think it returns nothing."
9691300,9698580," Right. So it returns nothing puts, uh, just accepts into pointer. And this thing also just accepts in"
9698580,9704820," pointer. Okay. Anything else? Unexpected data on the stack. All right. That's cool."
9704820,9708500," What am I forgetting? I think I'm forgetting to do that."
9708500,9716020," Uh, all right. So Esther account actually upsets the pointer. So it's a pointer pointer."
9717380,9723860," Right. It's a pointer pointer pointer pointer pointer. This thing accepts the pointer returns an integer."
9723860,9730340," It accepts the pointer return the pointer. This one accepts integer pointer and returns nothing."
9730340,9741540," Uh, pointer pointer. Okay. Uh huh. So this thing accepts a pointer returns integer pointer. If I remember correctly."
9742660,9749220," Uh huh. So here we can clearly see what we accept. We can accept integer pointer and pointer and we don't"
9749220,9757300," return anything. We just save that thing. Uh, okay. Esther chop by one. Um, so I think we accept the pointer in"
9757300,9763140," here and don't return anything. So, and here we also accept the pointer. Don't return anything."
9763140,9771060," Uh, we're almost there by the way. Um, so we accept chop by delimiter. So delimiter is the integer, uh,"
9771060,9780580," pointer pointer. Cool. Uh huh. Esther queue. This one is an integer pointer, integer pointer, return boolean."
9780580,9785620," There we go. So this is actually a pretty good place for this kind of formatting."
9785620,9795140," Uh huh. Uh huh. Okay. Not enough argument is digit. So this thing accepts an integer returns a boolean."
9795140,9803380," Uh huh. Try parse. This one is cool. So it accepts integer pointer, but returns the parsed integer or an"
9803380,9810420," error. And I think error is a boolean. Okay. That's cool. So it tries to parse it from a string and"
9810420,9815860," either returns it or returns a boolean. Uh, okay. Enough, not enough arguments. I'll not accept boolean"
9815860,9829380," returns boolean. Uh huh. We annotated the whole standard library. Hello, sir. What are you doing? I'm streaming."
9829380,9838580," I'm an epic streamer. Uh, specifically I'm doing, I'm making my own programming language. Check out the, uh,"
9838580,9845700," the project commands. Uh, and there is a link there. I'm implementing my own statically typed"
9845700,9853060," compiled language in Python. Yes, that's what I'm doing. All right. So we annotated the whole standard"
9853060,9859700," library and the whole standard library checks. Let's try to compile the, uh, port port compiler"
9859700,9867620," and see in how many places it will fail now. Uh, all right. So unknown data type of set. Uh,"
9868580,9880740," that's actually pretty cool. So OP type. I feel so dumb when I struggle to send her a diff in the"
9880740,9888420," table and you do magic. Don't feel bad about it. I also have a hard time, uh, centering a diff in the"
9888420,9894340," table and I don't think it has anything to do with your intellectual abilities. I think the web is dumb."
9894340,9904900," Everyone struggles to send her a diff in a table because web standards are crap, not because of"
9904900,9911300," anyone's intellectual ability. I think you're pretty smart if you're able to do that. Uh, so don't feel bad"
9911300,9918180," about it. Uh, so we accept the type and, uh, so I suppose this is just like a pointer to pointer in"
9918180,9923860," here. We accept the pointer. It will return an integer and here we accept the integer and pointer and it will"
9923860,9936900," return nothing. Uh, right. If you do web and you feel dumb, that's not because you dumb. You're not dumb."
9936900,9944100," You're smart. Web is dumb. Actually, like web is really fucking hard. Doing web development is"
9944100,9947860," extremely hard and I have a huge respect towards people who's doing that professionally every"
9947860,9954580," fucking day because that shit is insane. Holy fuck. It's more complicated than it should have been."
9954580,9960180," I'm telling you, like developing your operating system is probably like easier than doing web daily."
9960180,9966180," Maybe not. I don't know. Maybe I'm exaggerating, but it's fucking hard. It is fucking hard. Holy fuck. Anyway."
9966180,9976020," Um, my biggest achievement in web development. Take a look at Sodin.org. Look at that."
9976020,9982100," It's my, it's my website. Sodin.org."
9985380,9992660," fucking centered vertically and horizontally. That's way more difficult than writing a statically typed"
9992660,9998740," compiled language in Python. That is way more fucking difficult. Um, anyway."
9998740,10004980," Uh, so, anyways."
10006980,10017620," So, this is the point, uh, pointer in and then point, uh, integer, um, integer pointer in."
10017620,10022580," There we go. Can we"
10022580,10027780," just do a line in"
10029060,10040580," that was dumb. Um, okay. Can I align in? There we go. Look at that. That's freaking ahigao. Uh,"
10040580,10046740," that's the most ahigao thing I've done. Uh, all right. So, this one is essentially a pointer and"
10046740,10058340," returns an integer. Um, okay. An expected keyword. So, okay. So, this one accepts a pointer, but returns"
10058340,10063860," nothing as far as I know. So, we can just do that. Uh, unknown data type. When you simulate the stack,"
10063860,10069060," uh, simulate stack push, I think we just put an integer and we don't return anything."
10069060,10078180," Uh, simulate stack stack count. Okay. So, this one pops, but it basically just returns an integer"
10078180,10085860," without accepting anything. Um, okay. Push operation. So, I accept integer integer and don't return anything."
10085860,10090820," So, I just push this entire thing. Uh, print operation. Uh, I don't remember. What does it"
10090820,10096420," accept? Does it just accept? I think it just accepts an integer and doesn't return anything. So, we can"
10096420,10101380," just do that. Uh, integers are not allowed in the procedure definition. Thank you so much."
10101380,10108500," Dump OPs. I don't think it does anything. Strings are not allowed. Compile OPs. So, this is,"
10108500,10117620," we're getting closer chat. We're getting closer. Uh, data type. So, here I'm going to accept the pointer and"
10117620,10125700," I'm going to return an integer. Uh huh. So, here when I push something, I push an integer onto the stack."
10125700,10133140," I think that's it. And here I return some integer, return an integer. An expected keyword is terastat with."
10133140,10139460," Okay. So, this one is interesting because I already kind of annotated something. Uh, so, input prefix count"
10139460,10146420," integer pointer, integer pointer. I think that's it. And this thing should return a boolean if I'm not"
10146420,10152660," mistaken. Right. So, something like this. So, integer pointer, integer pointer, boolean. Um, well, you can"
10152660,10162580," actually go now and just do something like this. Maybe it's like prefix, uh, input and this is the"
10162580,10168180," result. Okay. So, this enables actually pretty good annotation in here. I really like this syntax. Uh,"
10168180,10175700," all right. Unexpected keyword. Remove comment. Okay. Um, so, output. I think it's a pointer pointer."
10175700,10182260," And I didn't think it actually returns anything. Right. It's just like it removes it and saves it into"
10182260,10190420," a separate thing. To dupe. I remember this one, uh, over, over. Right. So, there's only one. Uh,"
10190420,10197300," to drop is just like a drop, drop. We don't even use these things like very often. Uh, memory sets. Uh,"
10197300,10202020," so, here's the integer, integer pointer. Doesn't really return anything. So, might as well just do it one minute."
10202020,10210980," Um, unknown data type. Uh, okay. Put location. I don't remember. Uh, I think it accepts a pointer."
10212260,10215780," Yeah. I think it just accepts the pointer and just prints it or something."
10215780,10222900," Uh, no data. So, this one accepts a pointer and returns a boolean, checking whether the string is"
10222900,10232980," empty or not. Uh, next line. So, this accepts a pointer to the Lexa. Uh, this one, I suppose it accepts the"
10232980,10241380," pointer to the token. Uh, token. Then the pointer to the Lexa and returns the boolean indicated whether you still"
10241380,10247300," have a token or not. We have a proper tokenizer for this thing. Okay. So, map a file. Uh, here,"
10247300,10258980," we accept a pointer, which is the file path as the system. Uh, and then we return a string. Yeah,"
10258980,10266900," basically a string. All right. The content of the file. Uh, there we go. So, it has to be like this. Uh,"
10267780,10274660," unexpected keyword Lexa file. So, it accepts just a pointer and I didn't think it returns anything. So,"
10274660,10281700," should be fine. Should be freaking fine. Unexpected keyword. Parse file. This one"
10281700,10295140," also just accepts a pointer. Uh, usage only accepts FD. Uh, main doesn't accept anything. Unexpected data on the"
10295140,10307860," stack. Uh, that's very interesting. So,"
10307860,10321140," Hmm. I think this one just returns an integer. Uh, oh, I know what's up with that. So, because before,"
10322100,10328420," Oh, shit, here's an interesting point. Here's an interesting point. Remember how I said that we"
10328420,10333460," always go inside of the procedures, uh, to check its body, right? We always go inside of the procedures."
10334020,10340500," And one of the interesting consequences is that you can write a procedure that is kind of generic,"
10340500,10347940," right? So, you can, uh, write a procedure F that accepts any type and always cast that type to integer"
10347940,10356500," and just adds, uh, 69 or something. So, it doesn't care that, uh, the input is a boolean or integer or"
10356500,10362420," pointer. It always casts there. And since we have a type inference, the execution always goes there and,"
10362420,10368260," you know, confirms that, yeah, you can put any type in here. We can't do that anymore. Uh, because in,"
10368260,10374020," in SIM stack, in SIM stack, if I take a look at this stuff, where is the SIM stack? Yeah. This is"
10374020,10382020," literally what we did in here. Yeah. So, we accepted anything and we always casted it to integer and that"
10382020,10388420," worked. It doesn't work anymore. Um, so we have to do something about that. We definitely have to do something"
10388420,10394500," about that. Uh, so one of the things we can do, we can just cast that to integer, right? So, we'll just do"
10394500,10401540," that and cast it to integer. Um, so, and I suppose I'll have to do that like every time for all of these"
10401540,10410020," separations. So, we have to cast boolean. Uh, right. Let's see. Um, hmm."
10413940,10426420," So, if I do stack pop, uh, Oh, cast integer, sorry. We need it. Of course, uh, cast integer. So, I wonder how"
10426420,10431460," many of such things we have in here. Might as well, actually, I know all of these separations, right?"
10431460,10439060," Uh, maybe, maybe we're going to rely on the compiler to tell me all of these places. There should be not that many"
10439060,10445140," of them. It's only the logical operations that require this kind of stuff. Uh, okay. This thing"
10445140,10453940," doesn't accept any pointer. Okay. Unexpected data. Um, so what does it say? Integer expected pointer."
10455860,10462180," Uh, where did we expect the pointer? So, map."
10462180,10470660," So, fd is that content count null address."
10470660,10482660," So, I think I did a fucky-wacky somewhere in the standard library of mmap. Is that how mmap works?"
10483860,10490340," Uh, so all of these things are pretty much integers, right? Except the last one. So, the last one is a"
10490340,10498420," pointer, but null is a pointer. If I remember correctly, right? So, it is a pointer. Uh, so,"
10498420,10507060," yeah, it's, it's not what I think it, it is. Oh, oh, I know. So, it's, it's a bug in this procedure."
10507060,10513140," It's a bug in this procedure, right? And where is it defined? It's defined in the standard library."
10513860,10520340," So, it accepts. Oh, I see. I see, I see, I see. So, that means I have to cast this."
10520340,10526820," All right. I don't know how it worked for so long."
10526820,10542260," So, the question is, so, we have a proper port port compiler. Let's actually, uh, run the simulation on"
10542260,10549940," some of the stuff, uh, on intrinsic specifically. Okay. So, we've got a working compiler."
10549940,10557620," So, and it type checks with the type signatures. That's cool. And if I put some crap in here,"
10557620,10564740," right? So, 34, uh, it should not compile. Yeah, it should not compile. And look at the speed of the"
10564740,10572500," compilation. Okay. So, it generates port.asm relatively quick, but now the bottleneck of the"
10572500,10580180," compilation is NASM. There's something with NASM that makes it super slow. We can actually compare the,"
10580180,10583220," the performance of this entire thing. So, there's a lot of stuff in here."
10583780,10591540," Um, okay. So, let's, let's do a committee committee. Implement. Implement, uh, prog signatures."
10591540,10597860," Prog signatures. Right. I'm going to go back to the master and we're going to take a look at the"
10597860,10603780," performance of the compilation. So, this is the performance of the compilation before the procedure,"
10603780,10604580," uh, signatures."
10611620,10613620," Waiting. Waiting. Waiting."
10613620,10631140," Right. 22 seconds. 22 seconds. Uh, right. So, let's go back to prog signature and let's try to compile this"
10631140,10641460," thing. Uh, two seconds. See Python. Well, that's the importance of using the right"
10641620,10649860," data structure. Remember chat. Python is not slow. You just have to use the right data structure."
10649860,10652820," That's right. Uh,"
10652820,10658020," I don't know what we need to do about a NASM. I actually looked into NASM"
10658020,10664980," and apparently NASM by itself is a very slow compiler, uh, assembly actually. NASM slow."
10665700,10671460," Uh, because I knew about this problem for quite some time because you can see that problem being"
10671460,10677700," apparent when you just disable the, uh, you know, the type checking. So, it instantly become apparent."
10678260,10684820," Um, so, and apparently NASM is, is pretty slow. There is like a, a thread on the forum, NASM forum, 10 years"
10684820,10693780," ago, uh, talking about like a program with less than 4,000 lines of code, right? So, porth, porth dot"
10693780,10705780," other, porth dot other is, uh, 24,000 lines of code, 24, 4, 20, 24, 4, 20. That's the shed that is generated"
10705780,10711460," by our porth compiler. That that's a, that's a lot of shed difference. So different strings and also, uh,"
10711460,10716980," interactions and whatnot. And, and that takes like a 20 seconds to compile. They had a program that is"
10717060,10726420," less than 4,000 lines of code that compiled 10 seconds. So it is kind of a known problem for quite"
10726420,10736580," some time, NASM being slow. Right. Which makes me think, maybe we should try a different compiler instead."
10736580,10743940," So the compiler actually is like, you know, assembly, not compiler. Uh, the assembly is like a very small"
10743940,10751780," part of our compiler and it's actually like a separated easily swappable part. Right. So, uh, generate"
10751780,10757620," another, there we go. So there's like a single function that just generates, uh, you know, assembly."
10757620,10765140," We can try to maybe make a stream where we, uh, like try out different assemblers, uh, and see which"
10765140,10769620," one is the fastest. Right. So you just have to re-implement this thing for different assemblers."
10769620,10775060," And for example, for something like fuzzin, uh, or any assembly that is using like Intel, um,"
10775060,10779860," dialect, I think it would be easy to implement. So there will be like a little bit of a difference"
10779860,10786900," in the syntax, but, um, yeah, we'll see. We'll see. It's kind of interesting, but we finally have"
10786900,10793380," like a proper, uh, procedure signatures and, uh, there's, they're rough around the edges because of the"
10793380,10798100," error messages and stuff like that. But I'm going to smooth out the error messages off screen. I'm"
10798100,10803140," going to try to make the error messages a little bit nicer and the whole type checking process actually"
10803140,10809220," simplified dramatically. It in fact simplified dramatically now. So we don't do like a very"
10809220,10814980," complicated, like tracking of the call call paths and we don't go inside of the procedures. Like it's"
10814980,10821860," way simpler than it was before. And I think it was worth it. I think it was worth it. Uh, so I also need to fix the"
10821860,10827380," tests, but I think I'm going to do that off screen already. So, all right. Does anyone have any questions"
10827380,10836580," about what we've done so far? Any questions, any epic questions from, from epic putters? Was and when?"
10836580,10839940," I don't know. It's on the list, but I don't know when exactly we're going to do that."
10842820,10849540," Um, to, to, to, to, to, to, to, to, um, um,"
10849540,10859300," um, I wrote some programs in ports yesterday in the compilation was really slow. What caused that and"
10859300,10867140," how is it fixed? Uh, so it was slow because we used a wrong data structure. We used list instead of deck. As"
10867140,10882820," as soon as we replaced list with the deck, it became, uh, 10 times faster, 10 times faster."
10882820,10890260," Um, we have arrays in ports. Well, you have a memory. If you have a memory, you already have a race"
10890260,10896020," because arrays, uh, memory is basically an array of bytes. So we already have arrays."
10896020,10911780," In your website, there is a something game in C plus plus one that the schedule is irrelevant. It's"
10911780,10930260," not a reflection of the reality. Um, a race or just fancy point to math. Exactly."
10939460,10944020," Didn't you want to delete the schedule thing? Yeah. I want to do a lot of things actually"
10944020,10947860," deleting the schedule is one of the things I want to do, but there is a lot of them."
10947860,10954740," Uh, yeah, we are going to have the support for floating point numbers. Of course, uh, I didn't"
10954740,10960180," implement any floating point numbers because the goal right now is to make the compiler self-hosted,"
10960180,10964180," right? And to make the compiler self-hosting, you don't need the floating point numbers."
10964180,10969140," You usually need floating point numbers. If you're doing some sort of like a, uh, graphics"
10969140,10976420," or physics simulation or stuff like that. Right. Uh, I do plan to do graphics in port with like"
10976420,10983140," OpenGL and stuff like that. And once you go into like GPU stuff, you definitely need floats. Um,"
10983140,10989380," will you implement generics? Yes. I will implement generics. Probably it's going to be a separate"
10989380,10995780," stream where we introduce generics and bring back the to dupe and to drop, uh, functions."
10995780,11003460," Or if you're a bank and you want to round your customer money away."
11003460,11013780," Classic. Yes. Yeah. Flows are useful for banking and for storing currencies. Of course. Yes. Everybody"
11013780,11026260," knows that. Uh, what's your most anticipated feature of course self-hosting because I can finally remove"
11026260,11032180," Python from my system and I don't have to program in Python anymore. That's the most anticipated feature"
11032180,11040900," of port not using Python. Uh, port will have generics before go confirmed. Yes. We're going to have"
11040900,11047700," generics before go. I'll try to implement them as soon as possible. So we have them before go."
11053060,11058900," Are you going to be doing less of stream after somebody after that email you got? No,"
11058900,11064980," I'm going to do as much of stream as usual. It's just like every time somebody emails me and tells me"
11064980,11069700," like, what the fuck is that? I'm going to do a separate stream explaining it. That way I never have"
11069700,11076020," to explain things that are not needed to be explained. Right. So nobody complained. Everybody"
11076020,11080020," understood everything. So no need to explain anything. It's just pretty convenient. I think"
11080020,11085780," Are you, I'm sorry, are you planning to have a local scope eventually?"
11085780,11095060," What do you think this is?"
11095060,11105540," You're planning to optimizing the assembly output at some point. Yes, it is in the readme."
11106020,11109700," We have a plan in the readme actually."
11109700,11121220," Uh, so, so here's the fourth plan, right? To be compiled, native, stack-based, Turing complete,"
11121220,11128100," statically type, self-hosting. We're currently here. We're currently here. So being optimized is,"
11128100,11133620," you know, one of the things, you know, one of the things I would like to actually add if it's cross"
11133620,11138580," platform. Because it's not right now. It can only work on my machine."
11138580,11146180," It's not just can work only on Linux. No, it can work only on my machine. That's how cross-platform it is."
11146180,11149140," Right. Um,"
11154580,11164660," Yeah, it works on my machine. It's actually pretty good. How cross-platform your program is. Like it works on my machine. That's how cross-platform it is."
11169300,11175860," Have you checked how many redundant push pairs are now in the other output? No, I've not, because I don't care."
11175860,11191060," Um, because I'm doing self-hosting. I'm not doing optimizing. Optimizing is after self-hosting. So anything related to optimization."
11192020,11202260," I don't care. I don't care. I don't care. I don't care. I don't care. I don't care."
11202260,11205460," I don't care. Does anyone have any other questions?"
11211620,11217780," Um, is it possible to write a native fork bomb in forth? I have no idea. I don't know forth."
11217780,11222500," Uh, I know forth because I wrote it, but I don't know anything about forth."
11222500,11227860," Um, it is possible to write, uh, a native fork bomb in port, right?"
11228420,11238100," In fact, it has a fork Cisco, right? It has a fork Cisco and I use it to actually run external processes from fork. So as you can see here is a fork."
11238100,11243140," Uh, forth bomb in port. Yeah."
11243140,11251220," Um, is type checking optional right now? Technically yes."
11251220,11256340," Uh, because you can provide unsafe flag and it will remove the type checking."
11256980,11261300," So it kind of is optional, but I'm not sure if I'm going to actually keep it."
11261300,11262740," Um, so"
11262740,11267700," I don't know. Maybe, maybe I'm going to just keep this flag just in case."
11267700,11274820," Um, because with that unsafe, you will be able to do things that are not particularly possible."
11274820,11279220," Uh, right. For instance, uh, let's actually write full port."
11279220,11284740," Right. And you have a procedure F maybe full, right?"
11285700,11293460," That, excuse me, I guess it will accept a single integer, right? And if the integer,"
11293460,11294820," um,"
11294820,11305380," if the integer is less than 10, then it will return 69. Otherwise it will return 69 for 20."
11305380,11313860," Right. So this thing is impossible to write in typed forth, right? Because like, depending on the runtime"
11313860,11320660," parameter, uh, function returns variable amount of, uh, elements, right? It returns a variable amount of"
11320660,11327780," elements. Uh, furthermore, maybe we can actually put something like zero, uh, zero, right? And then"
11327780,11330740," I can do five. Um,"
11333460,11340500," let's actually do something like this. Uh, yeah, five full. And then, um, while dupe"
11340500,11349700," not equal to zero, we're going to print that thing. And there we go. And after that, that's it. So this"
11349700,11354580," kind of stuff is not really possible to implement in typed forth. This is not going to ever type check"
11354580,11360180," because we're using like a very dynamic features, right? We're checking whether it's less than 10 or"
11360180,11365380," equal to 10 and greater. And depending on that, you have a different amount of elements. And then we"
11365380,11372580," print those elements until we reach the zero. Um, and, uh, in a tab forth, it's won't be able to like"
11372580,11380100," do that. Uh, so let me actually see if we can compile it, uh, with untapped forth. So full forth,"
11380100,11386180," and it seems to be working. So you have 69, but if I put 10 in here, uh, it prints, um,"
11386980,11392980," yeah, it actually didn't print anything properly. That's very strange. What if I put 20 in here?"
11392980,11397940," Huh? So dupe not equal zero."
11397940,11405700," Strange. I don't know why this doesn't work. I would expect it to work, but it doesn't work."
11407380,11419860," So, uh, probably because, uh, this is what I have to do. Um, so we consume, ah, I see. Oh yeah, I see."
11419860,11425380," So yeah. So one of the things, one of the problems you have with untapped forth is that there is no type"
11425380,11430900," checking errors. So you keep confusing operations and shit. Okay. So here is that you have two elements in"
11430900,11437460," here. And if it's less than, uh, than 10, uh, you have one, right? You see, it's a very dynamic"
11437460,11443700," feature and this kind of stuff, if you try to type check it, it will not compile, right? Because like,"
11443700,11448340," first of all, you didn't provide any parameters in here. Second of all, you don't know how many"
11448340,11453620," elements you return two or three. You just don't know what to put in here. You return three of them"
11453620,11458820," and it will tell you, well, you kind of like don't have enough arguments. You expected three"
11458820,11465220," arguments, but they have two in here. Right? So it's just like, what do you do? Right? So you can't"
11465220,11470100," even properly type check this problem, but if you disable type checking, this is a valid program."
11470100,11475700," It's a very dynamic program that just depending on the, uh, on the input parameter, which could be"
11475700,11483060," parameter input parameter, which could be a runtime parameter can do different things. And this basically"
11483060,11490340," creates like two different languages. Uh, and I'm still thinking, do I want to like support both of"
11490340,11497300," the languages? So we have typed and untyped forth, uh, or do I want to forbid untyped forth completely?"
11497300,11505380," Uh, I mean port. Uh, what's interesting is that untyped port is more like fourth. Fourth is very much"
11505380,11512580," untyped dynamic language, right? Port on the other hand is very like strictly typed. So maybe for the fourth"
11512580,11519780," developers that like the dynamicness of fourth and want to use that dynamic, the dynamicness in port,"
11519780,11528020," we can actually, uh, leave, uh, this flag for them, I think. And what's cool is that in unsafe, uh, you"
11528020,11532660," don't have to provide signatures for anything. So your, uh, procedure signatures look like this,"
11532660,11540260," just the prog name in, and there we go. So it's like, uh, it can be either dynamic or static. So"
11540260,11547780," I mean, sounds like a good idea to actually like have two variants of the, of the language. But, uh,"
11547780,11554660," if you, if your program relies too heavy on dynamic features, you won't be able to make it like, uh, static,"
11555220,11560660," right. So it basically makes it two different languages semantically. They're syntactically"
11560660,11566900," same, but semantically they're different. Maybe we want to do something about that. No. Um,"
11567940,11575540," so I have two ideas. So maybe you're going to annotate files, uh, like with some sort of a"
11575540,11581140," problem, right. Dynamic, right. And that thing is going to be dynamic port or maybe static. And this"
11581140,11587700," entire thing is going to be static port. Um, or maybe you would be able to annotate specific procedures or"
11587700,11595460," specific blocks, right. Disable the type checking in that block, right. Or maybe when you do something"
11595460,11603220," like, uh, like unsafe and you can in unsafe, you can specify what are the input parameters and what are"
11603220,11609060," the output. So inside of this entire thing, there is no type checking, but outside the input and output are"
11609060,11613460," assumed to be like this or something like that. There is like a lot of things you can do about that. It just"
11613460,11620340," depends, uh, like what, how exactly people use this language for what. So there's like any, you know,"
11620340,11626740," there's a lot of, um, room for discussing the colors of the bike shed. That's what basically what I'm trying"
11626740,11635460," to say. Are you going to add linking with C? Yes. We're going to be, uh, linking with C because I'm planning"
11635460,11641140," to do graphics in this language. All right. So I guess that's it for today. Thanks everyone. Who's watching"
11641140,11648100," me right now. I really appreciate it. Have a good one and I see you next time. Uh, so I'm not sure what"
11648100,11653620," we're going to be doing next time because I'm pretty, pretty much have everything to continue, uh, re-implementing"
11653620,11661380," portion itself. So maybe the next stream, hopefully the next stream is going to be, uh, me taking a couple"
11661380,11668500," of last steps in making this language self-hosted, right? As I already promised, I'm not going to make"
11668500,11674100," it self-hosted off screen. I'm going to just keep developing it. And once it's almost there, I'm going"
11674100,11680100," to do the last steps on the stream so we can witness this language compiling itself for the first time"
11680100,11685060," on the stream. I want to capture that moment. I want to see that moment together with the chat."
11687700,11693460," All right. So, uh, we'll see. Maybe if I encounter some other problems that worth streaming, I'm going"
11693460,11699540," to stream them before that, but yeah. All right. That's it for the day. Thanks everyone for all the"
11699540,11705700," subscriptions, donations and beats. I really appreciate that. Have a good one. And I see you next time."
11706500,11721300," Love you all. Mwah."
