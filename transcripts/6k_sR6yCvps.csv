start,end,text
160,6640," looks like we're live hello everyone and welcome to yet another recreation programming session with"
6640,15040," azuzin let's make a little bit of an announcement and officially start this stream as usual uh red"
15040,22000," circle live on twitch and what are we doing today on twitch.at television website today"
22000,28560," we are developing a new language in rust for erlang vm and the reason we're doing that is because"
28560,33280," i want to right that that's literally the reason because i want to don't ask me why are you developing"
33280,39600," the language because i want to i can't do that and you cannot that's why i'm doing that that's"
39600,46320," what i'm doing that to dab on you to dab on you so right i'm joking uh so i'm gonna give the link to"
46320,52080," where you know that twitch.tv/studying and i'm gonna ping everyone who's interested in being pinged there"
52080,56240," we go the stream has officially started i'm not even sure if i'm gonna actually succeed today so"
58160,63840," i'm i'm being preemptively cocky uh but that's fine that's fine so what we did we do on the"
63840,69760," yesterday stream and not really yesterday stream but the the previous stream right so we did a very"
69760,76400," simple thing we uh created a simple program uh called hello right so and then we compile it into"
76400,84720," beam uh you know bytecode and beam as you know as you know is a virtual machine for erlang right so and"
84720,90960," a simple binary file and stuff like that so we took uh a pretty cool book and i really recommend to check"
90960,97200," out the book it's called the beam book the beam book uh right and it's a basically a book about"
97200,104400," internals of erlang right and using that book using some uh snippets from that book we implemented a simple"
104400,112160," parser for the beam file format right a simple parser for the beam file format uh so and essentially we can"
112160,118240," even take a look at how it works right so here is a simple thing we already compiled it uh right so that"
118240,125520," created the module hello uh we can take a look at the module info uh of that module right so and the most"
125520,131920," important thing uh that we can see in here is that it imports the function hello uh which means that i"
131920,135920," can actually call this function and it will tell me hello world there we go the function seems to be"
135920,144640," working so uh here is the parser right so off screen i actually implemented uh parsing for the rest of the"
144640,149280," important chunks i think i have not fetched it so let me actually quickly fetch it"
150480,156960," uh right so i'm gonna merge that uh and open it up one more time so let me revert the changes"
156960,162400," so yeah so essentially this parser parses all of the important chunks right as far as i know there"
162400,169920," is like four four or five important chunks so it's the code chunks which contains the byte code the"
169920,177760," instructions the encoded instructions the atom table uh atom table is basically a list of atoms which are"
177760,185200," symbols which are just strings right it's a list of strings uh then the list of imports the functions"
185200,190720," that your module is going to use the list of exports the functions that your module is exporting and the"
190720,197040," list of strength literals right so that's basically sort of like the the main chunks that we're operating"
197040,202240," with right so these are the main chunks we're operating with uh right so and i can compile this entire"
202240,207680," thing so it exports the function read which allows you to read the beam file right so we can do hello"
207680,214720," hello beam uh right and we can see the internals of uh these five chunks here are the atoms here is the"
214720,220800," code we didn't really we don't really parse the code instructions right the code uh the instructions"
220800,228640," themselves uh are encoded in a very anal format it's so freaking anal that i decided not to implement it"
228640,237280," myself right uh right so it's not really that anal but it's a little bit anal it's called compact uh term"
237280,244720," encoding right it's it's called compact term encoding and essentially uh the arguments right they have"
244720,253760," a value some sort of an integer value uh and a tag associated with them right and the purpose of this"
253760,262240," encoding is to cram as much information as possible in the least space possible right so and essentially if"
262240,271440," if you have a value that is i think less than 16 if you have a value that less than 16 the tag and the"
271440,280800," associated value fit entirely into the uh into a single byte a single byte will contain a tag and a value"
280800,287200," that is less than 16 because tag is stored in the first three bits of the bytes"
287200,295680," yes yes that's how fucking anal it is when i said that this format is anal i meant it it's it's a very"
295680,302480," anal format uh right so and if you have a value that is greater than 16 they use slightly different"
302480,309600," encoding methods right so i think it's up to two thousand or something up to two south thousand after"
309600,316000," two thousand they use a different schema that expands the amount of bytes so it's basically the arguments"
316000,322480," have a variable length and stuff like that so the purpose of this entire shed is to preserve the amount"
322480,330400," of disk space it is needed to preserve the amount of disk space so when the loader loads up this instruction"
330400,338720," format it actually expands each individual argument to be word aligned so during the execution it's not that slow"
338720,344400," right so it is needed to sort of like you know cram as much uh information as possible within like a"
344400,352880," uh small amount of space because i suppose um this code maybe this is my hypothesis by the way i don't"
352880,359360," know for sure but maybe this code is meant to be also transformed over the network because it's a language"
359360,366240," for distributed systems and you can hot reload over the network so maybe to save some space let's save some"
366240,371920," traffic on that or something like that i don't freaking know this language is from 80s i don't know the"
371920,377360," decision process of this kind of language but it is what it is and it isn't what it isn't luckily there"
377360,384480," is like already algorithm baked into erlang that allows you to encode arguments in a certain way"
384480,389520," they don't really expose the algorithm for decoding the arguments that but they expose the algorithm for"
389520,395920," encoding them right if you go into the erlang there is a module called beam asm all right so let's take a"
395920,402960," look at what it exports module uh info so what does it have uh it has uh quite a few i think it doesn't"
402960,410640," have that much right the most important thing it has is an encode right so you can do beam asm encode"
410640,416000," and you can provide the tag you need to know the number of the tag and the number of the tag is one of those"
416640,421440," right so essentially literal is going to be zero integer is going to be one atom is going to be two"
421440,426560," and so on and so forth right so let's say we're going to actually encode something like literal and"
426560,432400," we want to encode a number two so and this is the thing that you've got right and it's going to be a"
432400,439200," single byte uh up until i think 16 right after 16 like starting from 16 is going to be two bytes"
439200,444960," right and i think after like 2000 is going to be like more than uh two bytes and so on and so forth"
444960,451280," so it's basically extends uh right so and you can use this kind of stuff and there is also like a list"
451280,459200," of different tags that you can use for this kind of thing uh i think it's all located near the beam asm"
459200,468720," right so let's actually find out so let me find file file with the name beam asm uh right what do"
468720,475120," we have in here okay here it is so here's the beam asm and there's also header right so if we take a"
475120,482080," look at this entire thing uh uh op code yeah there we go so there are op codes here are all of the tags"
482960,489760," so there's eight tags in here for different types of things and uh right there's also op codes for"
489760,495040," different instructions in here here are different instructions of the erlang virtual machine"
495040,502800," so this entire function tells you basically given the um given the name of the instruction and its"
502800,509840," arity it gives you its op code that is within the bytecode right that is within the bytecode there's also"
509840,517120," op name that does the opposite thing given the number it gives you the uh the name and the arity"
517120,522960," right so yeah that's basically the kind of stuff that we will need today the kind of stuff that we will"
522960,530560," need today right so uh and within the module right as i said we have atoms we have code we don't really"
530560,536480," have any strings so we have imports and we have experts and so on and so forth okay we can kind of"
536480,543920," parse the beam files we can kind of parse the beam files so today i would like to do an opposite thing"
543920,552960," today i would like to do an opposite thing i want to generate a beam file from scratch that is loadable"
552960,559200," by erlang virtual machine uh i could do that in erlang sure i could do that in erlang and it's actually"
559200,565680," kind of convenient because again there is a such thing as uh beam awesome encode so if i need to"
565680,573520," start encoding things i can just use this function but i think it's kind of unsatisfying i feel like"
573520,580480," it's a little bit unsatisfying i feel like the file the beam file has to be generated by something that is"
580480,587120," entirely not erlang so the sequence of bytes must be generated by something that is entirely not erlang"
587120,593680," and i decided to go with rust i guess uh rust sounds like a reasonable thing to to use of all this kind of"
593680,601040," stuff right so the goal for the day stream is going to be uh to write a rust program that generates a"
601040,608480," sequence of bytes that is going to be recognized by erlang virtual machine as a legit erlang module"
608480,615440," right so and maybe generate some functions that perform something and stuff like that right if we"
615440,619760," manage to do that if we manage to do that i'm going to declare today's stream as success"
619760,625440," right and once we have something like that making a programming language out of that is going to be"
625440,631520," actually rather easy right basically implement like a lexard parser and just generate uh the"
631520,641120," final code based on that syntax right that you parsed and stuff like that so uh yeah so that's basically"
641120,646080," going to be the goal for the day stream write a rust program that generates a b module we already kind"
646080,652320," of know how b modules work and if we manage to load it up and maybe even execute some functions out of that"
652320,660160," module is going to be a success for the day stream sounds good sounds gucci sounds a tamaguchi let's go"
660160,667120," so uh let's go ahead and uh create the the file so the language uh the language that i want to create"
667120,679280," i'm going to call it bada uh you will know why a little bit later uh you will know you will know why a"
679280,688880," little bit later so i'm going to do bada rs uh right so and let's first create uh you know hello world"
688880,693120," so this is going to be hello"
693120,702160," bada i guess i don't know and let's just compile that rust c uh bada rs and uh there we go"
703120,710240," let's just wait there we go so we got hello world how about that how about that no cargo why do you need"
710240,710720," cargo"
710720,722400," listen listen listen listen listen listen we are generating a sequence of bytes from we're just"
722400,727040," generating a sequence we're just generating a sequence of we're just generating a sequence of bytes"
728240,735440," i know in 2023 with the current software development standards it sounds insane and it feels like you"
735440,741920," need to have like a uh very complicated framework to do that but this is the capabilities that rust has"
741920,750320," in a standard library in a standard library it has the capabilities to generate the bytes i know it sounds"
750320,759360," insane but trust me trust me it is possible it is possible right how can you generate a sequence of"
759360,764080," bytes right first of all you need a container for those bytes right so let's actually create something"
764080,770320," like bytes uh right so this is going to be vector new right so and let's say this is going to be vector"
770320,776000," of bytes there we go we have a container for bytes we have a container for bytes so the next thing we want"
776000,781120," to do we're going to just push some bytes into that container 69 let's actually do that three times why"
781120,788160," not so and if we open up the documentation uh for for rust for the standard library right so let's actually"
788160,794320," take a look there is a very cool package within the standard library standard library standard library"
794320,802240," uh it's called right fs right right so uh let me go so what this thing does it accepts the path"
802240,808880," and the contents which is uh something that can be interpreted as a reference to a slice of bytes"
808880,816400," so essentially what i can do now i can do fs all right and let's create uh for for the name with the"
816400,821440," name for the file right so it's it's going to be butter uh and the extension is going to be beam"
821440,826560," that's exactly why i decided to call language butter right so because the final file is going to be butter"
826560,832560," beam haha very funny anyway so and then you just provide the the reference to this entire thing and"
832560,839840," then you say uh expect uh maybe we're going to even extract this entire thing to file path uh right so"
839840,845360," file path like this so and we say that we expect this specific operation to not fail"
845360,850000," uh right i'm going to try to compile this one more time right try to compile this one more time we have to"
850000,856320," import this specific thing stdfs stdfs uh right this entire thing has to be mutable because we're pushing"
856320,862720," it we're mutating this entire thing and there we go it generated file a butter beam and if we open it"
862720,870800," uh right it's we hear this about a beam and we open it in hex in hex mode it's 45 45 but it's in hex"
870800,878960," right if you convert hex uh right into into decimal right so 45 it's 69 so it's basically 69 three times"
878960,886960," and all of that without any third party dependencies using only the standard library i know it sounds"
886960,894400," insane but look how much shit you can do just using standard library without cargo without"
894400,904240," over complicating thing just vector and the right function repeat after me just vector and right function"
905680,911760," oh you you want to you want a framework you don't need framework you don't need traits you don't need"
911760,922160," hierarchy just vector and right function repeat after me just vector and right function it's that simple"
922160,930160," you don't need anything else you don't need to over complicate anything just vector and right function get it"
930960,945440," okay and that's how we're going to be generating so with these tools with these two things just vector"
945440,953200," and right function we will try to generate a file that is going to be recognized by erlang as the the module"
953920,958000," right so that's going to be the goal for today stream that's going to be the goal for the stream"
958000,961360," all righty"
961360,972400," so how do we generate uh the thing so right now if i try to like even load this file uh even load this file"
972400,979600," with erlang it's not going to work as far as i know in erlang there is a module code right so which is"
979600,985840," responsible for loading the beam files right so we could use compile right so usually we load things"
985840,992160," with compile right so c and you have to provide specifically an erlang file right but we don't"
992160,999840," have an erlang file we don't have an erlang file we already have a compiled module just byte code uh right"
999840,1005760," that was generated not from erlang file but from scratch literally so for this kind of situation i think there"
1005760,1011680," there is a special function in the code module uh right so which is literally called uh load file"
1011680,1019280," all right so and it tries to load the erlang module using the code path it looks for uh the object file"
1019280,1025600," with an extension corresponding to the erlang uh erlang machine used and so on and so forth okay"
1025600,1032960," so let's actually try to do that a code load file right so and let's just load the bada beam bada beam"
1033760,1038400," uh oh yeah i think i remember so you're not supposed to use the string you're supposed to actually"
1038400,1044800," provide the atom without the extension there we go and we cannot load that load that because it says"
1044800,1051760," corrupt file and here's an interesting thing it crashes within the c code right so the loader for"
1051760,1059040," the byte code is actually implemented in c right so and we can even probably find the location where it"
1059040,1064320," was located and stuff like that and know exactly what's going on there all right so if i do something"
1064320,1074560," like uh let me just like look for that so is there uh so there's elixir forum disgusting uh i'm gonna go"
1074560,1083440," to to google uh so there we go so here is the github thank you so much and uh so we even know the line"
1083440,1090400," where this kind of stuff happened right so we even know the line and uh so the line is 144 is there any"
1090400,1096000," way to jump to the line uh i think there's no way to jump to the line maybe ctrl l man it doesn't"
1096000,1105920," support that because it's freaking github uh right so there we go corrupt file header uh yeah corrupt file"
1105920,1113280," header so it literally failed in here so what it does right it tries to read the code right so then"
1113280,1118560," you have a bunch of results different errors right so these are different errors that may occur"
1118560,1125200," while loading the bim file right so uh we can just just read that in here actually"
1125200,1132080," right so right from the c code of the virtual machine it's it's not even that uh you know that"
1132080,1136960," unreadable it's just c uh it's a predestate forward c actually maybe we can modify that"
1136960,1143040," maybe we can use that code as a documentation on the format uh right so maybe we can do that"
1143040,1148400," but we'll see we'll see so the first thing we need to do we need to generate the the header"
1148400,1155600," right so and if uh i remember correctly the header actually starts with the magical number 41 uh right"
1155600,1161920," or rather magical combination of characters then 32-bit size of the whole thing i'm gonna see"
1161920,1175360," uh right so it's a size of the whole thing excluding 41 and uh the size itself and then uh the beam"
1175360,1182640," magical um you know magical thing for the for the internal sort of format right for the internal format"
1182640,1188960," so as far as i know 41 is a magical number for uh sort of like the container and within the container you"
1188960,1194400," have another format which we have another format which is beam right so i think they use like eff files"
1194400,1203120," or something that's what it is right um interchange file format so this is what they use to store beam"
1203120,1212960," things um right so and uh yeah within that thing they have uh beam all right so that's basically how it works"
1213920,1225360," so okay um so we need to be able to push uh for uh for one into the bytes into the bytes but as a sequence"
1225360,1231600," of bytes right we need to be able to do that uh so as far as i know we can't really do that so we can't"
1231600,1235760," really push this entire thing because it will push it as a single element in here right so let's actually"
1235760,1242480," remove this intention so i'm going to try to compile that and it is not going to work right so it's not how it works"
1242480,1249200," unfortunately so if i remember correctly vector implements a very interesting uh sort of like a"
1249200,1257120," trade called extend right so i've i saw this um trade before especially when i worked with pasta"
1257120,1266400," uh like a tree you know talking tree and talking streams and stuff like that right so i saw them relying"
1266400,1272720," very much on this specific trade and it has an interesting method that is called extend and it"
1272720,1278400," extends the container with an iterator right it extends the container with an iterator as far as"
1278400,1286400," you know vector implements uh this specific method right so it just allows you to extend so which means"
1286400,1294320," right so we have a string slice we can interpret it as bytes and we can basically interpret it as an iterator"
1294320,1302720," and we can extend uh right we can extend bytes with just that which makes it rather easy to"
1302720,1309120," work with i think right so let's actually try to do that one more time uh right maybe so there is also"
1309120,1313920," some sort of a mechanism in rust that allows you to automatically confirm slices to iterators maybe i"
1313920,1319280," can get rid of that i can get rid of that okay so we don't really need to to do anything in here okay"
1319280,1328320," so and then if we take a look at the badabim badaboom um okay okay okay okay so uh i yeah there we go"
1328320,1336320," so now we have four one now we have four one so that's pretty cool so the next thing we have to put in here"
1336320,1342640," right so the next thing we have to put in here we need to put this size uh of the entire file excluding"
1342640,1349280," the magic and the size itself right so essentially we can just put four in there right so let's actually"
1349280,1356800," say four uh right as u32 i think there was like a way to do it like that right i don't remember if this"
1356800,1364480," kind of thing works in rust but we'll see we'll see and is there any way to convert uh u32 like to"
1364480,1371600," like big andian uh is there something like it okay so i vaguely remember there was something like that"
1371600,1379120," to big andian uh to big andian word and it gives you an array uh right so but then we can probably try"
1379120,1387040," to interpret it as a slice to big andian um right to big andian bytes because erlang uses big andian"
1387040,1395040," right erlang uses big andian uh so now uh what we can do we can try to extend this entire thing so this"
1395040,1401760," is going to be just four and uh then we probably want to do something like uh beaming here right so"
1401760,1406640," and it's actually pretty straightforward right so we can just insert each individual element of the format"
1406640,1412720," like with single calls extend single call push and stuff like that i think that's pretty cool"
1412720,1419120," uh right and let's actually try to run this entire thing and open the uh bada bim bada boom one more"
1419120,1427040," time bada bim bada boom look at that we've got a header of the beam file that easily but is it going to"
1427040,1435200," load is the erlang going to load this entire thing let's find out uh bada bim so it does not complain about"
1435200,1443840," corrupt file header now it complains about missing code chunks we just knocked off one goal post i'm"
1443840,1450880," sorry if it was too loud so yeah so essentially this is actually very useful by the way this is actually"
1450880,1460000," very useful we can implement the generator in series of goal posts right so essentially first we just uh"
1460000,1466960," fixed the error of corrupt file header okay next one like missing code let's generate code chunks with"
1466960,1472800," empty code right so maybe then it will tell us something like missing that chunk let's generate"
1472800,1480960," that chunks and another chunk until we just basically generated a minimal bim file right so a minimum bim file"
1480960,1486240," i think that's really interesting right so this is a very cool approach i really like developing stuff in"
1486240,1491840," this kind of approach like interactive approach because you can kind of see the progress uh right"
1491840,1498800," you can kind of see the progress i think it's really cool so this is similarly to how um you know quite"
1498800,1506160," often people develop emulators right so uh essentially they have some sort of like their favorite game"
1506160,1512640," uh right they implement uh like a stop for the emulator with a switch case for different opcodes that"
1512640,1519280," doesn't implement any opcodes they try to run their game it fails on a certain opcode they"
1519280,1525040," implement that opcode run it again it complains about another opcode and then they iteratively just"
1525040,1530960," implement the whole emulator right or at least the emulator that can play their specific one game"
1530960,1535440," but then you can try to implement it for another game and eventually you will implement the whole emulator"
1535440,1545120," so it's kind of similar to that right so um yeah bada bim bada boom so uh we need to generate the code"
1545120,1553760," chunk we need to generate the coaching how what's the format of the coaching uh so let me see so uh we"
1553760,1561360," probably need to find where refer to the code here it is so yeah they called import chunk which is rather"
1561360,1566800," weird so it's supposed to be cold chunk but i copy pasted it from the book right so the book contains"
1566800,1577680," quite a few typos uh right so which is kind of fun but anyway so cold chunk uh i'm gonna paste it in here"
1577680,1584640," i think so this is not the comments that i expect in here so how we're going to be generating all of that"
1584640,1588800," so i suppose maybe we're going to have some sort of a function right so some sort of a function"
1588800,1595600," code chunk which is going to accept opcodes right so and i don't really know what's going to be the opcode"
1595600,1603040," uh right so it's probably going to be some sort of a separate stuff um let's not accept any opcodes"
1603040,1609360," for now right because i want to generate like an empty chunk right uh so and see how it's going to go"
1610320,1615600," so this entire thing is going to return i suppose the bytes of the chunks right so we're going to just"
1615600,1625600," generate it as as the chunks and um so let me see let me see so i'm going to just say to do like so and"
1625600,1634160," in here i want to first pre-generate all of the chunks i want to pre-generate all of the chunks so then"
1634160,1642400," later then later i can compute the final size of the file right the final size of the file uh so"
1642400,1651440," essentially i can say uh plus code len uh as u32 maybe it would even make sense to do something like"
1651440,1662800," uh like so right so as u32 uh two bytes right and uh so now i don't have to worry about specific size of"
1662800,1668320," the code if it's going to get extended that size is going to be added to to the final size of the file"
1668320,1675840," and then we can say something like bytes uh extend code right byte x bytes extend code right and if we're"
1675840,1682080," going to have even more chunks in here something like atom uh something like atom atom chunks uh"
1682080,1688000," all right so and here you can have a bunch of atoms atoms are the strings right not really strings"
1688000,1693200," they're the symbols that are used within the module uh right so different names like hello"
1693200,1698640," and that name then can be used for the name of the function uh some of the names can be used for the"
1698640,1703520," names of the modules that are imported or exported right so we can say that like generate atom chunk for"
1703520,1710960," these specific atoms and stuff like that so what's interesting is that some of the uh opcodes may refer to"
1710960,1720240," some atoms so maybe we should be able to have like atoms as the table in here that we can reuse among"
1720240,1727200," several chunks right so because the way the code refers to the atoms it refers to the atoms by index"
1727200,1734480," right so to refer by index you need an array of atoms right so we can generate the code from the atoms"
1734480,1739760," so to know their indices and then they generate atom chunks so this kind of stuff can be reused in the"
1739760,1744640," future but but not for now so i don't really want to over complicate this entire thing too too much"
1744640,1751360," right so we're generating empty stuff uh i'm jumping ahead of myself too much right because as soon as you"
1751360,1757200," start implementing something interesting it feels like you want to over complicate things right so build some"
1757200,1763520," sort of abstractions did some sort of a framework right so build some sort of framework so let's not"
1763520,1770560," go there yet let's not go there yet and we don't even need the code chunk yet uh right we don't even"
1770560,1779200," need to go to the code chunk yet so interestingly what if we first generate the contents of the beam"
1779200,1785440," and only then generate the header or something you know what i mean right essentially let's actually first"
1785440,1792480," generate something like this so let's say we're going to have a beam which is the which is the vector"
1792480,1800000," right and we extending the beam without caring about the size or anything like that we might even in"
1800000,1807680," like in in line the code in here right so we just generated the beam without the header and then we have"
1807680,1814960," bytes uh here we do five and as the sort of size we say beam len"
1815440,1819280," right and then we extend the bytes with beam"
1819280,1827280," that's actually pretty cool so essentially then i can append more different chunks in here like atom"
1827280,1834000," uh so imports right so we have imports chunk exports and that will work automatically"
1834000,1841040," right that will essentially work automatically so i think that's a pretty cool idea right so uh let me"
1841040,1846000," actually try to go to the compilation errors and see if it's going to work so this thing has to be mutable"
1846000,1851840," uh this thing has to be mutable and now it complains about uh the specific part because the code is not"
1851840,1859440," implemented okay cool so um maybe i can even use that paradigm for all of the chunks because all the"
1859440,1867040," chunks they have this sort of thing where you need to specify the header of the chunk the sort of name and then"
1867040,1874080," the size of the chunk basically the size of this section excluding the name and the size i can use"
1874080,1881120," a similar trick that i did in here first generate this part and then once you have this part generated"
1881120,1887680," generate this part so yeah this is actually like probably something that is going to work really well"
1887680,1895200," for sort of this kind of format if you know what i mean uh right so when the subsize is a very anal thing"
1895200,1907280," right it's the size after which the code starts right this is a really weird thing so the code starts in"
1907280,1917120," here right the code starts in here so subsize it's the size of this section why the do you need that"
1917920,1924720," why the do you need that here's an interesting thing you may generate uh beam modules that have"
1924720,1932720," a bigger section uh than some of the loaders expect so essentially if you have a version of the compiler"
1932720,1938720," that adds additional fields in here right so some additional fields like full uh bar and so on and so"
1938720,1948160," forth this thing allows all the loaders all the loaders all the virtual machines to skip this section and go"
1948160,1955920," straight into the code so it is needed for backward compatibility right so the newer modules with the"
1955920,1962160," newer stuff with the newer stuff can be still loaded by all the virtual machine because uh these sort of"
1962160,1967680," things like helps them to to know what they're interested in so you you can still preserve old"
1967680,1972400," fields in here and all the loaders all the virtual machine will be able to extract information out of"
1972400,1978800," that but then they're going to ignore the newer stuff this is actually quite clever this is actually quite"
1978800,1982880," clever trick and i really like that maybe i'm going to steal that trick in the future right so and there"
1982880,1988320," is a lot of things like that throughout the erlang virtual machine actually there's a lot of things like"
1988320,1994880," that just sort of like a provisions for the future in case something may change uh and some of them are"
1994880,2006560," really cool actually i really like that um so um yes yes yes so here's an interesting thing um we can"
2006560,2011600," take a look at what you're supposed to even have in here right so what you're supposed to even have in"
2011600,2018240," here so opcode max is the maximum size maximum value of the opcode uh right because of the opcode"
2018240,2025120," codes right as you can see their indices they're growing up right so the first uh index is one two"
2025120,2031200," three and every time you introduce a new instruction they just increment this specific opcode number"
2031200,2039040," right so by providing the maximum opcode number you sort of declare what's the instruction set you're using"
2039040,2048160," right uh it's the instruction set you're using uh and label count is basically the the amount of labels you have"
2048160,2052400," but so in within the within the within the code section labels there's something that you can"
2052400,2057280," uh jump to and the function count is the amount of function you have within the code nothing particularly"
2057280,2067520," special in here so uh let's actually see i want to take my hello module in here hello module in here"
2067520,2073280," and see the values of these parameters in there so i can just put them in here and don't guess or anything"
2073280,2080560," like that uh right so let me take a look at this kind of stuff so there is a code uh okay so the code"
2080560,2088800," just basically ignores the info section right so as you can see we do we take the subsize then uh we just"
2088800,2094240," take info and we uh completely ignore it i think instead of ignoring it we could have actually put it in"
2094240,2102880," here right so let's actually put it like this so here is the info uh and uh let me reload this entire thing and i'm gonna"
2103440,2113280," basically do the file hello bim the file hello bim so here is the code here is the byte code that we got"
2113280,2119440," and here is the info but info is not particularly parsed the info is not particularly parsed let's actually"
2119440,2125680," parse it properly uh let me take all of these things let me take all of these things and replace"
2126480,2134160," uh the info with right so this is basically what we need to have in here uh right so the instruction set"
2134160,2142560," the some other things blah blah blah uh right so this is the things right so before we were actually"
2142560,2148720," parsing it as a chunk now we're separating it so we're extracting specific instruction sets opcode max"
2148720,2154320," label count function count and so on and so forth right so now we can say that info is going to be"
2154320,2162720," just associative array of those things right so can we just basically take this entire stuff ah let's go"
2163760,2173120," and can i maybe shave off all of these things i don't think they are particularly needed uh"
2173120,2178160," for some reason it didn't want to put the uh semi-column in here so i'm gonna just"
2178160,2184160," yeah i wanted to actually turn it into a snack case i don't think i'll be able to do that in bulk"
2184160,2190560," so i'm gonna do that manually like so all right so i'm trying to construct an associative array an"
2190560,2198080," associative array in uh in earlink is basically a list of tuples right a list of tuples and each"
2198080,2204320," tuple is just a pair first element is the key and the second element is the value so uh and in my case"
2204320,2210400," the key is going to be just an atom that describes the name of a particular fields that i'm interested in"
2210400,2214960," so in here we have instruction set opcode max label count and function count"
2214960,2220880," so on top of that i would like to maybe have this subsize as well just to see what usually you put"
2220880,2226480," uh in in the modules right so i would expect it to be something like 16 because this is four"
2226480,2232000," bytes this is four bytes this is four bytes this is four bytes like four by four is 16 so this is what"
2232000,2237840," i expect in there uh right but i want to be 100 sure right so here we go here is the subsize"
2237840,2243520," and i go here we have the thing that extracts all of that information so if i try to run this and that"
2243520,2249680," stuff so that's the data we have okay so for the hello module right for this hello module that we"
2249680,2256240," compiled from uh from erlang right the values for all of these parameters for the code section"
2256240,2263040," uh for the code section are the following where is it i can't find so the subsize is 16 as i predicted"
2264000,2271760," instruction set is zero so if i remember correctly they basically set the instruction set to like one"
2271760,2278880," version and they never changed it since they invented it so that's why for the longest time"
2278880,2286160," instruction set was zero right and it's kind of funny right so i suppose you need to increment the"
2286160,2301760," instruction set number if you made backward incompatible changes for backward compatible changes what you can"
2301760,2310640," do you can just increment the opcode max right so because if you're just adding new instructions it"
2310640,2316160," doesn't mean that you cannot work with all the code all the code that is going to work with newer virtual"
2316160,2321280," machines anyway right so because it just doesn't use the new instructions the only way you need to do"
2321280,2327600," that you know increment this particular thing is when you have backward incompatible changes so i suppose so"
2327600,2333040," far they had no backward incompatible changes and to be fair when you're developing a virtual machine"
2333840,2340240," it's actually super easy to just uh append more and more instructions and just preserve the old"
2340240,2346240," instructions for backward compatibility right so quite rarely you need to change like literally everything"
2346240,2354080," quite rarely and that's kind of demonstrates that i think maybe so it's like it's it's similar to uh to"
2354080,2363840," x86-64 right so as far as i know the the modern x86-64 processors they still can run ms-dos"
2363840,2370960," can they can't they i think they can like you can literally take the the old ms-dos like from the"
2370960,2379520," from the floppy disk and run it on the modern x86-64 processor sort of like uh but anyway so all the like"
2379520,2385680," majority of the modes and the instructions that are needed to run this old software they're still kind"
2385680,2390960," of work there uh yeah people say in theory people say in theory right so maybe in practice it could be a"
2390960,2398480," little bit more difficult but theoretically so uh but what i'm trying to say is that you can kind of go"
2398480,2407120," very long without introducing backward incompatible stuff so you can go for relatively long so that's"
2407120,2412480," probably why the instruction set is just zero so label count is just the amount of labels and the"
2412480,2418240," function count is the amount of functions and stuff like that you can actually see labels if you use a"
2418240,2426400," disassembler uh erlang comes with its own disassembler right so there is a bim disasm uh right so let's"
2426400,2433920," actually take a look at the module info right so bim disasm and you can disassemble a particular file"
2433920,2441600," right so you can disassemble a particular file so let's take a look at hello uh bim right and there"
2441600,2447040," you go here are all of the functions here are all the functions that you may have and within those"
2447040,2453120," functions you have labels right different labels so we can even search for them uh right so these are"
2453120,2459120," different labels and those labels are basically the places uh where you can jump to during the execution"
2459840,2469440," right so these are the labels and uh so that particular uh you know thing right label count"
2469440,2475280," it tells you how many labels you have within the code section uh right and the function count is how many"
2475280,2480480," functions you have uh within the code section you can actually kind of see them each individual function"
2480480,2487680," actually starts with uh func and foe right so func and foe denotes the beginning of the function right so"
2487680,2494160," and i suppose i don't remember you have to have like a label right before func and foe right and then"
2494160,2500320," label right before the beginning of the body of the function or something like that so this kind of sequence"
2500320,2506160," of things like label func and foe and another label is sort of like a preamble for a function right and"
2506160,2511920," when you call a particular function the execution jumps in here right the execution jumps in here"
2511920,2517840," uh so when the function foe tells you the the name of the function uh right actually yeah so the name of"
2517840,2525200," the function and the some module info i don't really know what the fuck is that oh it's a it's this one"
2525200,2532080," yeah there we go so you have a hello function it tells yeah the name of the module and the function"
2532080,2538960," itself and i suppose this is its arity right so and then once you declare it here comes the body of"
2538960,2543360," the function so you can do different stuff in here so as you can see this function doesn't really do"
2543360,2553200," anything uh right it moves literal hello world into the register x by the way erling is not a stake"
2553200,2560480," stack machine it's not a stack machine it is not a stack machine it's a freaking register machine"
2561280,2572160," so yeah but you know what's funny uh you know what's funny it has thousands of"
2572160,2580880," x registers so it has so-called x registers right so and the way you refer to this registers actually is"
2580880,2589120," something like x zero x one x two x three and so on so forth and i think you have around 1024 of them"
2591120,2601120," right so you can kind of treat this array of registers as a stack if you want to i mean"
2601120,2608000," right if you have a stack the size of which is known at compile time right you know the size of the stack"
2608000,2613280," at compile time it you do not allow it to be like a dynamic stack or anything like that you can just use"
2613280,2621120," this array of registers as the stack i could implement this as a target for port easy because one of the"
2621120,2624960," limitations that port has is that the size of the stack has to be known at compile time"
2625600,2629760," that fits into the computation model of port actually so"
2629760,2635920," so easy actually fucking easy um"
2635920,2645360," so there's another like array of registers called wire registers i don't remember what they're used for i"
2645360,2652480," think they're used for manipulating an actual stack on top of these registers it also had also has its own"
2652480,2658400," stack uh right and i think i don't remember so i think it's needed for manipulating memory or something"
2658400,2663280," like that right i didn't fully understand but i i don't think we really need that so in this thing"
2663280,2669040," what does it do it moves the literal hello world into the register x and it just calls an external"
2669040,2676400," function io format right so and that's basically it and if we take a look at the exactly what's going on"
2676400,2686000," here right so we're just calling io format with the string literal uh so yes yes yes so let's pretty step"
2686000,2695120," forward so let's go back right so this is the parameters that uh basically we can use all right"
2695120,2701520," for generating the code section for bada bim bada boom bada bim bada boom let's go ahead and do that"
2701520,2708880," so i'm gonna just like do it like that uh so let me maybe create something like chunk right"
2708880,2716240," so i'm going to generate starting from subsize i'm going to generate these things a little bit later"
2716240,2722080," right that's that's going to be basically the idea can i just like create variables out of these things"
2722080,2729920," like let something like that that would have been cool i think i think i think i think i think uh right"
2729920,2734640," so this is going to be something like this i'm going to put semicolon in here and i actually want to"
2734640,2743120," replace these commas with something like equal boom look at that do you like that do you like that chat"
2743120,2749600," i think it's pretty polish uh right so then in here we're going to say it's u32 right so subsize"
2749600,2755600," is going to be 16 it's going to stay 16 instruction status then we're going to say 16 uh zero uh opcode max"
2755600,2761680," let's leave it as it is we're not going to generate any code as of right now we're not generating any"
2761680,2767040," coders over there so i suppose the amount of labels is going to be zero right and we're not going to"
2767040,2772800," generate any functions so the function count is also going to be zero that makes sense all right so"
2772800,2778960," that's that's the things we're going to have in our chunk uh so let me just go ahead and extend this"
2778960,2790160," thing so instruction instruction set uh to b to b bites to b bites and here well i mean first it has to"
2790160,2799920," be subsize instruction set then opcode max then label count then function count right so this is"
2799920,2806400," basically sort of like the preamble for the code chunk that we managed to generate then comes"
2806400,2816000," uh right so where is the format uh then comes the code and then comes the freaking paddy okay okay okay okay"
2816000,2826560," okay so the the changas the changas has to be aligned by four"
2826560,2836320," so yeah after generating a single changas a single changas we have to align this mother flipper by four"
2838080,2844880," so that means we'll have to append a bunch of zeros in case that thing is not divisible by four"
2844880,2851520," right essentially essentially right imagine you generated some sort of a changas right so uh like"
2851520,2859440," this how can you know if it is divisible by four well you split the each individual element of this changas"
2859440,2865520," into groups of four okay here's the first four here's another four and this thing is not divisible"
2865520,2872480," by four because like you see there's like the tail so-called remainder right so the tail of this group"
2872480,2878800," and we call it in mathematical circles remainder is not equal to four so we need to basically append"
2878800,2886160," like additional zero to turn it like into this right so this is what we need to do after we generated a"
2886160,2892640," bunch of things it still has to be aligned it has to be padded uh by zeros right so it becomes divisible"
2892640,2901040," by four so um maybe we can create a function called pad chunk right and it's going to literally accept the"
2901040,2909680," chunk maybe immutable vector of bytes right and it's basically going to just append a bunch of zeros"
2909680,2915680," so the size of this changas becomes divisible by four right but to do that we need to first know is it"
2915680,2922240," already divisible by four right so we can take the size of the changas right and do mod four and if it's"
2922240,2928240," equal to zero it's already divisible by four nothing needs to be done and by the way mod four"
2929040,2937440," is essentially the size of this remainder the size of this tail after you try to divide uh this entire"
2937440,2943920," stuff by four right it's it's quite easy to get that little tail that's what the mod operator for it's"
2943920,2949280," literally the only purpose of this mod operator is to get this small little tail at the end when you're"
2949280,2956960," trying to group a certain number by a certain size right so that's what it's needed for okay if it's already"
2956960,2961280," equal to zero that means like we we have nothing in here it's already divisible by four"
2961280,2968080," so the only thing we care about is when it's not equal to zero right so that means right"
2968080,2976960," we need to append a certain amount of zero so in this case the remainder is three so that means we need"
2976960,2985280," to append one right so essentially how many things we have to append we have to append four minus this remainder"
2985360,2992640," right minus this remainder and i wonder if i can actually put that remainder into a separate variable"
2992640,3001920," uh can i call it like a rem and then i can do a rem rem and then i can say for zero to rem"
3002560,3012240," uh right just this amount of times push byte zero into the changas and that's basically it so that's"
3012240,3020880," how we can basically align that that's very dumb but i mean we have to append three bytes at max we have"
3020880,3027840," to append three bytes at max maybe there's something that allows us to repeat uh a certain byte for the slice"
3027840,3031760," right so can i so there's a slice repeat"
3031760,3041360," uh-huh so you can repeat a certain well that's very interesting right so essentially if you have a slice"
3041360,3051520," zero you can say repeat that slice this amount of times this amount of times and then you can just extend"
3051520,3057920," that slice with this kind of thing but if you repeat you get a vector right so but maybe that's fine"
3057920,3067200," right so and essentially this thing is yeah okay is that better that looks awful so that means"
3067200,3076720," that's the solution we're gonna go with that's the solution we're gonna go with because it looks awful"
3076720,3088480," to piss more people off ah yes we usually used to call it freaking this so this thing has to be mutable by the way"
3090080,3105040," uh okay so uh we don't depend anything right so the size of the code is going to be literally zero okay"
3105040,3113680," so we're going to do chunk um you know pad uh oh and by the way as far as i know there is another really"
3113680,3121120," unpleasant thing about the beam format is that the chunk size should contain the size of the chunk"
3121120,3123040," without the padding"
3123040,3139360," right so this size is does not include padding it does not include padding right so uh essentially uh if i do"
3139360,3148480," something like um pad chunk all right and i just put pad this specific chunk to four and then um i want"
3148480,3154240," to generate a different chunk right so let's actually say let's let's call this thing result uh right and"
3154240,3164960," then i'm gonna append actually extend this entire thing with code as bytes right code as bytes and then extend"
3164960,3175440," that stuff with the size of the chunk i actually need to interpret it as u32 right as u32 uh two bbytes"
3175440,3182960," two bbytes and then i extend this entire thing with that chunk right so the reason why i do that is because"
3182960,3188720," uh like i need to first know the size of the chunk i need to first know the size of the chunk before i can"
3188720,3194080," put it in here right so first i generate the chunk then i put the size of the chunk and then i append"
3194080,3202240," it to the final thing that i return as the result in here but here is an interesting thing that size has"
3202240,3212240," to be unpadded that size has to be unpadded but i already padded it but i already padded it so that"
3212240,3215440," means i have to padded it after i calculated it"
3215440,3220400," uh"
3220400,3220400," uh"
3220400,3220400," um"
3220400,3228480," it's kind of funny isn't it it's kind of funny uh anyway so that that's basically everything"
3228480,3234240," right isn't it i think i think that's basically everything uh so let me try to compile and it's"
3234240,3242560," compiled it actually compiled uh so let me take a look at bada bim bada boom bada bim bada boom"
3242560,3250640," bada bim bada boom so yeah there we go so we have a code we've got the code so the code starts somewhere"
3250640,3256960," here right so here's the code and we have the size and we have some other parameters in here uh right and we"
3256960,3263600," have nothing at the end right so that's that's basically the the bim file with the code right"
3263600,3267280," the bim file with the code"
3267280,3274160," i ran out of tea actually i ran out of tea so i think uh i think i'm gonna make a small break"
3274160,3278400," i think i'm gonna make a small break and after the break after i have my cup of tea"
3279120,3285920," we're gonna go ahead and continue slapping the code continue slapping the code all right um all"
3285920,3292080," right so uh we have a code chungus right so we managed to generate the code chungus and let"
3292080,3297840," me see uh if it compiles it seems to be compiling so if i take a look at that specific code chungus"
3297840,3306400," uh right so do we have anything in here okay so we have something and if i try to uh load it up"
3306400,3313680," in the urlang virtual machine all right so let's do uh where is the code loader okay so"
3313680,3333680," it does not complain about the code table anymore can your chat gpt do that i don't think so mate anyway"
3334480,3344320," uh so let's generate the atom uh the atoms uh chunk right so let's go into the pasta i want to extract"
3344320,3354000," the format of the atom chunk uh atomic chunk so an atom chunk atom chunk is basically a list of strings"
3354000,3361040," right it's basically a list of strings so uh let me put this stuff in here uh right so we're gonna do it like"
3361040,3370240," that boom uh atom chunk uh so and we're gonna accept the list of atoms right so let's say we're gonna"
3370240,3378480," have a list of these slices and uh we're gonna return a vector of bytes so uh yeah so essentially you have"
3378480,3386560," to provide the the number of atoms and then you put sequence of atoms which is one byte per atom which is the"
3386560,3393760," length of the atom and then the atom bites uh the the you know the the string itself so these are sized"
3393760,3401680," strings these are pascal strings by the way these are pascal strings even down to the limitation of the size"
3401680,3408960," so since you can only have one byte for the length of an atom you cannot have an atom longer than 255"
3408960,3414800," let's that let that sink in let that sink in"
3414800,3423360," so yeah uh let's go ahead and do that so we're gonna have a mutable chunk uh vector uh new right"
3424080,3428960," and uh so the first thing we have to do we have to put a number of atoms in there right so we're"
3428960,3434640," ignoring this stuff for now because we don't know the size of the chunk yet uh right so let's go ahead"
3434640,3444640," and do chunk uh chunk extend the size of atoms atoms uh as u32 as u32 and we're gonna do two bbytes"
3444640,3449760," two bbytes boom we actually put this stuff in here so let's start iterating atoms"
3450640,3460320," like so and for each atom we're gonna take the length of the atom as a byte as a byte uh and uh"
3460320,3468080," right so we're gonna do two bbytes two bbytes and we're gonna append that into the chungas extend"
3468080,3474880," append that into the chungas and then we have to append the atom itself right so we have to take atom as"
3474880,3484000," bytes and then we're just gonna do chunk extend uh like so and that is basically it after that we want"
3484000,3490000," to pad the chunk right so we want to pad the chunk and then generate the rest of the stuff"
3490000,3494880," the the the result okay so that means we'll have to pad it after we generated the result right so the"
3494880,3502240," result is going to be another thing in here uh right so we are extending the result"
3503360,3513760," with the atom uh as bytes right so here is the atom then with the size of the chunk all right so chunk"
3513760,3524880," len as u32 so that's the size of the chunk as say to be bytes to be bytes and then we pad the chunk and"
3524880,3532000," then we extend this and i think with the chunk as well so padding the chunk to 32 bits is extremely"
3532000,3539440," important it is in fact extremely important oh boy i hope i'm not gonna run into any of the"
3539440,3548000," roadblocks we'll see how it goes we'll see how it goes okay so i'm gonna append the atom chunk and uh"
3548000,3555840," we can generate a bunch of atoms in here so let's actually generate something like hello uh world uh and"
3555840,3560960," so on and so on and so forth so one of the chunks we'll need by the way we'll need the name of the"
3560960,3566960," module right so uh itself right because we're going to be declaring imports and stuff like that so bada"
3566960,3571920," is probably one of the chunks that we want to have in here uh so let's actually put it in there right"
3571920,3577920," so let's actually put it in there so and uh let's just run this entire thing and it seemed to be working"
3577920,3583840," let's open a bada beam a bada boom uh and do we have any stuff in here they go here are the atoms"
3583840,3591360," you can clearly see that before the atom you have one byte one byte one byte and that bytes is basically"
3591360,3597200," the size uh of the of the string and as you can see you have three bytes in here to bring all of that"
3597200,3603600," to like alignment by four and you can clearly see that there is alignment by four in the entire file"
3604400,3610400," so the entire file is aligned by four because there's no remainders in here right so as you can"
3610400,3616400," see it's just like groups of uh well groups of well i mean this is actually not really bytes these are"
3616400,3622960," nibbles but um everything is perfectly aligned here everything is perfectly aligned so it's a group by four"
3624480,3632000," okay uh so let's go into the urlang and uh try to load this entire thing uh so"
3632000,3640400," loading module bada please recompile this module with uh otp bat file"
3640400,3642480," huh"
3642480,3651680," it doesn't really say what exactly is going on all right so"
3653680,3661440," uh let me go into the urlang and uh i'm going to try to load it up um that's kind of weird"
3661440,3669280," so we may try to disassemble this entire thing uh bim disasm uh that specific file"
3669280,3681440," so this is going to be bim uh right missing chunk xpt okay so uh sometimes um the loader is incapable of"
3681440,3687440," telling us what exactly is going on and uh it's kind of nice to fall back to the disassemble because"
3687440,3692560," sometimes it can tell us some more information about what the is going on so another chunk that"
3692560,3699920," we need to provide is the experts chunk all right so yeah without the i wonder what's gonna what is"
3699920,3704080," going to say if i don't provide any atoms chunk right so let's actually try to do it like that"
3704720,3710560," right and an urlang if i try to disassemble it it wants the atom chunk but once you provided the atom"
3710560,3717440," chunk uh right once you provided the atom chunk the disassembler wants the uh experts chunk uh i wonder"
3717440,3723440," what's going to happen if you don't provide any of the atoms what if you don't provide any of the atoms so"
3723440,3730560," there's no atoms in the final file uh oh this is funny actually holy"
3730560,3733520," um"
3733520,3743440," extract atom it was trying to extract an atom it was trying to extract an atom and it couldn't do that"
3743440,3751520," it was trying to do that in latin one oh by the way by the way so uh when you do atom one you can only"
3751520,3762160," use latin one encoding right so if you want to use utf8 encoding you only you have to do at u8 right so"
3762160,3768800," it's a special sort of like an atom chunk uh special atom chunk for encoding utf8 so maybe that's the"
3768800,3775920," chunk we have to use right so and apparently you can't have an empty atom chunk which is kind of fun"
3775920,3784320," right so yeah uh anyway so if i if i do that what what's going to happen if i will try to load the empty"
3784320,3795120," chunk with the uh virtual machine uh corrupt atom table yeah so atom table apparently may not be empty"
3795120,3801760," atom the table apparently may not be empty otherwise it's considered corrupt"
3801760,3805200," both by the virtual machine and the disassembler"
3809680,3818320," and the disassembler okay so we can try to maybe put something back like bada in there uh maybe one"
3818320,3828400," atom maybe you need to have at least one atom uh right so if you have one atom oh missing import table"
3828400,3836720," but it was complaining that the file is bad or something hello world"
3839360,3841360," okay okay wasn't complaining about that"
3841360,3852560," so is that because i was using the atom thingy instead of utf8"
3852560,3857600," instead of utf8 yeah"
3857600,3863040," if you're using non-utf8 atom table"
3863040,3868960," it cannot load it i suppose maybe it doesn't support"
3869040,3876960," non-utf8 atoms anymore wait if i have non-utf8 but with bada"
3876960,3882960," it's also going to compile you know what it feels like chat chat chat you know what it feels like"
3882960,3886560," it feels like a lock picking doesn't it"
3890960,3897840," so i'm just changing like yeah i'm just changing the byte of like a bunch of bytes and see how the lock"
3897840,3903680," clicks and stuff like that like i'm observing like the outside effects without looking inside of it"
3903680,3909520," right this is actually quite funny right i'm changing the combination of bytes and see how the virtual"
3909520,3918320," machine reacts um that is quite freaking funny like i'm learning the system from the outside right so i'm"
3918320,3925280," treating i'm learning a black box right i'm learning a black box without looking inside of it if i start"
3925280,3932240," looking into the source code this can be already like a white box thingy um right exploring the maze right"
3932240,3939600," right so i'm exploring the maze so it's actually quite fun uh i really enjoy that so if i do better okay so"
3939600,3949280," so apparently the modern um the modern erlang vm does not support atom like that because it's non-utf8"
3949280,3956880," you have to use utf8 and it even tells you that so uh error loading module bada please recompile this module with"
3956880,3962480," you could have actually gave me more information mother flipper like what's up with with those people"
3965040,3972320," right i suppose this message targets like the non-technical people that don't know how the"
3972320,3977840," internals of the beam compiler works just don't think about that you dummy dumb dumb just recompile"
3977840,3983360," your silly file you're not supposed to understand that like a smarter people then you figure it out for"
3983360,3992560," you just recompile with him could have at least tell me they could have at least tell me that"
3992560,3999680," bruh we do not support the like latin one encoding anymore right so this is an old compiler just using"
3999680,4005120," new one they could have at least mentioned that just like a glimpse of information for people who"
4005120,4013120," know what is going on it's just like come on why are you treating me like a dummy smh my h smh my h"
4013120,4020720," um okay so we learned a couple of new things first thing we learned uh you're not supposed to use atom"
4020720,4026800," with the modern erlang vms right you're supposed to use at u8 second thing i learned is that atom"
4026800,4034640," table cannot be empty apparently it cannot be empty uh so another thing i kind of vaguely remember from the"
4034640,4043360," bim book is that the atom like you refer to the atom in the op codes through the indices and the minimum"
4043360,4052080," valid index for the atom is one right so the atoms are indexed starting from one in that specific table"
4052080,4060240," you know why you know why you know why this is because the atom zero atom zero is actually new"
4062560,4069200," atom zero is a reserved atom global atom across like all the modules and stuff like that and it"
4069200,4074720," it's new and it's atom zero which makes sense actually which makes sense"
4074720,4084720," it's pretty cool i think i think it's pretty cool anyways uh all right so what does it want what does it"
4084720,4097440," want uh what's the book it's called bim book uh the bim a book uh this one it's a literally a book dedicated"
4097440,4104000," to internals of erlang if you ever wanted to understand how internally erlang system works"
4104000,4109840," like uh opcodes virtual machines and stuff like that the that we're doing right now"
4111040,4115440," there is a book for that unfortunately it's not finished right so there's a lot of chapters in"
4115440,4123520," here and not all of them are finished so um but it's kind of good for like a you know reference guide"
4123520,4128480," uh right so you can you have a table of like opcodes in there some little disc a little bit for"
4128480,4137680," descriptions and stuff like that uh okay good so the next chunk we need to generate chat the next chunk"
4137680,4144240," we need to generate is the imports chunk right so missing import table so let's take a look how you"
4144240,4153280," generate the import table import chunk uh so yeah essentially you have a import count and then you"
4153280,4162000," have a sequence of triples the module name the function name and everything module name is 32-bit integer"
4162000,4167200," function name is a 32-bit integer how a name is a 32-bit integer"
4169360,4180240," this is because that integer is an index in atom table that's why you have an atom table atom is a"
4180240,4188560," symbol atom is the name and you refer to these atoms throughout the entire file right so you say okay i'm"
4188560,4196960," importing the function with the module atom that one and function atom that one uh right and of course the"
4196960,4203600," arity right and this is actually the classical signature of a function in erlang uh the classical"
4203600,4210480," signature of the function in erlang where you have the module name slash the function name uh actually"
4210480,4217600," colon excuse me module colon function name slash arity right it's like 69 or something like that right"
4217600,4222960," so this is the signature of a function full signature of the function it's three elements module where it's"
4222960,4228800," located it's located it's name within the module and it's arity and essentially that's an equivalent of that"
4228800,4229680," but in binary"
4229680,4241520," so that's why uh you should have your atoms before everything yeah exactly exactly exactly so and"
4241520,4245600," because of that this is previously for format right so we have a count of those things and you have these"
4245600,4251200," triples and uh then they are repeated for the import counts and of course then you have to not forget to"
4251200,4260080," pad your chungus uh okay but what is arity uh it's the amount of arguments it's a mathematical term"
4260080,4267360," it's a mathematical term if you google up what is everything snap back to reality comes everything"
4268720,4274560," so in logic mathematics and computer science arity is the number of arguments or operands taken by a"
4274560,4280720," function operation or uh relation that's what it is it's just a number of arguments"
4280720,4290720," so let's go ahead and generate these shots uh so did i already replace this stuff"
4295680,4301360," so imports chungus so i suppose for now we're not going to generate any imports right so i want to create"
4301360,4311520," an empty module right imports uh imports chungus okay so here's the imports chungus so and we're gonna just"
4311520,4325520," return back uh like so mutable chunk vec new uh in the chunk extend import count is going to be zero let's"
4325520,4332400," actually maybe define it like that import count um to to be bites let"
4332400,4340960," let's import count u32 zero nothing in there but in the future we're going to actually extend it"
4340960,4348000," um that's it i suppose that is basically it so we need to create the results which is also going to be"
4348000,4360640," the vector new uh right then result extend imp t as bytes as bytes result the chunk size okay"
4360640,4365840," chunk len as u32"
4367840,4376640," uh to be bodies to be bodies um then pad chunk mutable chunk"
4376640,4389920," and extend the chunk and then just return so after that we can extend the beam file with the imports chunk"
4392640,4396080," it's actually kind of cool how easy it is to add like additional things in here"
4396080,4403600," um yeah so we just implemented a new chunk and uh then in the future all of these functions may be"
4403600,4410720," parameterized with like a more high level arrays of structures right so maybe we're going to have a"
4410720,4418720," structure import right structure import um right and it's going to be literally just a module which is"
4418720,4426000," going to be a string uh function which is going to be a string and arity uh you size and maybe it's going"
4426000,4432560," to have some sort of a function right that renders that entire thing into a sequence of bytes"
4433840,4440160," right a sequence of bytes just a second um given the list of atoms"
4440160,4449200," uh something like this you know what i'm talking about right so on the level of like logic high level"
4449200,4455040," logic you operate with like real names and stuff like that and then you can render it down to a sequence"
4455040,4460640," of bytes uh knowing the atoms right because it's going to look up each individual model in the atoms and"
4460640,4466480," stuff like that uh maybe this entire thing is going to be actually mutable vector of these things so if"
4466480,4471680," for example during the rendering you encounter a thing that is not in the atoms table it's going to"
4471680,4478400," automatically append it to the atoms table so then you can render your atoms table so and because of"
4478400,4490400," that this could be something like a like a hash set uh maybe hash map from str to um to u32 or"
4490400,4499200," something like that right so then if you encounter a new thing that was not in the atoms before like"
4499200,4503840," i'm getting too much ahead of myself right so you can clearly see like how you can develop this entire"
4503840,4509520," system that automatically collects and generates and stuff like that so i should probably not go ahead"
4509520,4515760," of myself this is the main trap of this kind of project is that you're trying to go ahead of yourself"
4515760,4521520," and like start over engineering the system and then you can get yourself into the trap where it's very"
4521520,4527920," difficult to get out of because you've created such a beautiful system it would be really you're gonna"
4527920,4534800," feel really bad for tearing it down when it doesn't work out for you right so that's why i don't really"
4534800,4540720," like to architecture like ahead of myself right i own the architecture when it's actually needed when it's been"
4540720,4546240," proven that yeah that's exactly what we need for that specific case this is just speculation having"
4546240,4552160," this system that automatically keeps tracks of atoms just a speculation this is just like a me from 10"
4552160,4557760," years ago speaking right now right who is inexperienced and want to over engineer and"
4557760,4563360," hasker and stuff like that i should tame myself okay we need to only implement things that are needed right now"
4564000,4577600," so uh all right all right all right uh let me let me see so we created the import chunk we already uh"
4577600,4585440," all right so let me see if i can now load this entire thing in here export table okay"
4586880,4595200," so it does not complain about import table anymore okay so and the cool thing about the export table"
4595200,4600240," is that it's kind of similar to import table actually it's it's literally the same it's just"
4600240,4605440," like a different name so as you can see you have well i mean you don't have to provide"
4605440,4612160," oh you don't have to provide the module name because it's obviously with the module you are in"
4612160,4616160," you have to provide the function name the arity and the label"
4616160,4625200," in the label so and the label is basically the label within the code chunk where you have to jump"
4625200,4633920," if you take a look at the disassembly of the hello uh function right so beam disassemble uh file"
4634800,4640400," hello beam uh right so for each individual function"
4640400,4646480," right you have label one label two and stuff like that these kind of labels"
4646480,4655120," so in reality the code block is a continuous sequence of opcodes it's a continuous sequence of"
4655120,4661440," instructions and all of the bodies of all the functions are just concatenated together"
4662080,4666880," right so it's just like a continuous sequence of instructions and the start of the body of the"
4666880,4673920," function is denoted by a label right you literally place these labels in here and labels is a special"
4673920,4678080," instruction that is going to be removed during the loading right it's needed only to mark the places"
4678080,4686000," within the code and in the export you also specify the label where the function starts right it's usually"
4686000,4692000," this one i think i think that it's that one right before the function in four because after you call"
4692000,4697200," the function you need to encounter i think you need to encounter function in four so the runtime knows"
4697200,4703920," what kind of function it is executed because it's setting up information for for the runtime error"
4703920,4710720," generation right so it's sort of like a preamble for the function so then when an exception happens it"
4710720,4715840," knows what kind of name of the function to put in a stack or something like that so it's it's kind of"
4715840,4720400," important for the execution to encounter this specific instruction so func and four is an instruction by"
4720400,4727120," the way right it's a very high level virtual machine label is the instruction func and four that tells you"
4727120,4732880," about the current function is an instruction and then you have moves and stuff like that line i don't quite"
4732880,4740240," remember what the is line but i think it's it's also for debugging purposes right uh it's also for debugging"
4740240,4749120," purposes you know debug like erlang comes with its own debugger and it's the funniest ever i still"
4749120,4759680," haven't figured out how to use it all right but uh i can show you uh erlang just a second uh debugger"
4760720,4763200," start this is how you start the debugger"
4763200,4768480," and it opens up a gooey application"
4768480,4781920," imagine like you're in a terminal you start debugger start and this is a gooey application right so it's just"
4781920,4789040," like it's a debugger yeah i don't know how to use this by the way it's just like you have like checkpoints"
4789040,4791280," and stuff like that and then you can close it"
4791280,4800560," so funny um like i i was googling up how to debug like erlang and stuff like that i found this is what"
4800560,4806800," you have to do and i got like almost spooked out it's just like i didn't expect like i thought i'm"
4806800,4810720," working in the terminal it's just like a gooey window pops up like what the is going on"
4813040,4820480," what what what the so when i was writing erlang for living we would do processing for calls and inspect"
4820480,4825520," state etc i never used that goo okay i'll make a note i have no idea what you're talking about by the"
4825520,4830480," way but i'll make a note that maybe processing for is something more useful in this specific case"
4831760,4839440," uh okay go so what do we wanna do so we need to generate the export table right so let me quickly"
4839440,4844080," maybe copy paste this entire stuff right let me quickly copy paste this entire stuff"
4844080,4850400," uh right so what i'm thinking is that maybe i'm gonna also copy paste"
4851040,4859600," the import chunk right because it's kind of similar if you think about that so we're not going to export"
4859600,4866160," anything but we can quickly replace import with export right so this is going to export export count"
4866160,4873040," and we also have to change this thing there we go so we have to change this thing"
4874240,4883600," so uh let's okay so whenever call this so let's actually put it in here exports um i think that is"
4883600,4889520," basically it's so we also need to have string literals if i'm not mistaken string literals also mandatory chunk"
4889520,4900800," uh right right right right right right right so let's go let's try to load butter uh invalid opcode"
4902880,4911520," okay that is very interesting so maybe uh right so maybe we have to actually"
4911520,4919920," put something in a code block put something in the code block uh all right it doesn't really"
4919920,4928000," tell us what's exactly let's try to do the disassembled bim this asm file uh bada bim bada boom"
4930560,4937280," missing chunk okay so that's pretty interesting so uh the virtual machine complains about the code"
4937280,4943120," right the invalid opcodes and stuff like that but the disassembler complains about the lack of strt"
4943120,4953360," okay so let's actually maybe try to satisfy the uh assembler first right so where is my password so strt"
4953360,4959120," and strt is very simple so it's it basically stores these strings right it stores the strings and if you"
4959120,4963120," don't have any strings you can just leave this thing empty right it's not that big of a deal"
4963120,4967760," and you store all the strings in a continuous chunk right so just continuous changas"
4967760,4978160," uh so should be easy to generate as well given that we have a huge experience in this stuff in generating"
4978160,4985840," the changas uh there we go string changas fn right so we're going to just return this kind of thing"
4985840,4991360," let chunk uh vector new"
4991360,5002160," chunk um so data that's going to be really nothing and zero is already padded to"
5003120,5011520," yeah we don't need any of this i think i think we don't right so i can do chunk extend uh strt"
5011520,5023360," as bytes and then chunk extend extend zero u32 to be bytes and then just that right because i don't have"
5023360,5029840," any data so and zero is already padded by four right so that makes sense it's just like yeah"
5029840,5038240," uh okay so string chunk uh what else do we have in here erling and let's try to disassemble this"
5038240,5045360," entire thing empty code segment okay so you can't have empty code segments either it's kind of funny"
5045360,5051440," that it first checked for all of the segments and only then started to complain about empty code segment that"
5051440,5055520," but then it complained about empty atom segment right away"
5055520,5065120," isn't that kind of funny isn't that kind i think it's kind of funny right it's just like different"
5065120,5074400," different checks for the like verification checks for the um for the correctness of the format are"
5074400,5081120," happening at different times it's just like it's kind of funny to see so you can't have an empty code"
5081120,5088000," segment so we can try to put maybe a label in there right so we can put a label in there like an"
5088000,5094960," instruction okay here's the thing about instructions right so let's actually find uh instructions can"
5094960,5104080," consist of first opcode and opcode is one byte right so instructions start with one byte and it's opcode"
5104800,5112080," uh all of the opcode numbers uh are located in beam opcodes erl here they are right label just marks the"
5112080,5121280," the location within the code so and it's just like a code one uh then depending on the arity of that opcode"
5121280,5129920," opcodes also have arity you have a certain amount of arguments and arguments have variable length"
5130720,5139520," they have variable length depending on their size and each argument is just a number it's just a number"
5139520,5143120," depending on the size of the number it's going to be encoded with variable amount of bytes"
5143120,5153600," but on top of argument being a number it also has a tag associated with that number which denotes its type"
5153600,5160480," right so we can actually maybe describe the format of the of the instruction like so right so we have"
5160480,5168240," an opcode which is just a byte then you have an argument right which is basically a tag"
5168800,5176320," plus value and depending on the arity of the opcode of that opcode you have a variable amount of such"
5176320,5185680," arguments like so and what kind of tags do you have what kind of tags do you have uh compact here it is"
5185680,5198240," compact uh term encoding so you have a tag literal integer atom x register y register label character and so on and"
5198240,5208160," so forth so basically that tag describes what that value means in here right so for instance the um label"
5208160,5215680," well some uh like a move instruction for instance it may accept a register it may accept the register"
5215680,5225200," and uh for example uh in that case tag is going to be x tag right so i was thinking why the do you need tags"
5225920,5234240," why the fuck do you need tags can't you just say okay opcode decides what that specific argument means"
5234240,5244720," but i just realized now move instruction as an argument may accept either immediate value an integer just a"
5244720,5253040," value or a register so depending on the tag it's going to interpret that value differently"
5253760,5262080," right so because move can get its source either from a register or it's an immediate value so that makes"
5262080,5272800," sense so that makes sense uh right and the the main s of the whole thing is how you encode the argument"
5272800,5283360," the tag plus value how you encode them right and here comes the most anal way to encode uh like arguments you've"
5283360,5289360," ever seen in your entire life so again if the value is less than 16 if the value is less than 16"
5289360,5298480," if the value is less than 16 then you encode that value within the upper five bits of the tag"
5299680,5304720," they you literally you literally fuse the tag and the value"
5304720,5320480," so oh boy right"
5322880,5333440," i mean this kind of hurts well it is what it is it isn't what it isn't uh the algorithm i mean that"
5333440,5345440," encodes and stuff like that uh actually um it's available right so bim encode uh bim asm encode here it is"
5345440,5352480," uh so it's uh so it's one one uh and there you go we can even take a look at this so we have a bin opcodes so asm"
5352480,5359280," erlang okay so and we should have a function encode so it's probably somewhere in code"
5359280,5367440," yeah there we go okay so here is the function that does the encoding right so there's you provide the tag you provide the tag"
5368240,5375120," and if i'm not mistaken the tags i already showed where you can find the tags opcodes hrl so here"
5375120,5380480," are all of the tags right so we have eight of the tags you provide the tags and you provide the value"
5380480,5386480," for the negative numbers you can encode negative numbers with this yes so you have a special way of"
5386480,5392560," encoding them right and it's somewhere down there right so it's a special one of them if it's positive"
5392560,5398400," right but less than 16 it's pretty straightforward it's actually very easy case right you just smash"
5398400,5405920," the value and attack together right if it's greater than 16 vital but less than this number you use two"
5405920,5411120," bytes to encode that so here is the formula that performs the encoding for two bytes so here is the"
5411120,5416960," first byte with some masks and stuff like that and here is the second byte and if it's bigger than that"
5416960,5423520," right so we can even take a look at what what's what's that value bigger than uh what uh just a second"
5423520,5431600," zero eighty two two thousand right so this value is two thousand it's bigger than that use use a special"
5431600,5438000," different encoding in code one uh right so and this one is rather"
5440800,5445120," i don't even know what it does i think it's a uh right"
5445120,5452160," so there's like additional functions and as far as i know if i understood correctly"
5452160,5461920," like all of these codes yeah so the algorithm to encode the argument is basically yeah it's basically this"
5464720,5478080," i suppose it's binary like a bitwise uh or yeah so there's also things like bsl which i can only guess"
5478080,5486160," bitwise shift left right i i don't know erlang that much but i can guess that it's a bitwise shift left"
5486160,5499440," there's also bsr which is probably bitwise shift right uh"
5499440,5506480," to be fair so this is the entirety of the algorithm right"
5510800,5517840," i'm sorry uh so this is the entire algorithm algorithm is not that complex but it's not that"
5517840,5524800," simple either uh right it's not that simple either so one of the things we can do we can actually"
5524800,5533280," implement it incrementally so essentially we can implement it only for n less than 16 right and for"
5533280,5539120," today's stream we're not going to use values bigger than 16. do we really need bigger than 16"
5540400,5549760," we need to encode 69 somehow for obvious reasons for obvious reasons we need to encode the 69 somehow"
5549760,5561600," uh so we'll see we'll see but anyway so let me let me see i have an idea what if i just take the up code"
5561600,5566080," and put them in here"
5569360,5580320," so in num a tag"
5580320,5586800," so in here i'm going to replace that with comma and this shift i'm going to replace it with this"
5586800,5593440," can i now do something like this"
5596640,5597200," get a tag"
5597200,5604000," get a tag so but i want this to be like a byte a single byte but maybe it doesn't really matter"
5604000,5613600," so the thing we can do we can say encode tag tag and then n and n could be u size but but it also"
5613600,5620080," could be negative so let's actually say i32 right so and in here we're going to return a vector"
5620080,5627760," of bytes right so depending on the value of the n it's going to be encoded with different stuff right"
5627760,5631840," it's going to be encoded with different stuff okay so what if i go"
5631840,5634320," to awesome"
5634320,5636560," and"
5636560,5646480," maybe i'm going to just put an assertion in there so if n is negative if n is negative i'm going to do to do"
5647520,5656080," negative right so this is not implemented else if n is less than 16 right less than 16"
5656080,5662960," uh we can literally just copy paste this stuff in here right can't we so"
5664800,5672800," let's say that tag is going to be tag as u8 right so we're going to interpret it as a byte and then n is"
5672800,5680000," going to be n as u8 all of that is just bytes all right so beat shift left so n"
5681120,5691760," four right and four tag and just like this so and then else"
5691760,5696320," uh large numbers"
5696320,5704400," we can do something like that right so unless we encounter something that is bigger right so"
5706400,5709040," i don't freaking know i don't freaking know"
5709040,5718480," uh so all right so how do we do that um where's the code chunk code chunk"
5718480,5729680," uh code chungus uh so function count out of after the function count the code starts after the function"
5729680,5736480," count the code starts let's say chunk push and we need to put the opcode uh for the label there"
5736480,5743440," what's the opcode for the label it's actually one right so i need to put one in here"
5743440,5750560," and then i'm gonna do chunk push and for the label i don't remember what's the label has to be"
5751360,5757680," is it has to be there's already a label in here but i think it's used for referring to the label"
5757680,5764240," um i think it has to be an integer so let's actually try to use an integer in there"
5764240,5773200," so encode tag i so we can also like see what kind of errors that encounter hopefully"
5773200,5779680," and uh they have to start with one i vaguely remember from the book that labels also start with"
5779680,5786400," one right so atoms start with one because zero is a new and labels also start with one you know why"
5786400,5795520," because label zero is considered no label or invalid label why do you need a no label or invalid label"
5795520,5800240," there are instructions very interesting instructions so there's a list of instructions in there so generic"
5800240,5807680," instructions uh i think it's something like gc beef two right so it's basically called to a built-in"
5807680,5815600," function so beef stands for built-in function they have interesting arguments they have arguments lbl"
5815600,5826400," label label and label is where to jump if the built-in function fails on failure jump to lbl"
5827280,5834800," right so in your code you can generate uh error handlers you can generate error handlers to which"
5834800,5841440," a certain functions will jump in case of an error so if you don't have an error handler you can put a"
5841440,5845600," label zero in there and that's an invalid label and that will generate some sort of runtime error"
5847440,5854720," so i suppose this kind of stuff may be needed for try catch things um maybe that's that's an interesting"
5854720,5863680," yeah essentially if you compile and try catch block or every call to built-in function or maybe not"
5863680,5870240," built-in function that accepts a label where to jump in case of an error you can set a label to the catch"
5870240,5877200," section and that kind of automatically that kind of translates from erlang to the byte code nicely"
5877200,5884640," i think that's that's why it is like that so and again labels start with one because label zero is"
5884640,5891680," that means you don't have any label you don't have any place to jump to uh so yeah so let's let's put it"
5891680,5898880," like that so to be fair like referring to the opcodes with numbers is kind of mad what if we had like"
5898880,5906240," opcode enumeration as well similar to the tag enumeration all right so we're starting to build"
5906240,5914640," up our own bim library chat our own bim library isn't that poors isn't that poors opcode mother"
5914640,5921440," flippers loop code and here we're gonna have label and it's just one so and uh here i can just do opcode"
5921680,5933280," uh label as you can i also say that i want to use u8 as an internal representation for the enumeration"
5933280,5941920," can i do that in rust can i do that in rust rust under lying type for enum"
5949600,5951840," so internal type"
5951840,5954160," inner"
5954160,5957520," oh yeah"
5957520,5965040," i remember they couldn't come up with the syntax for that thank you so much"
5965040,5973280," i vaguely remember that yes yes yes they this is goofy like that um there is no syntax for this"
5973280,5979520," thing so they just ah whatever just slap an attribute on that like i mean this is we can't update our"
5979520,5984880," our parser our parser our parser is too complicated for this kind of just slap an attribute on that"
5984880,5990720," anyways"
5990720,5998480," uh so you see but i mean it's probably not important for us to be saying um"
5999760,6002560," in code mismatch types so"
6002560,6011280," extend extend extend all right so we have a lot of unused to get freaking done it"
6011280,6016000," can i just comment out all this"
6016000,6031360," let's go to urlinc and what we're doing here we were trying to disassemble this i think uh no func info in code segment"
6036800,6037120," okay"
6037120,6044320," that's really funny so uh okay so you you must have something in there"
6044320,6048160," you must have something in there that's that's so funny okay so"
6048160,6058000," uh usually like you have a label funkin4 and some other stuff so for the funkin4 you have atom atom"
6059120,6067120," and zero i suppose it's everything snap back to reality so uh oh here it is here it is"
6067120,6073920," mfa funkin4 mfa define a function okay it is everything"
6075680,6082080," more fucking everything more fucking everything all right so let's go ahead and try to do that"
6082080,6089680," so funkin4 funkin4 here it is it's the second one it's funny how the first these are the first"
6089680,6097440," instructions in erlang vm so that means they are most important is label and function information"
6098640,6106080," not like push data or something like or move data no this is just like labeling function flow int code end"
6106080,6116560," i don't know so we need to have a funkin4 um so this is going to be two"
6116560,6128480," legal all right chunk push up code funkin4 as you ate so and the first thing"
6128480,6137440," has to be an atom uh right encode and for the atoms i think we have a uh compact"
6137440,6150320," yeah tag a is an atom tag a is an atom and uh atoms are numbered starting from one so and this is the"
6150320,6156240," name of the module so we'll already have bada in there right so that means we can put a in here and"
6156240,6163360," what's funny is that maybe in the future we're going to accept atoms in here right and then i'll be able"
6163360,6171440," to just query this kind of stuff okay i'm getting ahead of myself too much all right i'm getting ahead"
6171440,6177680," of myself but we can actually have bada module bada function within the bada module"
6179680,6185840," yeah so we can do that right so it means we can do uh one one and that refers to the same atom so it's"
6185840,6192640," a uh we're using the same atom both for the name of the module and for the function so uh and i suppose"
6192640,6197360," for the reality for the reality we're going to have integer in here so there we go so we have a label and"
6197360,6203920," we have a function and for are you happy now um as far as now you need another label in here to sort of"
6203920,6211360," like um to denote where the body starts and as far as i know in opcodes you also have a return"
6211360,6218400," right and that returns from the function so we might as well put a return in here just in case"
6218400,6226240," so am i getting ahead myself once again so i think it's kind of dangerous it's not three it's actually 19."
6227040,6234000," so let's see if it's going to actually help with anything so there's no a in here all right so i a"
6234000,6240960," i a okay so we generated some shise so let's see uh bada bim bada boom"
6240960,6256320," uh-huh i zero i zero function close invalid resolve org and a set okay wait wait wait wait wait and"
6256320,6265600," unsigned so it was trying to resolve an unsigned argument but it encountered a signed one so"
6265600,6273520," maybe we're supposed to use this one uh so tag i so there was a zero so for the function and for it"
6273520,6279520," wants to have u in here is that what it was maybe we have to use u for labels as well because i don't"
6279520,6288560," expect the labels to be negative okay so u is not really this thing says that u is a literal and i is an"
6288560,6297840," integer but u is i suppose u is unsigned it's unsigned right that makes sense i think so unsigned"
6298560,6312320," unsigned uh atom x register y register f is f is a label h is a character h is a character and z i think"
6312320,6318240," it's extended or something i don't remember what is z because there is extended stuff like a flow at least"
6318240,6321360," floating we're probably not going to go into this complicated shift today but yeah"
6322320,6327040," um so i i think that's what it is okay so let's try to compile this entire stuff and"
6327040,6329520," uh"
6332400,6333040," okay"
6333040,6343840," function button label one function for butter butter zero arity label return"
6343840,6355360," but this is only the disassembler uh this is only the disassembler so we are capable of generating the"
6355360,6356560," instructions already"
6358640,6365200," and we didn't even have to implement the full annual way of encoding right because we don't use"
6365200,6375520," like numbers bigger than 16 uh numbers that are bigger than 16. so we we yeah so we don't go that"
6375520,6383120," deep into the annual encoding right we don't have to go that deep all right so the disassembler seems to"
6383120,6390640," be happy what about the virtual machine itself right can we load the butter uh okay"
6390640,6401040," oh invalidly ah invalid label number we have a label count do you guys remember a label"
6402080,6415680," that's funny how disassembler doesn't care about that that's actually kind of funny"
6415680,6423600," well i mean we have two labels right so there's two labels and since we're having a function i suppose"
6423600,6430720," there's one function in here i guess so so far so good right so let's try to compile this into i think"
6430720,6435280," uh op aligned"
6435280,6439680," op aligned label label num"
6439680,6448320," that's bizarre so tag you do you want the label to be"
6448320,6452560," let's put three in there then that's a bit bizarre so"
6453280,6456960," so do you do you mean that the label zero is a valid label in that case"
6456960,6466160," maybe i misunderstood the documentation invalid op code invalid op code okay that's that's bizarre"
6466160,6470240," uh invalid op code"
6472880,6486560," invalid code code code code code code segment did not end with int code and i remember seeing that i"
6486560,6494320," remember the scene that should wait a second uh int yeah you didn't know the end of the code section with"
6494320,6502720," this one all right and it's arity has zero so you don't have to do anything okay that's cool uh so let me let me see"
6502880,6504320," okay so we have that"
6504320,6507920," three"
6507920,6517040," uh code code code chungus here's the code chungus"
6518400,6525120," so chung push up code code code code why is it called"
6525120,6527760," int code and"
6527760,6531440," into interrupt integer"
6531440,6537440," i'm freaking now uh okay so those we have"
6537440,6543440," no warning anymore so there was a warning now there's no warning so everything seems to be fine"
6544240,6546480," okay so uh if i try to load this"
6546480,6556160," we just loaded much"
6556160,6558560," thank you"
6558560,6572160," okay so here's an interesting thing uh there's no bada function in here"
6574240,6585440," actually every module that you load it always has at least a function called module info"
6585440,6594480," right so which brings in information about the module right uh but bada doesn't have that thing"
6595920,6603840," so and this is something interesting the uh the reason why every module has module info"
6603840,6611280," is because of the erlang compiler it is not something that is built into the virtual machine"
6611280,6617680," of erlang it's something that is built into the erlang compiler if erlang compiler didn't generate that"
6617680,6624080," function it would not exist right so you can take a look at the module hello.erl right so it doesn't"
6624080,6633120," implement anything but hello right but if you take a look at uh module info right and what it exports"
6633120,6640640," uh it actually exports not only hello but also module info with error to zero and module info with error to"
6640640,6649040," one so the erlang compiler generated those additional functions for you implicitly but since we now generate"
6649040,6654320," everything we don't generate that so there is no such functions in the module this is kind of interesting"
6654320,6662240," so if you take a look at the assembler disassembler build this asm file uh hello bim and you would see"
6662240,6667120," how these functions are implemented so here are the functions within the hello here's the hello which"
6667120,6673280," just calls hello and then you have module info so what does it do uh so this is a standard preamble of the"
6673280,6682320," function then it moves atom hello into the register x and calls external function called erlang get module"
6682320,6690560," info even if the module doesn't have module info you can still get information about the module if you call"
6690560,6695760," this function directly honestly i have no idea why the compiler generates this function"
6696560,6701040," because what it does it just calls to the standard get module info function like why"
6701040,6708800," it's kind of silly it's kind of goofy but you insert this thing into every module and it's just like"
6708800,6719680," okay so i can't do uh module info i can't do module info but i can do erlang get module info"
6720400,6731680," bada and it can get module info for the bada so and we can notice that bada doesn't export anything even"
6731680,6741280," though internally internally it does have a single function called bada it doesn't export it"
6743120,6748400," it does not export that function so that's why you can't call bada bada"
6748400,6754480," so to make this function accessible we need to export it"
6754480,6760880," uh so let me see what we can do about that so where is the experts"
6760880,6768480," so exporting thing is rather straightforward right so it's a function name arity and the label"
6768480,6773600," um right so we know that it starts a label one or something so okay so export is going to be one"
6773600,6786080," uh so next thing um it's going to be chunk extend uh function name function name is an atom"
6786080,6793760," we already have one atom bada in there right so here's the atom bada so that means it's it's an atom one"
6794320,6803440," 32 to to be bytes uh right to be bytes so the next thing has to be the arity right arity is zero in"
6803440,6811520," our case so it doesn't accept anything and the label so let's see i don't remember which label you have to"
6811520,6819520," provide exactly i don't really remember what's the code chunk um code chunk"
6821040,6828800," okay so the label before funkin4 or the label after funkin4 i don't quite remember honestly"
6828800,6836160," i think it's the label before funkin4 because the runtime needs to get information about function"
6836160,6841120," before starting executing it it's it's needed for the debug purposes or something like that so i think"
6841120,6846480," we have to jump to the level one rather than the label two to be fair i'm not really sure why you need"
6846480,6853440," the second label it kind of denotes the like the body but maybe it's needed for i think i know what"
6853440,6857840," it's needed for i think i know what it's needed for it's probably needed for tail call optimization"
6857840,6864000," right when you have a tail call recursion right when the function calls itself in a"
6864000,6870160," tail call way it's probably not calling the function it's probably jumping to the beginning of the body like"
6870160,6875440," that so that's probably why early compiler generates this additional label uh at the beginning of the"
6875440,6881040," function body this is my hypothesis i don't really know for sure but like i mean if if i were implementing"
6881040,6888720," or look i probably would do it like that uh so yeah so because of that we have to jump to the label one"
6888720,6890800," if we're going to be expert in that specific function"
6890800,6907040," experts uh experts chunk uh experts chunk all right so chunk extend extend 132 to be bytes so this is the"
6907040,6914640," label one and that's it right so now expert count blah blah blah so let's try to recompile this entire thing"
6914640,6921520," so it complains about this thing that's used so okay so for now we use only unsigned integers and atoms"
6921520,6930880," um erlang is heavy on tco yes it is because it doesn't have loops like at all it does have these"
6930880,6936560," comprehensions right so you can kind of say that it's kind of loops but generally doesn't have anything for"
6936560,6943920," for looping so you you must use tail call uh because it's better so i think there was a funny"
6945200,6951840," funny tweet about that on twitter recently does anybody know i think it was about a camel so"
6951840,6961120," the the the the sign was recursion is better than full loops because there is no modifications so like"
6961120,6967920," and there is no state so it's very easy to reason about recursion and just like very complicated or camel"
6967920,6972960," code that doesn't use for loops and just like pure recursion is just like a recursive spaghetti if you see"
6972960,6981680," ever seen one right so it was so fucking funny because i programmed in a purely functional style"
6981680,6987360," very complicated shit and i know precisely what people talking about like you can have spaghetti code"
6987360,6994880," in a pure functional code with recursion it's fucking insane that you can have spaghetti code like that but"
6994880,7002880," you can uh and sometimes it's just way more readable to to just do for loop believe it or not so"
7002880,7008240," uh purely functional recursive spaghetti"
7008240,7016000," did aoc and haskell in spears spaghetti yeah it's insane because you wouldn't even expect that you wouldn't"
7016000,7024160," even expect after all of these promises of easy to reason code no side effects ponies and unicorns and"
7024160,7028320," it's just like oh my god it's just like and you look at that holy fucking shit"
7031360,7040640," so all of that is a lie all of that is a lie don't believe those goddamn functional programmers they're"
7040640,7045440," literally lying to you they're not only lying to you they're lying to themselves"
7049440,7057760," anyways uh so what do we have in here so we generated the expert so let's see what we have in here um so"
7057760,7066000," let's try to load reload the module uh where's the code uh okay so we managed to reload the code"
7067040,7078720," and uh now if i try to get module in four look at that look at that but a zero experts a butter beam"
7078720,7091600," a butter boom uh so can i do butter butter"
7097040,7105680," uh but it's but it's but it's there so it's it's zero"
7105680,7116880," huh so uh get module in four i can try to disassemble that as well beam disasm maybe i have to put"
7116880,7123760," something into the return right so the values are returned through the x register if i'm not mistaken"
7123760,7127760," right so disasm file uh badabim"
7127760,7130800," uh-huh"
7130800,7138960," because the the arity is zero here the arity is zero so the function zero what is two though"
7138960,7144880," what is two though uh okay"
7148800,7149520," experts"
7149520,7149520," experts"
7149520,7152240," function"
7152240,7160080," arity so function one arity zero label one uh then code the chunk code the chunk"
7160080,7167440," functioning for atom that one arity zero that makes sense"
7167440,7176960," uh so let's try to maybe move something into the x register so let me see generic where is the generic"
7176960,7181120," instructions generic instructions generic instructions there was a move instruction somewhere there"
7181120,7191120," okay so move the source to the destination register okay so now let's give it a try"
7192960,7197840," opcode um move 64 okay"
7197840,7203280," uh opcode move 64"
7203280,7220640," before return chunk x push opcode return uh move excuse me so and the first thing is the source the source we can put"
7220640,7227920," maybe a value uh 69 we can't encode 69 because it's bigger than 16 so we can probably put something like"
7227920,7229680," six right so this is going to be tag"
7229680,7238080," uh u uh six right so this is the source the destination is going to be chunk push and it's going to be a"
7238080,7243920," register the register through which we return things is x right and it's it's zeros one right it's the zeros one"
7243920,7249360," right it's the zeros one so we're going to move six into the register x and hopefully that is going"
7249360,7254800," to be returned from the function uh so we're programming an assembly basically almost directly"
7254800,7261920," we're programming an assembly uh almost directly okay so this one has to be as u8"
7263600,7271120," what else do we want in here so this one has to be more like extend and this one"
7271120,7274480," x is not available so let's make it available"
7276880,7287840," okay so learning uh can i just recompile uh let's actually do disassemble uh so disassemble okay"
7287840,7297840," that's cool so that's recognized by disassemble move six into x right so move six into x and then return"
7298320,7306960," so we can even double check if that is the case with hello right so six uh right if you just return"
7306960,7316720," six out of the function right so what is going to happen uh so six zero and then i can try to disassemble"
7316720,7328160," hello uh six uh oh but this one uses integers specifically and i think integer is the tag i uh tag i"
7328480,7339040," so maybe that's the tag we have to use um so this is going to be tag i tag u6 so let's say tag i"
7339040,7352080," okay disassemble better better yeah so now this one uses uh integer six and moves it in there okay"
7352720,7355840," so code load file better"
7355840,7362080," not purged"
7362080,7375840," i remember i think like you can't really reload already loaded module unless it was first purged whatever the"
7375840,7379440," fact that means okay so erling purge module"
7379440,7387440," because i don't know why honestly it's freaking early"
7387440,7391200," oh i think there's a function for that"
7391200,7403440," purge one yeah there's even soft purge so purchase the code for module that is that is removes the code"
7403440,7408160," marked as old if some processes still linger in the old code these processes are killed"
7408160,7415600," before the code is removed ah i see so maybe you have some processes that still use it right so that's"
7415600,7423040," why it needs to be purged explicitly and stuff like that okay so uh i suppose we're gonna do code purged"
7423040,7430480," better and right and then we're gonna load the code we can even do something pretty cool because we can"
7430480,7437920," chain operations together right so load file uh better boom and that purges and loads a new version"
7437920,7444720," simultaneously right because the comma is a single separator essentially so can i do butter butter boom"
7447680,7454880," that didn't help honestly that didn't help so we have a function but we can't return from this function"
7454880,7461920," um so we can't return from this function so let me see if i"
7461920,7467360," forgot to do something did i forget to do something about that so"
7468400,7478800," opcode max label count three function count one did i forget maybe align things"
7478800,7485280," uh so did i forget to align things i don't freaking know"
7485280,7493360," maybe i have to jump to a different okay what if i have to jump to a different label"
7496400,7497200," there's also"
7497200,7505520," what if i set label two experts"
7505520,7513600," label so let's see if i set label two in here maybe that's the label problem"
7513600,7517680," so let's just try to purge and"
7517680,7525440," apparently i was wrong about tables apparently i was working by other tables"
7526160,7538400," uh so what was the problem let me let me show you so i need to disassemble the file"
7538400,7546640," let's disassemble so essentially there's two labels before the function for and after function for the"
7546640,7551840," reason why i put two labels before and after is because the early compiler does so so i have no idea"
7551840,7557920," why i'm just repeating after early compiler uh right so i thought that the beginning of the function like"
7557920,7563680," the label that you have to put in the export as the beginning of the function is the one before funkin4"
7565200,7578000," apparently i was wrong so i just changed it to label 2 right which skips funkin4 and it worked"
7578000,7582480," so yeah i don't freaking know i don't freaking know so"
7585040,7591760," uh so the problem with all this stuff is that it's half as documented right even the bim book"
7591760,7598080," is not finished right so there's a lot of things here that are straight up not documented right so"
7598080,7606720," especially the further uh uh chapters some of them say to be done or something right so not everything in"
7606720,7613760," here is documented uh so the shell so there's some stuff in here that is just like missing"
7613760,7620880," so and like a lot of the stuff you either have to get from the code or guess or something like that so"
7622320,7628400," i wonder if people who have a lot of knowledge about this system they get probably paid really well"
7628400,7637920," because they're pretty serious uh systems that rely upon this i think you can actually"
7637920,7644080," get a lot of money by knowing all that stuff i feel like right because there's probably some"
7644080,7649440," complicated telecom systems that use all of that stuff and they need people who understand this"
7651280,7662720," but they're actually pretty cool maybe i should just learn all of that purely to uh purely for the"
7662720,7673920," money right how do you dig up such exotic languages dude if you think erlang is an exotic language you"
7673920,7681200," probably only recently started the program erlang is not an exotic language it's older than python and it's"
7681200,7687760," like it's like it's industry standard for telecom you're just like you're just not aware of it it's"
7687760,7690960," not an exotic language it's it's it's a freaking standard"
7690960,7697520," uh so i would i wouldn't call erlang an exotic language honestly"
7697520,7705600," erlang is not used in telecom anymore but cisco is using it huh that's very interesting why is it not"
7705600,7709280," used in telecom anymore right i mean this is actually pretty well suited for it"
7709280,7713040," elixir is very popular in it"
7713040,7726000," why do i need elixir i can write my own compiler into the into the erlang virtual machine"
7728080,7736320," it's too easy too easy it's okay so the only difficulty is uh encoding of the arguments okay"
7736320,7741920," okay okay so the this is like an unsolved computer science problem is implementing the encoding for the"
7741920,7749120," arguments uh over the virtual machine of erlang but i think we can do that i think we can do that i think"
7749120,7759360," we can port uh the second case i think porting this case is not that hard honestly"
7759360,7765440," i think we can do that i think we can do that so let's actually go ahead and do that so essentially"
7765440,7773600," what we want to be able to do what we want to be able to do so code changus code changus we are trying"
7773600,7781440," to return not six but 69 if you try to compile this entire thing it will crash because not implemented"
7781440,7789840," large numbers we don't know how to encode large numbers right so uh we can implement very specific"
7789840,7793920," large numbers that are less than um this"
7793920,7803840," these ones and to implement them we just need to port this specific thing this specific line okay"
7803840,7814400," so um so we are actually first of all we take n right and since it's a positive number i might as"
7814400,7823920," well actually maybe say that it's going to be u32 then i'm shifting that number to the right by three bytes"
7823920,7830000," right so that's the first thing i do i take n i shift it to the right by three bytes and then i do bend"
7830000,7839440," uh with this mask so i'm bending that mother flipper with this specific mask like so so i just bend it"
7840480,7847920," uh okay so we'll get that then i bore it with the tag right i bore well i mean i have to do it like that"
7847920,7857200," so uh tag let's say the tag is going to be as you said so uh tag and then i bore it again with this mask"
7857200,7864960," i just bore this again with this mask so it actually has to be b excuse me it has to be it's also probably"
7864960,7875360," has to be u32 um so did they copy the mask correctly i feel like i want to recopy zero b boom u32"
7875360,7891040," okay this is the first byte this is the first byte uh as u8 okay i have no idea what any of that means"
7891040,7896320," but do i really need to uh but do i really need to know that i don't think i need to know that so the"
7896320,7907200," second byte the second byte is this so i'm taking n and i'm bending it uh with just this uh ff"
7907200,7916720," all right as u8 okay and so that is basically the encoding"
7917920,7922320," so i probably made a mistake somewhere so i probably made a mistake somewhere but i mean"
7922320,7931360," so that will allow us to uh encode the values up until 2048 which is actually quite a lot like"
7931360,7940000," do we even need larger numbers at least for now so 2048 is going to like last us for quite some time"
7940000,7946720," already i think and it's only going to be like for immediate values right so we don't need these large"
7946720,7952320," numbers for doing large computations right because if you accept large numbers through registers you're"
7952320,7958960," just passing them along between registers so you don't need to operate uh on such large numbers immediately"
7958960,7968080," so like we quite rarely would need that negative numbers they would be needed but i implemented an"
7968080,7975120," entire self-hosted language without negative numbers so negative numbers are not that much of a necessity"
7975120,7982560," in fact humanity civilization lived quite comfortably for a very long time without invention of negative"
7982560,7988320," numbers people were doing math and arithmetics and economy and stuff like that without negative"
7988320,7995760," numbers for quite some time so you can live without negative numbers like i'm saying that and ironically"
7995760,7998800," actually the same way you can live without imaginary numbers"
7998800,8010480," so yeah so i think for now this encoding is more than sufficient right so and we can implement the rest of"
8010480,8014640," this case is like later so i think that's that makes sense"
8014640,8024640," so so you come to the boss and boss asks you why didn't you implement negative numbers for our new"
8024640,8030720," programming language that we sell into our customers and you be like you know humanity didn't invent negative"
8030720,8050960," job security exactly and then you're fired exactly"
8050960,8065840," so okay so that means we should be able to now encode a 69 okay let's see if i manage to do that so"
8067120,8073200," i probably fucked something up look at that we actually did it successfully"
8073200,8083680," okay that encoding well i mean even though it is anal it is not as scary as i thought okay so"
8083680,8092240," all right so this only scary part are negative cases and the numbers that are bigger than 2000 right so and"
8092240,8098320," if you are within the range of like 2000 it's actually not that scary it's just a couple of formulas that you can just retype"
8098320,8099360," so"
8099360,8104960," all right that's pretty cool okay so let's just try to purge this mother flipper"
8104960,8108560," bada bim a bada boom 69"
8108560,8115840," that's pretty cool actually"
8115840,8118240," it's pretty cool"
8120960,8128240," what the the the most funny part is that we generated it entirely in a language that has"
8128240,8129600," nothing to do with erlang"
8129600,8136480," this link like we just generated it in in rust so we sort of like a cracked the code"
8136480,8140480," and we didn't use any of the built-in erlang facilities"
8140480,8150480," right it's just like it's a rust file that uses only two things two things who can tell me what kind"
8150480,8155120," of things does this file does this file use vector and write"
8155120,8167040," you don't need anything else to write a compiler for erlang virtual machine you need vector and write"
8169760,8177200," and it just demonstrate it to you like this it's too easy you can add a read into that and then you can read"
8177200,8184640," a certain file all right and you can then compile that file down to something so you can maybe even"
8184640,8193280," invent some sort of a language uh test language butter and obviously we don't really have that big of a generation"
8193280,8198960," generation capabilities as of right now we don't really have very big generation capabilities but"
8198960,8204560," we can invent sort of like a programming language that lets you define erlang functions"
8204560,8207600," and assign numbers into them"
8211760,8218720," you know what i mean uh then it collects all of these functions and like literally generates like"
8218720,8227200," erlang module with these functions that return this now we can already do that it's a dumb language"
8227200,8234000," it's a stupidest language you can come up with but it's a legit language and it will compile down to"
8234000,8241280," erlang virtual machine you can technically do that how much time will it take for us to implement that"
8241280,8247680," how much time it will take to implement first i kind of want to do that i kind of want to do that"
8247680,8252960," but i mean already streaming for three hours but um"
8252960,8258480," i need to make a small break right so let's make a small break i'm going to make a cup of tea"
8258480,8262480," i'm going to make a cup of tea and once i have a cup of tea we're going to try to tackle the task"
8262480,8269440," of parsing this file and then generating um erlang module out of that file with all these functions"
8269440,8274640," and stuff like that so and once you have that you can start extending the syntax"
8274640,8280400," by adding maybe i don't know like sequence of numbers and then plus operations and stuff like"
8280400,8284640," that i mean who knows right so you need a point from which you can start instead"
8284640,8291760," camera noises or just me yes there are some camera noises like i live in the novice abysk near"
8291760,8293280," the nuclear institution"
8293280,8305440," i'm not even joking we have a uh the nuclear research institution uh like nearby"
8305440,8314720," like i'm not joking we do have a nuclear research institution here"
8314720,8323360," uh within novice abysk there are rumors that those motherfuckers hide a nuclear reactor"
8323360,8330160," it's the funniest shit ever so there are rumors that there is somewhere a nuclear reactor"
8330160,8336000," and every time somebody asks us this goddamn scientists they say no there is no nuclear reactor"
8336000,8342240," no nowhere but we we know we know we know these motherfuckers are hiding nuclear reactor somewhere"
8342240,8350000," anyway uh so let's make some break um all right so let's actually not start with parsing these shites"
8350000,8356400," let's start with not parsing it so i think what i'm gonna start with is actually"
8357280,8364960," with defining a hash table right so we're gonna have a hash table uh which is gonna be let's call it the"
8364960,8374080," program right so this is a program hash uh new so maybe i'm gonna uh actually say that it's a mapping"
8374800,8382960," it's a mapping from a slice a string slice to to a number right so use size or something like that"
8382960,8387760," and we're going to basically push a bunch of things in there so we're going to push hello"
8388320,8393200," uh which is going to be 69 and the world which is going to be 420 right and we're going to just"
8393200,8402880," restructure like massage massage the code to compile this hash map to compile this hash map"
8402880,8408800," into the b module right so essentially we're going to assume that all of that stuff is already pre-parsed"
8408800,8414400," for us right we're going to put the parsing like um you know out of the equation right"
8416400,8423360," and we'll see how it goes we'll see how it goes so we need to be able to collect all of the"
8423360,8431040," um all of these things in there all of the keys in a in the program and turn them into a list of atoms"
8431040,8437920," right so now we're going to have a variable list of atoms uh so let me see so as far as i know in"
8437920,8443120," the program you can take keys right so and that literally gives you keys and we can try to collect"
8443120,8452080," all of that stuff um right into into the atoms maybe in fact we could have something like atoms"
8452080,8457120," which is a vector because one of the atom that we're definitely going to have in here is the name"
8457120,8464800," of the module itself which is a button right and then we can say that we're going to extend the atoms"
8464800,8469520," with the keys right so all of the keys that you're going to have in here all right so we're going to"
8469520,8475760," push them into the atoms and there go we got all the keys we might as well even print this entire"
8475760,8481440," stuff so let's actually say atoms uh the atoms that we managed to collect here are the atoms"
8481440,8488400," and i'm going to try to just run the button so we don't have a hash or anything like that so let's"
8488400,8496400," actually do use std collections collections hash map i think that's what you're doing here there we go"
8496400,8504720," so what do we have in here uh so yeah we have to put colon in here and push um so method push not found"
8504720,8511440," in the current scope i think it's not called push i think it's called insert in case of hash map there we"
8511440,8518240," go so here are all of the atoms here are all of the atoms that we've got okay that's pretty cool"
8518240,8523920," so now when we want to generate the atom chunk we can just say okay so here are all of your atoms"
8523920,8530560," there are all of your atoms so that's pretty cool and uh so when we try to compile this"
8530560,8535920," and i think and then we're going to go into the into this stuff we can try to maybe take a look"
8536720,8547520," at the parser so if i do bim uh read bada bim all right so this is but the beam uh i did the"
8547520,8554160," fucky walkie oopsie doopsie and here are all of the atoms right so we have bada world hello"
8554160,8560240," they are in a little bit of a weird place right to be fair they are in a little bit of a weird place"
8560240,8568720," but that's maybe fine so that is maybe fine i kind of feel like i want to have this system that"
8568720,8576720," automatically uh you can insert atoms and then you can query atom ids so that's one of the things i"
8576720,8582720," would love to have right so maybe it's going to be like a structure structure atoms uh right and one of"
8582720,8595920," the things you can do here is essentially fn get id right get id and you can get a mutable self and the"
8595920,8603280," name of the atom and what it will give you it will give you the size of that specific atom uh right and"
8603280,8610160," as you can see it's actually it actually mutates the atoms it actually mutates the atoms and uh here we have"
8612720,8620080," uh which probably stores the strings so it probably needs to uh you know own them all right and uh the"
8620080,8626240," result here is going to be that so when essentially when you're trying to get a certain thing right so"
8626240,8636240," get uh the name right you're trying to get name if you found it uh id you simply return it but if you"
8636240,8642560," didn't find it that's where it gets interesting so we also probably need to get some sort of a"
8642560,8646240," counter right so counter uh use size"
8646240,8654720," so and essentially we increment counter by one right we increment counter by one"
8654720,8666960," then we do self inner well i mean it's it's inside of the self uh insert name to string uh self counter"
8668640,8674480," self counter so we insert that stuff in here and then we just return the counter as the id"
8674480,8680400," so as you can see if it doesn't exist it's going to be added in there and so on and so forth right i"
8680400,8686400," think that's a pretty good idea so and we need a way to construct this entire thing i think the default"
8686400,8693200," construction should be more than enough so this is going to be something like default default construction"
8693760,8701680," so and now i can do atoms default uh so and essentially i could have actually implement"
8701680,8708880," extent for the for the atoms right so but i mean i can do something like this um so essentially key in"
8708880,8718640," program keys uh right and i can do so i'm basically and since it's sort of like a lazy like that"
8718640,8726400," since it's so lazy maybe now it would be better to actually pre-allocate all of them"
8727360,8738080," will be actually better to probably kill them hmm but maybe what if we generate atom chunk the last"
8738080,8743840," because i feel like it doesn't matter in which order you you put them right i think it doesn't matter"
8743840,8752720," i'm pretty sure it doesn't matter um all right so let me let me see so i'm gonna actually back off a"
8752720,8759440," little bit all right i'm gonna back off uh and uh try to generate the atoms last because"
8759440,8767520," it would be kind of nice it would be kind of nice if we passed the atoms like everywhere in all of these"
8767520,8774480," chunks as we generate the code and imports and exports and atoms like lazily collect all that stuff"
8774480,8780080," and then at the end we generate the final list of atoms like that you know what i'm talking about"
8780080,8785040," that would have been cool right so that way we don't even have to think like how many atoms we're"
8785040,8790160," gonna have we just generate as we go referring to different atoms and we just collect them and on the"
8790160,8796160," data we just generate the final list of atoms and that will work uh but i feel like right we need to"
8796160,8802880," confirm that this kind of stuff is going to generate a valid code at all right so let me see"
8803680,8812640," uh so we have a code chunk uh all right so let me remove that thing so id this is a pointer can i just"
8812640,8819040," pattern match the pointer like so is that something i can do uh okay so that seems to be working so let's"
8819040,8826800," go into erlang uh let's go into erlang and try to read this entire thing okay our parser managed to read"
8826800,8831840," that successfully what about the disassembly disassembly disassembly didn't like something"
8831840,8840480," disassembly really didn't like something extract atom oh yeah this is because we didn't put anything so"
8840480,8847760," we need to have at least one atom in there that makes sense uh i do agree with that okay"
8849760,8857600," mm-hmm so and then if i try to disassemble that okay so disassembler is fine with the atom chunk being"
8857600,8864640," at the end so it is totally fine with that uh what about the uh actual virtual machine is virtual machine"
8864640,8870720," fine with this kind of shit virtual machine seems to be fine so you can actually put the chunks in"
8870720,8877280," whatever order you want that is pretty cool that is pretty cool i'm gonna try this idea of actually"
8877280,8886080," generating atoms the last because new atoms may appear as we go sort of speak new atoms may appear"
8886080,8891520," as we go so when we're generating the code when we're generating the code we're going to be accepting"
8891520,8900960," the problem right uh how a hash map so it's str to your size and this basically this is basically the pro"
8900960,8906960," the number that the function should return uh right and we also should accept the"
8906960,8914960," atoms by a mutable reference right so that's basically what we have in here that is basically what we have"
8914960,8923120," in here uh so we are generating the chunks um the label count the label count is going to be"
8923120,8928560," this is actually rather interesting how we're going to approach this entire stuff so"
8929600,8937600," we have three we have three i suppose i can say we're going to have two labels per program right two labels"
8937600,8947200," per program so that means i can say len multiplied by two right we can do len multiplied by two though we can"
8947200,8959280," just simply generate code in a separate chunk as well right so we have chunk then the code and then the result"
8959280,8969120," result we can simply put this entire stuff into separate vector as well if that makes any sense"
8969120,8981520," if that makes any sense so we can say let code and it's also mutable vector new like so and i'm gonna just"
8981520,8992400," quickly replace that that's a code and then in here we can have label count and function count right label"
8992400,8999680," count and function count and we can uh put them up there and we can make them mutable so that means as we"
8999680,9006240," generate the functions as we generate the functions we're going to be incrementing these labels we're going to"
9006240,9011200," be incrementing these labels right so initially they are zero but we're going to be incrementing them"
9011200,9014640," we're going to be incrementing them um okay that's cool"
9018720,9029600," so i'm going to be iterating the name and result in program so that's what we do name and result in"
9029600,9040880," program uh so we generate a number like a label so to do that we're gonna do label count plus one label"
9040880,9049280," count plus one and we're gonna just use that label count that makes sense i think i think that makes"
9049280,9057520," sense so the next thing we do we need to use atom for the module right so atoms get id for the module"
9057520,9067600," badda right so that's the module name then we do uh atoms get id for the name of the function uh actually"
9067600,9072320," yeah so it's not string literal what the fuck am i doing yeah for the name of the function so that's what"
9072320,9079360," we do the average of this function is going to be zero right so the average is headcoded so since we"
9079360,9084000," keep repeating the bada over and over again it's going to use the same id in there right it's going to"
9084000,9091440," use the same id in here so next we generate another label i can actually copy paste that specific chunk"
9091440,9096720," of code i may actually factor out this code right every time we generate a label we increment the label"
9096720,9103520," and so on and so forth so then we generate the move instruction and we move in the actual value in"
9103520,9110160," here right so this is the result we have to put in here uh like so maybe we have to even dereference"
9110160,9117040," some of this stuff like so we put it into the x and then we return and i suppose this instruction"
9117040,9123280," should be at the end of the code this section at the end of the code section uh all right that's cool"
9123280,9131760," so uh and what's funny is that we also need to increment the function count every time we encounter"
9131760,9137600," a new function so it's a function count plus one right so new function function count and all of that"
9137600,9143520," that is going to be encoded down below in here and then a chunk is going to be extended with"
9143520,9150480," the code and then the result is going to be extended with the chunks so we have like a two nested"
9150480,9157760," process of generating the code right so we have something like that that is very interesting actually"
9158320,9167280," this is very interesting okay so and this is the code and we have to provide the program and mutable atoms"
9167280,9174960," right mutable atoms interestingly uh we're not going to be doing imports but we're going to be doing"
9174960,9181200," experts right so experts also will need program and the mutable atoms right because we're going to be"
9181200,9186560," looking at the atom ids and stuff like that we don't really need to do anything with a string chunk"
9186560,9192960," uh but the atom chunk must be accepting atoms right it must be accepting atoms"
9192960,9199520," uh okay so i'm going to just try to compile the thing as it is go through the compilation errors"
9199520,9209360," um right so extend chunk program program is actually not defined because i removed it so what else do we have"
9209360,9218000," in here atoms is not in the scope let's define them let's mute atoms atoms default so this is going to be"
9218000,9227760," something like this what else do we have in here label count uh so as u32 it's actually as i32"
9229280,9244240," and this one so all of them as i32 uh as i32 uh label count as i32 and this one also as i32"
9244240,9251040," okay so that that worked we can take a look at the uh"
9251040,9261280," uh pass of the beam right just to see what we got in here okay in terms of atoms we've got the atom"
9261280,9271440," butter but we yeah that makes sense actually uh that makes sense actually we we got uh-huh experts function"
9271440,9280400," uh name everything label that's a bizarre function honestly like why there's only one there oh because"
9280400,9287360," we didn't export okay we just generated some code but we never exported anything in there so that doesn't"
9287360,9291840," doesn't make any sense but i wonder if the disassembler is going to understand uh this entire file"
9291840,9299520," yeah it doesn't understand um cannot disassemble instruction function close function in 4.3 it"
9299520,9305440," didn't like the function info for some reason probably because we didn't put atoms anywhere"
9305440,9312880," correctly so that makes sense okay so can i just put mutable atoms in here all right so we're gonna go"
9312880,9323200," into the atom chunk uh and the atom atoms are gonna be to be fair atoms do not need to be mutable right"
9323200,9330000," we'll have to go internally i think all right so we're not going to be modifying them we're only going"
9330000,9339040," to be looking at them uh all right so the atoms is inner length and what we're iterating we're actually"
9339040,9343120," iterating the inner thing where we get the name"
9343120,9352560," yeah this one is interesting because what we'll have to do we'll have to turn it into a vector"
9352560,9358400," and sort them by their ids that is very interesting actually"
9358400,9363760," that is very interesting maybe instead of using"
9366320,9368640," maybe instead of using hash uh hash map"
9368640,9373520," we should use a vector at least for now"
9373520,9379040," all right we should probably use a vector"
9379040,9385360," uh so because it will make it easier to then sort"
9385360,9391280," like in order that is used by the indices and stuff like that and that way you don't even need a counter"
9392400,9395520," all right so essentially what you can do you can"
9395520,9405200," i just iterate then enumerate right enumerate and then find and what you're finding is then index"
9405200,9409680," right so index and the uh name right so"
9409680,9417840," so there is a little bit so there's a collision in here between that name and that name so i have to"
9418320,9425360," call it a slightly different so let's call it needle um so and essentially what we're looking for is uh"
9425360,9430800," this thing right maybe even without this kind of stuff but uh but yeah"
9430800,9440160," right so this is going to be iterator enumerate uh find that thing right find that thing"
9441040,9448720," and if you found it right if you found it we're gonna return it otherwise we're gonna um"
9448720,9454080," we're gonna do something else right so i'm just thinking how i'm gonna do it"
9454080,9462480," this is the result and then i need to match the result all right so match the result and in here"
9463360,9470480," what you have is an index and the name so we don't really care about that name but we can"
9470480,9478640," map the final thing which takes an index and name and just maps it into index plus one because we are"
9478640,9485200," indecent from one right so that way you can just say okay id result otherwise"
9487200,9495200," uh otherwise you can just do self inner push needle to string"
9495200,9500400," and simply return self inner length"
9500400,9506160," so that way i think it's going to be easier so let's go through the compilation errors"
9506720,9515680," um so atom yeah so inner len uh what else do we have in here so we're iterating inner"
9515680,9527280," and surprisingly that is literally it uh-huh so you have middle str so can we just do it like that"
9528640,9534320," no implementation for this string this is most bizarre"
9534320,9542000," thing i've ever seen in my entire life how can i compare this mother flippers cannot move out"
9542000,9552720," uh so i want to iterate index is not used in here boom look at that okay so we're using the vector"
9552720,9559360," instead of hash map uh so that should be fine and now we're also generating atoms and it just makes"
9559360,9569280," it a little bit easier right right right right right right right so that's pretty cool uh atoms"
9569280,9575920," and you don't even need the counter we can even call this thing names right so these are the names of"
9575920,9588480," the atoms and let's actually call them names names names uh names uh okay that's very cool"
9588480,9602320," all right so let me see if whatever we generated even disassemblable it is disassemblable so the reason"
9602320,9609760," was it's it's already freaking generated look at that what the so hello is 69 and the world is 420"
9609760,9617440," so we generated two functions so that means holy bro bro bro i can add more functions in here i can say"
9617440,9625360," foo which returns uh one hand is uh like something like this uh right i can do that and then in earling"
9625360,9630960," i can disassemble this entire thing and now we have three functions and foo returns exactly that"
9630960,9636400," so it's already a mini programming language this is already a mini programming language so"
9636400,9645040," right this is so freaking cool right so i just give it hash map of these functions uh of these names and"
9645040,9651600," corresponding uh numbers and it generates you an actual valid b module with functions with the same"
9651600,9658800," names that return these numbers it's a dumb language i understand that it's useless but it's legit so that"
9658800,9663280," means you can extend it you can make it more powerful and stuff like that that's what's important"
9663280,9669600," right you implement dumb but extendable and then you extend it and that's how you win right you go one"
9669600,9675760," step at a time you go one step at a time so but none of that is actually loadable right because we need"
9675760,9681040," to also export all of these things right we also need to export all of these things so i'm thinking is"
9681040,9688000," that we need to take the program and mutable atoms and export all of this stuff uh all right so this is"
9688000,9700880," going to be program right so it's a hash map str use size and then atoms uh atoms atoms atoms and they're"
9700880,9708400," going to be mutable because getting an id actually mutates this thing all right so export count is basically"
9708400,9716960," program len right it's a program len right it's a program len then we iterate through the program"
9716960,9723040," right so iter and you have a name and result right so it's a name and result"
9723040,9730560," and here is an interesting thing so you're supposed to prove the function name you're supposed to"
9730560,9741520," program function name so it's atoms get id um get id name like this then arity is zero and label"
9741520,9747520," okay go okay go"
9751920,9761920," label is two okay where can we get that though where can we get that though i don't really know"
9761920,9770080," so we need to um when we manage to compile each individual function we need to save its label uh"
9770080,9778400," all right so code chunk look look look so we have this label which starts at here uh and then we have the"
9778400,9785360," second label in here we need to somehow save that label we need to somehow save that label as we"
9785360,9796480," compiled all right so we may have something like labels uh hash map uh hash map dash map labels and it's"
9796480,9802160," going to be str and maybe it's going to be u32 or something and it's going to be"
9802160,9808560," something like this so it's a very dumb solution but i will think how to make it better"
9808560,9818240," uh labels insert and the name we're going to start maybe by string name uh maybe by string name huh"
9819440,9828000," so we already kind of yeah so let's actually use string name and uh label count right so these are the labels"
9828000,9831120," these are the labels"
9831120,9845520," okay so program uh expertise says as u32 uh atoms uh is not an iterator so what do you say"
9846720,9849760," um um as u32"
9849760,9862320," to be bytes so here is the name what else do we have code chunk you need labels okay let's define labels"
9862320,9866640," so labels is also that"
9869360,9876320," but we actually set it's going to be used for whatever reason sure um so as we compile this entire"
9876320,9886000," thing we collect all of the labels so that's fine uh huh oh and if you want to do labels you have to"
9886000,9892560," do lifetime so okay that's going to be a painful that's going to be painful so instead of doing that"
9892560,9900960," instead of doing that maybe we should collect the atom ids right so get id uh right so get id so the"
9900960,9907120," returns your size yeah so this is going to be your size let's not do that i don't want to go into uh"
9907120,9917280," into this kind of all right so name id uh and we can put it name id like so uh right so this is a name id"
9918720,9923840," and this we're going to have a name id all right so that makes will make it a little bit easier to"
9923840,9930000," do this entire um and label is uh your size"
9930000,9939040," alrighty so when we export and here's an interesting thing we don't need the program name we can just have"
9939040,9946080," labels yo that makes it okay so this is a name id and this is a label"
9946080,9952240," the fuck bruv bruv what the it's just naturally writing itself what the hell"
9952240,9961840," uh right so might as well even make name id u32 so i never have to convert it so the arity is zero we"
9961840,9967920," know that for a fact and then i just use the label what the hell that is such a cool idea i just like"
9967920,9977600," naturally discovered like yeah you compile code from list of names and numbers into a list of um"
9977600,9985600," list of name ids atom ids and the labels where it is located so yeah actually program and labels"
9985600,9997040," program and labels are the same entities this is a row program and this is compiled version holy"
9997040,10006080," shit and like what this is so freaking cool so this is the same thing this is uncompiled program and"
10006080,10008000," this is program after compilation"
10008000,10016560," this is mind block it's it's funny how i just discovered that by just writing the code and messing"
10016560,10022400," around oh my god this makes so much fucking sense right code chunk takes the program and compiles it into"
10022400,10023200," a list of labels"
10023200,10034080," what is going on like what it's like it's like an enlightenment for like like wait wait a second it's"
10034080,10043600," the same thing wow holy shit anyway i'm sorry i'm just like it's kind of difficult to convey what is going"
10043600,10049200," on in my head right now but i mean uh i'm trying so and expert count is going to be just the labels then"
10049200,10055360," right so that that makes sense and just like this is the labels right so the name id um"
10055360,10063520," yeah so here is that but when i do code chunk uh right this has to you can't see choice in this"
10063520,10071200," miss but yeah that's what they're doing here um so mismatched so this is a name id and name id is"
10071200,10078000," defined in here uh as well i mean when we are signing that stuff in here i hope i'm not making"
10078000,10085920," any mistakes so actually so export chunk uh aha and this is the labels right so look compiling the code"
10085920,10094320," program into labels right so the output is sort of the result is the labels and then to export those"
10094320,10099840," chunks i'm providing the labels but i don't provide the original program i just i don't provide the original"
10099840,10106160," program to export it i'm exporting the compiled result of the program and the compiler result is just the"
10106160,10113120," atom of the name and the label where the the function starts uh and we go so surprisingly because"
10113120,10121440," of that you don't even need to provide the atoms what the oh my god holy"
10123760,10131840," okay okay okay okay okay input is the program the output is all of the atoms and all of the labels of"
10131840,10142480," the functions and those outputs labels go into the experts experts and atoms goes into the atom chunk"
10142480,10150560," and you can even see that through the mutability the compound program is immutable the two outputs out of"
10150560,10156880," that program are mutable because this is the outputs and the same outputs from the code compilation are"
10156880,10158320," inputs for the exporting and"
10158320,10171760," so let me see hopefully this entire will work hopefully this entire will work so um let me try to"
10172320,10178560," maybe uh just disassemble that okay so everything seems to be working here are all of the atoms"
10178560,10185840," um i'm quite surprised okay so this is not the atoms this is the exported function so i'm"
10185840,10192640," being a little bit silly right now so if i read this entire thing um here are all of the functions we"
10192640,10202240," we exported here are all of them mm-hmm so and this is a little bit bizarre because the module"
10202240,10211920," like i don't remember i think we had coded um the module name to be zero in some places i have a feeling"
10211920,10219280," that we did i have a feeling that we did and that may bite us in the ass in the future uh but anyway yolo"
10219280,10225120," so let's just try to purge the code and just load it okay so module name object is full yeah that's"
10225120,10232560," that's exactly what i expected uh so where did we use that stuff i forgot to"
10232560,10241520," update so i need to go through all the chunks then right so chunk name function count"
10242240,10251920," uh did we right so here when i do function in four we just do that we just do that so that seems to be"
10251920,10259120," fine i don't think code is an offender anywhere in here import chunks they're empty they don't refer"
10259120,10268080," to the modules that's fine export chunks maybe by the way export chunks may be referring to some modules"
10269440,10278640," so you have a function name you have that you have a label um so and atom chunks i don't think they"
10278640,10287280," okay i have a feeling i have a strange feeling that the module name is the first atom"
10289760,10300640," i have this kind of feeling so and we refer to this kind of stuff so atoms aha yeah"
10300640,10309760," so since we refer to the atoms uh like name first and only then to bada but it doesn't end up to be the"
10309760,10316720," first name in the atom list unfortunately okay so let's just try to do it like that uh let's try to"
10316720,10323200," disassemble uh maybe look at like that there we go so now bada is the first right and i feel like i"
10323200,10328480," don't have any information to confirm that but i feel like the first atom has to be the name of the module"
10328480,10334560," as well right so we have the module and then the the rest of the functions in here uh okay so then we"
10334560,10340640," try to take a look at the disassemble right and then let's purge and reload um okay so"
10342320,10350080," uh-huh the amount of labels is incorrect so i feel like the label count has to be sort of like plus one"
10350080,10352480," uh let's"
10352480,10360320," let's do after we finished all of that let's just do label count"
10360320,10366160," plus one just in case i still can't not understand how the label count works"
10367040,10375040," and all of that jizz but that works now so erlang get module info by the way isn't erlang"
10375040,10381520," automatically imported so i should probably be able to do something like this um yeah it's not"
10381520,10389200," there we go so we have experts we have foo hello and world so that means i should be able to do bada foo"
10390320,10403040," it's that hello world so if i want to add a new function in here if i want to add a new function"
10403040,10411040," in here so what i have to do i have to just do bar and uh just put some stuff in here right i'm going to"
10411040,10418320," recompile this entire thing right and then i'm going to reload the module all right i'm going to reload the"
10418320,10425040," module and now that module just a second i'm going to take a look at that the module info contains"
10425040,10436880," bar like a legit bim module contains bar and i can do in erlang bada bar and it contains that number that i put in there"
10439360,10450480," so i have the compiler from the hash map from the hash map from the hash map to bim module this bada bim module"
10450480,10462560," so the next step the next step is to actually do something like this compile this kind of file"
10464240,10467920," this is going to be the next step should we do that should we do that should we do that"
10467920,10477840," so what we need to do so as far as i know in the fast uh there is read to string"
10479520,10487840," so test butta right uh expect so let's actually do something like input path"
10487840,10492960," right input path so this is going to be that"
10492960,10505680," content so we get content and we can maybe do something like content length is equal to content then"
10506960,10513360," so boom what do we have in here content length 22"
10513360,10520240," content length 22 okay so we can maybe even print that content"
10520240,10526080," yeah so that's the cont uh well i mean it would be nice to get rid of this entire thing but"
10527040,10533920," so yeah i get that can we split content into lines is that something we can do"
10533920,10538880," uh so essentially i can say line"
10538880,10549520," we can so we just split this file into lines so we're also going to have like empty lines"
10550240,10555520," which is not particularly pleasant so this is something that i want to do like that line um"
10555520,10562800," len greater than zero only then we're going to consider those lines so we filter out uh those"
10562800,10569440," things right we filter out those things so within that line we probably want to split this entire thing"
10569440,10575920," by uh sort of equals right so and we're going to have some sort of chunks right and the question"
10575920,10581600," is what are those chunks how do they look like how do we process them even further how do we process"
10581600,10587440," these chunks even further what the is this can i just collect that into a vector"
10587440,10593680," uh all right so is that something i can do uh okay so we'll get those things so and essentially"
10593680,10597360," what if i have like something like this"
10598480,10605280," uh right so we have really wacky format really wacky format so how does it look like okay so we've got"
10605280,10614160," these kind of things we've got these kind of things um so we can essentially take uh chunks"
10614160,10627120," we can even maybe match this stuff if let uh key value uh chunks only then we're gonna care about them"
10627120,10636240," right only then we're gonna care about them uh right so uh then in here i can do key uh do we have"
10636240,10645680," something like trim uh and value value tree is that something that we have uh so then later i can do key"
10647600,10658960," key equal key and then value value value equal to that can we do this kind of stuff"
10658960,10666800," uh okay so what you don't consider slicing here pattern matching uh"
10669840,10671280," mm-hmm i see i see i see"
10671280,10680160," all righty all righty all righty all righty all righty so we can also do so what do we use we use"
10680160,10690080," parse parse parse parse um use size something like this and i'm gonna simply unwrap for now right so"
10690080,10695040," unwrap for now and what do we have in here we have this kind of stuff so the only thing that is left in"
10695040,10703840," here is basically uh program insert key value but we have to be a bit careful in here because um"
10703840,10711600," maybe not so we are referring to string and it refers to the content and contents leaves as long"
10711600,10718320," as the program so i think lifetimes are going to be fine lifetimes are going to be fine so uh that should"
10718320,10728480," just compile now let it go so uh now here's an interesting part i'm going to do the following thing"
10728480,10741920," one two three four here is the file i can even align this file i can even align this file i run bada"
10743120,10751680," that bada takes this file and transforms it into uh into the module bada beam right so we take that module"
10751680,10760240," and we load up that module in erling uh right and let's take a look at the module in four"
10762000,10773440," one two three four bada one two three four"
10773440,10782880," we wrote a legit programming language oh well i mean it's it's not turing complete or anything right"
10782880,10789440," so we can even test something like like your mom right doesn't exist go back to test bada"
10790000,10798080," your mom 69 uh recompiling the whole thing uh recompiling the whole thing reloading the whole code"
10798080,10803040," uh reloading the whole code uh reloading the whole code bada your mom it's there"
10812480,10814720," easy easy peasy it's crazy"
10814720,10825680," so there's a last thing that is left right it's kind of funny how you just like build on top of like"
10825680,10833200," i'm actually started inside out i started with the code generation right i started with the code generation"
10833200,10842080," then with the compilation and then with parsing people usually how people usually develop compilers"
10842080,10851200," they develop lexa parser uh compiler code generation they they usually go from the front end to the back"
10851200,10859040," end uh has anyone you tried to develop compile study from the back end to the front end i think it's it's kind"
10859040,10865520," of more fun to be fair right so right because since you're starting from the back end you get a final"
10865520,10872880," working result faster right so you study from the back end right so you start with assembly you already"
10872880,10878960," have a thing that is running you already have thing that is working and then you build up on top of that"
10878960,10884000," going back to the front that's a very interesting technique of developing compilers honestly and interpreters"
10884000,10888800," and stuff like that start from the back end from something that is already runnable from something"
10888800,10897120," that is already working and work yourself your way to towards the front end um start from the both"
10897120,10905360," sides and meet in the in the middle and i don't know maybe um so the only thing we don't really do in"
10905360,10912320," here is that we have hard coded input path and output path right so that's kind that kind of sucks in my"
10912320,10918800," uh to be fair so that that doesn't feel like a legit compiler if you know what i mean"
10918800,10928720," uh right doesn't feel like a legit compiler so what would feel like a legit compiler is to actually"
10928720,10936000," accepting the input path and generating output path based on that that would have been actually kind"
10936000,10942160," of cool i think so let's actually try to do that so this is going to be the environment and uh right so"
10942160,10952000," args we take the args so meetable args so the first thing is probably in the program so we can do expect"
10953120,10966880," a program uh and uh we can do the following thing some input path uh args next and we can just return this"
10966880,10979920," thing otherwise we can generate an error eprintln error no input is provided and there we go we've got an input path"
10981440,10989440," another go we don't need this anymore the output path the output path how do we even like do that"
10989440,10996960," so i do quite remember so there was a path thingy if i construct the path out of that uh canonize"
10996960,11006240," extension so we can extract the extension out of this thing but can you do that with extension with file name"
11010160,11019280," so what i want to do i want to strip of the file extension uh and then uh append like a different one"
11019280,11024320," so you have a path with extend oh okay"
11024320,11037920," so path with extension txt okay so let's give it a try uh path new input path"
11039120,11041760," uh with extend extension"
11041760,11049120," beam do i have to put dot in here i don't have to put down here i think that's fine okay let's go"
11049120,11056240," to the compilation errors and see how it's gonna go okay so path is a part of the std path"
11056240,11059440," std path"
11063920,11068160," what else uh what else uh expect no method this one has to be next"
11068160,11078720," else yeah so here what we have to do we have to kind of return let's do exit one um"
11078720,11083760," std process exit so this is basically crash"
11084880,11092720," uh uh okay uh expected but this is a string"
11092720,11101200," uh expected str well i mean yeah that's fine um"
11101200,11109840," i mean we can always do some some stupid shit like uh match it's not pretty that important honestly"
11110800,11112320," uh if ever"
11112320,11121840," eprintlm could not write"
11121840,11130160," file an output path remember that you can't really easily display"
11131120,11135280," the path buffer so there is a special sort of like a display"
11135280,11141280," thing right yeah so there is a special method to display this kind of stuff and"
11141280,11147680," uh everything right because they may contain something that is not utf-8 or whatnot on some"
11147680,11154240," operating systems so you have to be kind of kind of careful with this kind of stuff so output path is"
11154240,11164080," gonna be this and then we're gonna basically do std process process i said exits uh one"
11164080,11173200," uh so this one is unused that's fine error is unused it should be used"
11175200,11182800," uh okay so borrow out of move the uh-huh"
11182800,11189360," get them rust i swear to god"
11189360,11199360," get them rust uh all right so so let me let me actually do something like this it's just like"
11199360,11206400," sometimes it just forces you to spend uh some uh like time on an important ship and just"
11206400,11212960," compile my program already just compile my program already please"
11212960,11220560," rust do be like that not sometimes but every single freaking time okay"
11221280,11226400," what we need to do chat what we need to do we need to test this kind of stuff properly maybe in a"
11226400,11231840," separate folder all right so i actually want to open up uh a separate terminal"
11231840,11236720," so it's going to uh certain bada right so let's do test"
11236720,11244720," and i'm going to go into the test and i'm going to copy the binary in here the binary in here so we have"
11244720,11249680," bada can you see by the way i think you can't see what if i do something like expert ps1"
11250480,11257760," uh right it's ps1 and just that so look at that i think i think that's better for"
11257760,11265920," you know for for the demo and stuff like that right so let's go and open uh bada dot bada"
11265920,11275440," right bada dot bada and we're going to say one is one uh nice is 69 right we have two things in here"
11275440,11284880," and i do bada bada bada bada generated bada bada bada bada bada boom right so you can clearly see that"
11284880,11292320," here is a bada bada and here's the bada bim here's bada bim the next thing i do i do url"
11292880,11298480," and then i do code uh load uh load file bada"
11298480,11316080," that's the result of today's stream so what you can do now with bada you can uh take the file all"
11316080,11323840," right so bada bada with sort of like this list name one name name number name number and you can"
11323840,11331120," compile it into the bim file an actual bytecode of erling where each name is an erling function that"
11331120,11339360," returns this number this is a thing that is extendable so now instead of number you can accept a sequence of"
11339360,11344800," actions and you compile this sequence of actions to some instructions in erlink and you get a"
11344800,11351520," programming language that compiles to uh to erlang bytecode i think i now know why things like elixir"
11351520,11356880," and gleam are a thing because erling vm is a very easy compilation target"
11356880,11364560," it's a very easy compilation target like you can just compile to it it's a relatively straightforward"
11364560,11370080," virtual machine even being half as documented you can still figure it out"
11370080,11381600," gleam compiles to erlang code and not to the bim code"
11381600,11392800," pathetic pathetic oh my god how am i supposed to even take it seriously now"
11394560,11405920," i'm disappointed i'm disappointed i'm disappointed anyways uh so we have like five minutes so i should"
11405920,11412240," probably uh create the repo for all of that i should probably create a rip for all of that"
11412240,11418720," i already have a repo uh i mean yeah so i can compile it to the same repo essentially so i can remove that"
11419440,11423120," bim i can compile this stuff right so"
11423120,11438800," uh print info print info um for the code chunk right for the code chunk uh all right and we're gonna go ahead"
11438800,11444000," and just implement and just implement bada compiler in rust"
11444000,11452800," boom and i'm gonna push that right into the repo so uh and i have bada right i have bada"
11452800,11461440," and uh it's it's private repo so now i need to make it public uh so let me let me see"
11462640,11465440," oh yeah like making it public is such a pain in the ass"
11465440,11477440," so this is a danger zone this is a danger zone look how many clicks they add so you can make it public"
11485200,11492400," and now you have to and now you have to this is genius like this is in case some dumb ass intern"
11492400,11498800," doesn't accidentally publish like business important code like so many clicks and stuff"
11498800,11504960," like that it's fucking insane i i really love it you can feel the intent you can feel the ux and just"
11504960,11507920," like are you fucking sure are you fucking sure"
11515200,11538400," it's so you can find this thing in here and for people who's watching on on youtube of course it is"
11538400,11545040," going to be in in here uh so this is already a different day right i forgot to create a section for"
11546080,11556080," for the next stream um all right so uh i guess that's it for today thanks everyone who's watching"
11556080,11560720," me right now i really appreciate that have a good one and i'll see you all on the next recreation"
11560720,11570800," programming session with a mr zozin as usual so yeah thank you thank you for watching love you"
