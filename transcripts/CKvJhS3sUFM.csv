start,end,text
640,5760," All right, this is the next day, and I just wanted to finish whatever I started yesterday."
5760,12320," Specifically, I want to introduce the second intrinsic, which is store intrinsic,"
12320,15820," which is an opposite to load intrinsic, right?"
15820,18800," And also introduce the variables, right?"
18800,22900," So basically a construction that is kind of similar to memories,"
22900,29980," but it allows you to define the name and also associate the type with that specific name, right?"
30000,35280," It's like a memory where you define the size of the memory not by a specific number in bytes,"
35280,40640," but by the type, and type usually has an associated size with it, right?"
40640,47420," So, and basically this is the only two things that we need to implement to sort of like complete this feature set,"
47420,51860," and then we can continue expanding it, making more different types,"
51860,56300," and, you know, making the type system more and more complex."
56300,59640," So let's go ahead and introduce the store intrinsic."
60000,68820," So let me see, I think it's somewhere in the compiler, intrinsic, load, pointer 2,"
68820,72220," and I'm going to just introduce store, pointer 2."
72220,77000," It's going to be similar to store 64, because for now we only have 64-bit types."
77000,83100," So let's go ahead and just like start the compilation process."
84100,92720," All right, so 47 becomes 48, pointer 2, and this is store pointer 2."
92720,96440," The next compilation error."
96440,98520," This is not the compilation buffer."
98520,101140," Give me the compilation buffer, please."
101140,106640," Okay, 47, 48, load pointer 2."
107180,112060," All right, so this becomes store pointer 2."
112060,113420," There we go."
113420,116560," And the next one is what?"
116560,120240," So I suppose this is the type checking."
120240,122900," Okay, so load pointer 2."
122900,126280," We have a special function for type checking load pointer 2."
126280,128040," So I think we're going to do a similar thing."
128140,134840," We're going to have store pointer 2, and we're going to have a special function that type checks that."
134840,138180," So type check store pointer 2."
138180,142060," All right, let me go ahead and just like go in here."
142060,149600," All right, and I'm going to create proc type check store pointer 2."
149600,154360," It's going to accept the token and the stack, the type stack that we're type checking."
154980,159000," And I'm going to just like drop both of these things and say that this thing is not implemented yet."
159000,164680," Tap check store PTR 2 is not implemented yet."
164680,168060," Okay, so what's the next?"
168060,170820," And the next one is basically code generation."
170820,177200," So, and I suppose it's super easy to just take something like this."
177200,182360," Store 64, right, and just say that it's the same as store pointer 2."
183000,187720," Right, it should generate pretty much the same sequence of instructions."
187720,190720," And I forgot to increment the count in here."
190720,192360," Almost 15 intrinsics, by the way."
192360,194900," Okay, so we managed to compile this thing."
194900,196060," Can we recompile it again?"
196060,198040," Okay, everything seems to be fine."
198040,203240," So let's see if this entire intrinsics is going to work, right."
204360,208680," So let me include the std port, right."
208680,212220," And so let's introduce the entry point."
212220,219440," And let's introduce a function that accepts pointer to an integer, right."
219440,220900," So it accepts pointer to an integer."
221320,230960," And we can just bind that pointer to a specific name and just say, okay, take 69 and store it in that specific pointer."
230960,231720," Right."
231720,238740," So we don't have to specify the size or anything because all of that information is stored within the type of the pointer, right."
238820,239660," So it's a type pointer."
239660,242340," So that's kind of the point of this entire step."
242340,244660," So let's go to the compilation."
244660,248520," And so I should probably do something like this."
248520,256280," I'm going to take my bootstrap compiler, compile the compiler, and then run it and try to compile the example that I'm currently running."
256280,259340," And it should say that the type checking of this thing is not implemented."
259340,260600," This is precisely what I expected."
261760,264540," Okay, so now we just need to implement that."
264540,282920," The signature of store, right, of store pointer 2 should be something like it accepts any type, though we don't have the type for any, and pointer to any type, and just stores that value into that specific pointer."
282920,285760," So that's basically the signature, right."
285800,292860," And we need to describe that signature somehow with, like, you know, with the code, with the internal code of the compiler."
292860,293880," Right."
293880,307920," We have a special function called type check stack that accepts the current state of the stack, and then it accepts what's expected on top of the stack, and then what it's supposed to be on top of the stack after we perform that operation."
307920,324700," So essentially, we just need to prepare the ins and outs, right, so an ins are going to be just this, and the outs are going to be nothing, I suppose, because both of the things are consumed, and it's just like a statement, it doesn't really produce any output, it only performs a side effect."
327380,334940," on the memory. So let me maybe split my screen because I'm going to steal some code from the"
334940,343080," type check load pointer too. All right, so I'm going to do over, over, over, and that basically"
343080,351880," will copy these two elements. This one is a token and this one is a stack. All right, and I expect"
351880,358760," two elements on top of the stack. So I'm going to say expectarity, right, and whatever we expect here"
358760,366180," is going to be the input, right. So then I'm going to allocate the output stack in the temporary memory"
366180,371780," and we're going to fill it up a little bit later. So on the stack now, right now, we have token stack"
371780,379460," ins and outs, right, and we need to type check the ins stack, right. So on top of the stack, as already"
379460,384840," mentioned, so let me bring back the signature of the, of the store instruction, we're going to have"
384840,391360," some sort of a type and the pointer to the same type, right. So this is what we expect in here,"
391360,399200," right, this is what we expect in here. So I just need to take a look at the top of the stack of ins,"
399200,406800," right, so type stack top pointer plus, then I'm going to read this entire thing and here is the frame,"
407040,416420," right, here is the frame. So I'm going to take the type of the type frame, right. What the hell is"
416420,422700," going on Emacs? Why are you jumping around? Company mode actually causes more destruction than it"
422700,430140," actually helps in my opinion. All right, so we have something like this. So this is the type."
431420,438800," Do I need any, any location, because here I take the location. And the only reason I have a location"
438800,442800," in here is because I need to push that to the output stack, but the output stack is not supposed to have"
442800,452800," anything. So that should be fine. All right, so this is sort of like the first frame. And now I need to go to the"
452800,462180," the next frame, essentially. So how I'm going to be doing all of that might as well just do frame type frame,"
462180,467920," previous pointer plus, and I'm going to read it as a pointer. And that sort of returns the next frame,"
467920,476300," which I can try to bind yet again, right. That's very interesting, actually. So in here, we can actually"
476300,485680," check the types right away, right. Can we check them? Is that a good idea? I'm not sure how good of an idea"
485680,494140," that is. But maybe that's fine. All right, so this is the next frame, right. And in here, I unpack types"
494140,501520," yet again, but I don't push anything. Right. So and in here, I suppose to have four elements, if I take a"
501520,507520," look at the, you know, elements on top of the stack, I should have four of them. And I do in fact have four"
507520,513120," of them and all of them are integers. And they are unpacked types, right. So type consists of two"
513120,519440," things, the pointer counter and the primitive type. Right. So here we have the top and here we have"
519440,526480," what's behind it. So essentially, here we have the type for this for this thing for the pointer. And then"
526480,532320," the second one is going to be this. All right, so and then we can just go ahead and bind all of that stuff"
532320,541680," in here. So I suppose, how should I call them? I don't know, I need some sort of a name for these"
541680,549200," things. Usually these components are called pointer count and a primitive, but they have two of them,"
549200,559200," right. So I have two of those things. The first pair belongs to the actual pointer, right, the actual"
559200,564560," pointer. So I suppose it's some sort of like a destination, right. So it's a destination pointer"
564560,572480," counter and destination primitive type. So and then the second thing is the value that we're trying to"
572480,579680," store in the destination. So it's sort of like a value point account and value primitive, right."
579680,588720," Value point account, a value primitive. Interestingly enough, I think specific point account"
589360,596320," specific point account and specific primitive of a value does not really matter. Because essentially,"
596320,605280," the value type should be equal to the destination type with a point account or minus one,"
605280,614800," which means that I don't really need to unpack this thing. And I can just keep this as a packed value type."
615760,623280," Then I can just take my destination point account, subtract one and destination primitive and pack"
623280,632240," this thing again. And that result has to be equal to the value type. And if it is not, we didn't type"
632240,638400," check properly, right. So that's basically what it is. That's basically what it is."
638400,648480," Interestingly enough, we can do this operation somewhere here, right. So here we unpack this stuff,"
648480,657680," then I can say point account, and then a primitive, right, and then point account minus one primitive,"
657680,663120," and pack this entire thing back. So pack the type. So here we unpacked it and then packed it again."
663120,669440," Might as well just do it like that. So it looks a little bit more symmetrical. So here is the type,"
669440,677040," right. Then I unpack it, then I transform it, then I pack it back. I leave it on the in here,"
677040,683280," then I take this entire thing. And this becomes destination type, right. And that way, I can just say"
684560,690560," whether destination type is equal to the value type, right, something like that. Not sure how useful that"
690560,701360," approach is, right. But it is what it is, and it isn't what it isn't. So but that's not enough, actually."
701360,704960," So it's just like, you know, random thoughts about how to approach this and that stuff."
707600,715040," So in here, we should check. And it's quite important, by the way, that the point account"
715040,723600," is at least equal to one, right, at least equal to one, if it's less than one, right, so that means"
723600,733200," something went wrong, right. That means something went wrong. And we need to report that somehow. So I need to"
733200,740560," take the frame type frame location, and I need to print that location in here, then I'm going to say error."
740560,753040," And so the destination of the store operation must be a point, right, it must be a pointer."
753600,762240," It puts and then I'm gonna exit with not zero exit code. So that's basically the idea in here. And"
768480,776080," all right, that's very cool. Then we pack everything back. Then we take the next, the next frame. And in"
776080,789440," the next frame. So maybe I don't even need to do this thing. Because I can always just do something"
789440,796800," like this. Right. So I can just compress it like that. And then we just end up with expected type and actual"
796800,808000," type. Right. Destination type and value type. And if they are not equal, right, if they are not equal,"
808000,816960," though in here, we can actually literally call it expected type expected type. And this one is actual"
816960,824960," type. Right. This one is actual type. And if they are not equal, we can now report something about that."
824960,836880," Right. Or do we? I'm not quite sure. I'm not quite sure if we need to report anything in here."
836880,844480," Because we just need to put that into the output. No, no, no. We don't have to put that into the outputs."
847760,856400," I don't have to put that into the outputs. It's kind of interesting. Like, by the time we constructed"
856400,863920," the outputs of this operation, we already basically type check everything. So yeah, the current type"
863920,870880," checking mechanism actually doesn't really work well with the new paradigm of these things. But it can be"
870880,876080," fixed in the future. So that's totally fine. Right. It's just kind of interesting that I have to like"
876080,882400," write extra code because, you know, the type checking paradigm is not really developed well within the code."
883120,891920," So, all right. So if it is not equal, what do I do?"
895040,906720," I just say that I need this frame actually. I need the second frame. I need the location of the second"
906720,917520," frame. Otherwise, I won't be able to properly report that, I think. Let me make a small break. And after the"
917520,924720," small break, I'm going to continue because I need to refill my cup of tea. All right. So I've got an idea."
924720,935040," So here we take the point to the destination, right? Then we check that it is in fact a pointer,"
935040,942320," and then we decrement the point account, and we pack everything back. So what I'm thinking is that we can"
942320,947360," just take the previous frame, right? And within the previous frame, we can take a pointer to the type"
947360,955920," of the previous frame. And we can just save the new expected type right there. So and we have a proper"
955920,962560," expected inputs, which we can feed into type check stack. And that will work. We don't have to like check"
962560,971280," everything ourselves. So that's basically it, right? And outputs, outputs are expected to have nothing."
971280,977280," After that, we can just do type check stack, right? So we just type checking the stack."
977280,985600," And that should be it. So that's that's essentially actually very, very simple. So let me try to"
985600,990320," recompile everything. And as you can see, everything is properly tab checked. Let's actually see that it is"
990320,997040," in fact properly type checked. So we're trying to save integer into the pointer of two integers. So what"
997040,1002320," if that thing is going to be a boolean? Can you save a boolean into the pointer to integer? It should not"
1002320,1008800," work. Yeah, there we go. So the argument one of int is expected to be int but got boolean, right? And they"
1008800,1016160," counted from zero. So one is like the second one. Right? So there we go. So it's expected to be integer but"
1016160,1021680," got boolean. So we can try to even get rid of this thing. And it will say that the destination of the"
1021680,1028640," store operation must be a pointer, right? But it's not a pointer. So we can do pointer too. And here we"
1028640,1036880," can just try other things like, you know, untyped pointer, right? So untyped pointer cannot be assigned"
1036880,1045120," only an actual integer can be can be assigned in here. So we have a proper store intrinsic for typed"
1045120,1051360," pointers. And it's even type checked more or less properly. Okay, so let's just go ahead and commit"
1051360,1056560," everything we have. Before we commit, I might as well just like run the tests to ensure that I didn't break"
1056560,1060880," anything. We're also going to have some tests for the new features as well. I'm going to write them off screen."
1060880,1078400," Okay, go. Seems good. Seems good. Now introduce exclamation mark intrinsic intrinsic. There we go."
1078400,1083520," And I'm going to push that right into the repo. All right. So the last feature that we need to implement"
1083520,1090480," is variables, right? So we can load the information from the typed pointers and we can store information"
1090480,1098160," into the type pointers. But we can't construct such pointers yet. There is no mechanism to construct them."
1098160,1102960," Right. And one of such mechanisms is going to be variables, right? So variables are just like memories,"
1102960,1107840," but memories produce untyped pointers, but variables can be produced are going to be producing the typed"
1107840,1113280," pointers. So yeah, let's just go ahead and implement them. So I think"
1113280,1118640," I'm going to first start by defining a structure for the variables, which is going to be kind of similar"
1118640,1126320," to memory structure. Let's actually find the memory structure. Size of memory. Here it is. So yeah,"
1126320,1131760," maybe I'm going to actually keep all of that within the same section in here, but I'm not kind of essential."
1131760,1138560," All right. So we're going to have var name, and the name is going to be just a string, right? So offset,"
1139760,1147840," then we're going to have var offset, which I presume going to be offset from the global memory. So we're"
1147840,1152160," going to be storing variables in a global memory, maybe we're also going to have local variables,"
1152160,1158960," which are similar to like, local memories, right? So yeah, variables are basically typed version of"
1158960,1168240," memories. That's basically what they are. They're not that different. Really. Okay, so and this is going to be the"
1168240,1174560," offset and also we're going to keep track of the location where variable was defined, right? And it's"
1174560,1183120," going to be size of location, offset end. And then we're going to define size of var, which is just reset."
1183840,1197920," Okay, so we need to allocate the global array similar to this one, right? So let's quickly do that."
1197920,1206320," Const global var's capacity, we're going to have 1000 of them for now, of course, in the future, it's going"
1206320,1217200," to be like dynamically growing, but for now it is fine. So let's allocate memory global vars count,"
1217200,1228640," which is size of u64. And in the future, once we have variables, this entire thing could be defined as"
1228640,1236720," var global vars count integer, right? So but we don't have variables yet. So because of that, we have to"
1236720,1243600," use the memories. But once we have them, we can go back to this place and rewrite them with a new feature."
1243600,1248240," So it's going to be yet another case of feature implementing itself. But since we don't have"
1248240,1253680," that feature yet, we have to implement it without it. So yeah, the same situation."
1253680,1269680," Okay, so I'm going to have memory global vars, size of var, global vars capacity, multiply it."
1269680,1275040," And there we go. So global memory capacity, this one is rather interesting."
1276640,1286800," So I think I want to store global variables with the same section as global memories, right? So because"
1286800,1292000," of that, we're going to be using global memory capacity to calculate the offset for the variable"
1292000,1297440," because they're going to be stored within the same place. All right, but all of that doesn't really"
1297440,1305760," matter right now. So we have global memories lookup, global memories lookup, we also need to define"
1306640,1314480," global variable variable define, and so on and so forth."
1314480,1320080," All right, so let's go ahead and just do that. Let's go ahead and just do that."
1320080,1333680," So in proc, global var define, global memory define is going to be just a pointer, I suppose it's a pointer to the"
1334400,1337680," variable variable data structure, variable data structure, ptr to var struct."
1337680,1344240," And in here, I'm going to just drop this entire thing and say that this thing is not implemented"
1344240,1352160," yet. Global var define is not implemented yet. Right? It is not implemented yet."
1352160,1363040," Then global memory lookup, memories lookup. Yeah. So we take the name and it returns the pointer to that"
1363040,1377840," specific thing, global vars var. So global vars lookup and it should return the pointer to the variable structure."
1377840,1385280," So I'm going to just drop both of these things and return null, and then say that this thing is not"
1385280,1390720," implemented yet. Global vars lookup is not implemented yet."
1390720,1399040," Okay. Do we need anything else? That's a very good question. I didn't think so. Let me try to compile"
1399040,1404720," everything. This is not how you compile that. There we go. Everything seems to be compiling."
1404720,1411920," Okay. So I think I need to introduce the new keyword and go from there. So we're going to start with adding"
1411920,1420080," support for that keyword in the editors. All right. So first comes Emacs. So we have return. Here I'm"
1420080,1429680," going to introduce var. Then in Vim, I'm also going to introduce var and sublime. Where is return?"
1429680,1438640," It's going to be var. So let me go to my Emacs configuration and update the port mode, like so."
1439440,1446720," All right. And I'm going to exit Emacs and restart it once again. So now I should have the support for the"
1446720,1453760," var keyword, right? So this is going to be something like var. So let's code X and it's going to be an"
1453760,1461840," integer. Right. And then here it should be possible to use X like so. There we go. Right. So X will produce"
1461840,1467680," the pointer to an integer and then it will be passed to foo. And then within the foo, it's going to just like"
1467680,1476400," do this kind of thing. Um, right. So that's basically the idea. Um, okay. So obviously this entire thing is"
1476400,1484480," not going to compile yet. So let's start with bootstrap forth forth forth forth and compile the"
1484480,1489440," example that we just wrote. And as you can see, words are not allowed at the top level. So it thinks that"
1489440,1497520," var is a word, but it's a keyword. It must be keyword. So let's go to the Alexa and let's find the keywords."
1497520,1502880," So here are the keywords. Let's introduce another one. It's going to be var. Right. And we're going to start"
1502880,1511840," from there. Okay. So we now have 23 keywords, which is a lot of keywords, but we're going to fix that"
1511840,1523200," later. It doesn't really matter right now. So 22, 23, return. It's going to be var. And then it's var."
1524800,1532640," Okay. Anything else? What do we have in here? Uh, okay. So here, this is"
1532640,1540400," compile time evaluation. So I didn't think we were going to support these keywords in compile time"
1540400,1549680," evaluation. So we can just increment it by one. Uh, okay. So now the compilation. I think this has something to do with"
1549680,1564800," probably not. Yeah. Okay. That's fine. So let's actually find keyword, uh, memory, right? And this"
1564800,1568720," is where we're going to start supporting all of that. So basically we're going to, we need to kind of"
1568720,1581520," copy paste a lot of code related to, um, related to the memories, right? So keyword, uh, keyword, um, var,"
1581520,1587920," right? And if we get the keyword war, we're going to say that, uh, compiling keyword"
1589360,1599840," var is not implemented yet. So let's see what's going to happen. Um, okay. So I've, I think I forgot to"
1599840,1610080," increment 22 in here. Uh, all right. So what else do I have? Var. Okay. So compiling keyword, uh, keyword"
1610080,1615920," var is not implemented yet. So I can take a location and say that it's located here. Uh, right. And as you can"
1615920,1623440," see, it says it is located here. So this is where we fail to compile because this part is not implemented"
1623440,1631920," yet. Hmm. So let's start implementing it. Okay. That's cool. So the first thing we want to do expected"
1631920,1639520," memory name, uh, but found nothing. So we have to ensure that the name of the variable is a word, right? So"
1639520,1646960," exist at least, at least exist, uh, expected, um, variable name, but found nothing, right? So this"
1646960,1653920," is the situation that we may have, uh, and that situation may occur, uh, when we do something like"
1653920,1660080," this, right? So let's actually see, um, okay. Compiling var is not implemented yet, but this situation"
1660080,1667120," didn't occur, which is rather strange. So it tells us, oh, okay. So it may occur when something like this"
1667120,1673200," happens. Yeah. Expected variable name, but found nothing. Okay. And once you have this kind of thing,"
1673200,1682720," uh, it should be, it should be fine. Cool. So now what we need to do, we need to parse the type, right?"
1682720,1687520," I lost the place where I was actually working with all of that."
1689120,1696400," Okay. So here is the place and, and down there, right? Uh, we also need to check that the, uh,"
1696400,1704000," variable name is specifically a word. For instance, if you do something like this, um, this is kind of"
1704000,1710720," weird, right? It, it actually passes. So we need to specifically check for this thing, not being anything"
1710720,1720720," else, but a word, uh, right? So something like this expected, uh, variable name to be a word, but found"
1720720,1726720," something else. So I'm going to align a put like that. So if I try to compile this thing, it will say,"
1726720,1732640," expect the variable name to be a word, but found an integer instead, which is obviously not correct."
1732640,1740640," Okay. So, and to fix that, we'll have to use, uh, an actual word. Okay. So that works."
1740640,1746640," The next thing we need to do, we probably want to check for the name redefinition,"
1746640,1752640," right? So this is one of the things we want to do. Uh, so the value, uh, let's put it in here."
1752640,1760320," And I, as far as I know, we don't have, um, you know, where is that function?"
1761680,1766320," Uh, excuse me. What is going on? Why can't I find this function?"
1766320,1775680," Why it doesn't exist anywhere? And, uh, okay. I see. That's kind of, okay."
1775680,1785040," There we go. Uh, so here we just check whether the name is intrinsic, whether it's a constant,"
1785040,1791200," whether it's a procedure, local memory, uh, right, or a global memory when it's not inside of the"
1791200,1798320," specific procedure or something like that, uh, which is rather weird."
1798320,1808640," Hmm. Hmm. This is a really weird code. I'll have to get back to it because I think it has to be the"
1808640,1816720," other way around. If you are inside of the specific procedure, uh, you have to look up its local memories,"
1816720,1823280," but if you're not, uh, you should check for the global ones. So this is a really strange place."
1823280,1830000," Uh, this is a really, uh, strange code. All right."
1830000,1843680," Um, I think this should be the other way around, right? The other way around when we are inside of a proc,"
1844480,1854640," um, we check local memories, uh, otherwise, otherwise the global ones."
1854640,1862000," Okay. All right. So that's basically the result of the language being unfinished, right? So when the"
1862000,1868800," language is unfinished, the code looks unfinished and surprisingly, but some people don't understand"
1868800,1874640," that, uh, they think that languages appear out of thin air being ready and, you know, everything."
1874640,1883280," Okay. So, all right. So here's the global memories and we can take the name, uh, all right. Um,"
1883280,1893840," and let's say global, uh, vars lookup. So in global vars lookup, uh, we duplicate and then we check that it's"
1893840,1905280," a, uh, pointer or not. Interestingly here, uh, interestingly here, we take this thing."
1907680,1914640," This is a very old code. I duplicate this thing and if it's not equal to null, I'm okay. I see,"
1914640,1918480," I see what's going on in here. So might as well, um,"
1920800,1929280," to bind it to something maybe, right? Because duplicating it and comparing it to null is not"
1929280,1934480," particularly convenient. So we might as well just like bind it. Uh, let's call it gvar for global"
1934480,1942080," variable because I cannot use var because it's a keyword. So gvar, uh, right. And then if gvar"
1942720,1950560," is not null, right, is not null, we're going to throw an error, uh, indicating something. So there"
1950560,1955360," is a location and this is the location that we probably passed. Yeah. Yeah. So it was passed in"
1955360,1967120," here, right? Location input lock, um, error, redefinition of a global variable, uh, a global variable. And then"
1967120,1977920," we'll just say the name of that global variable in here, like so, right. Then, uh, I can just take this"
1977920,1990720," thing. It's going to be var location pointer plus input lock. Uh, uh, the original definition is located"
1992400,1998080," here. All right. And then we're just going to do that. And I didn't have to drop anything in here."
1998080,2003600," And, uh, I didn't have to duplicate anything in here. So I might as well actually do something similar"
2003600,2013600," in here. Um, right. So essentially instead of duplication, I can do, uh, gmem in here, gmem."
2017520,2025920," All right. And then I have to drop anything, uh, like so. Cool."
2025920,2036160," So it's kind of similar thing. Like you can even see that, uh, the global memories are like global"
2036160,2042320," variables. So that's why one mechanism is going to deprecate another one. Uh, so yeah, it's just like the"
2042320,2049600," variables are more type safe than the memories, uh, anything else global virus lookup is not"
2049600,2055520," implemented, which is actually correct there. It is not implemented. I wonder if I can just copy paste"
2055520,2062800," global memories lookup, uh, thingy, right? So what it does, it just iterates through all of the global"
2062800,2068480," memories. And if it finds the name, it just returns that otherwise it results nothing. So this is actually"
2068480,2074640," rather complicated code for this thing. And this is because we didn't have early return before,"
2074640,2079920," right? So with the early return, like iterating through array of things and just like returning"
2079920,2087280," as soon as you found something is super easy, but not in here. Right. So let's actually see how much we"
2087280,2094240," can simplify such code. If we use, uh, like an early return is actually very interesting. Um, okay. So I'm"
2094240,2103040," going to just do zero and while this thing is less than global vars count, right? So I'm reading it as"
2103040,2110880," an integer and just like, like this, uh, and then in here, I might as well just do it like that. Oh boy."
2110880,2119280," So maybe it would make sense to like make it as an index, right? So then I just take the index,"
2119280,2131040," I multiply it by the size of the var, right? And then I have set global, global vars, uh, plus ptr,"
2131040,2138480," right? Something like that. And that gives me the, uh, the thing. And I wonder, I don't really care about the"
2138480,2147680," index per se. So I might as well just do dup like, so, and this gives me, uh, g var, and then I can just"
2147680,2157360," do plus one. And here I just have a g var, uh, then I can go ahead and check the name. So variable name"
2157360,2166000," pointer plus, and I just read it as a string. So in here we have a name, right? So maybe I can just bind it to"
2166000,2173760," something. So it's a little bit easier for me to use that. So here, of course, drop."
2173760,2191040," And then I can do n and s. And if it's equal, I can right away return g var from this entire thing."
2191040,2197440," Though it's not going to work because on top of the stack we have an index, right? So it would be better"
2197440,2205200," to probably just bind both of them. Uh, right. So here I just like construct this thing and I just bind"
2205200,2214720," both of them. And then I put the index back in here after I'm done with everything. Right. That's actually"
2214720,2221840," pretty cool. So if the name is equal to what we expect, we just return right away. Otherwise we can"
2221840,2230480," simply return null and that should work, I think. That's pretty cool. Not gonna lie."
2230480,2238000," That's pretty straightforward and pretty simple. So let's see if this type checks."
2240400,2248720," Okay. Global vars count. Uh, global vars. It's probably called global var count. Wait,"
2248720,2255360," it doesn't exist. Where, where is it? I didn't see it. Ah, this is because I actually define it like"
2255360,2257920," below all of these functions."
2260000,2267760," let's quickly fix that. Okay. And it seems to be type checking. Uh, okay. So we checked redefinition."
2267760,2273760," So we can go ahead and just check, uh, if we try to redefine something that already exists, for instance,"
2273760,2281520," full, right? So it should not work, right? You're trying to redefine a procedure full, right? So redefinition"
2281520,2287840," of a procedure full, uh, original definition is located here. Okay. So that's pretty cool."
2287840,2293920," We can actually try to do something like that. Well, it's not gonna work because we haven't finished"
2293920,2302000," defining the variable. So that's fine. Uh, this one has to be X and I think we're good to go. I think"
2302000,2307280," we're good to go. We checked the redefinition and what's going to be the next thing. The next thing we"
2307280,2312800," need to parse the type of the variable, right? So we need to parse the type of the variable and how"
2312800,2318960," we're going to be doing that. How are we going to be doing that? So I suppose we're going to be just"
2318960,2325440," like parsing it as the signature of the procedure, right? So we're just going to construct a type stack."
2325440,2332160," And, uh, as we encounter things, we're going to push them on the type stack. And if we encounter pointer"
2332160,2338080," two, we increment the pointer counter, and then we just return the type stack. And for now, for the"
2338080,2342800," variables, we're going to expect the type stack to contain only a single element. Though in the future,"
2342800,2350320," it would be interesting to explore an idea of defining variables with several types. Like for example,"
2350320,2357680," if I define X being integer and pointer, what's the implications of that? Right. So what does it mean?"
2357680,2365680," Do we store two words in a row in a memory? And how do you access the second one? So it's kind of weird."
2365680,2369520," It's kind of interesting. And I'm not sure if I'm going to go that route, but this is something to"
2369520,2375200," explore. But for now, we're only going to allow one type on the stack, right? So you can define"
2375200,2380320," just an integer, or you can define pointer to an integer, or pointer to a pointer to an integer,"
2380320,2386720," and so on and so forth. Right. So and that's why we need a word end in here, because defining a single"
2386720,2394240," type may actually take three words. In fact, it may take a lot of words, right? So and this is actually"
2394240,2401200," this defines a single type, right? So we push original type, and these are just like the type modifiers."
2404320,2411280," All right, so for that, we probably will need some sort of special procedure that stops at keyword end,"
2411280,2425280," right? And probably accept some sort of Lexa. And right, it will just pull the tokens from the Lexa,"
2426160,2431360," and just push them into the type stack. So that's that's the plan. That's the plan for this entire"
2431360,2442080," step. Alrighty, so let me let me see. And because of that, I suppose the variable definition must"
2442080,2449120," has a pointer to that specific type stack, right? I think I'm pretty sure."
2451680,2462560," Yeah. So where is the var size of var? Okay, so we don't really know any sizes or anything like that."
2462560,2467200," It's kind of interesting that in in case of a memory, we also don't know the sizes of the memory."
2467200,2476560," But maybe they are not needed, right? So for that specific place. Okay, so here we're going to have var"
2478000,2485280," type, and this is going to be size of type stack, right? For now, it's going to be just a type stack."
2485280,2495040," Though, this one is rather, this one is rather weird. Maybe, maybe it's going to be just an integer,"
2495040,2503440," right? So it's maybe it will simplify the, oh boy, the type checking, though, it can be kind of painful"
2503440,2511120," in terms of parsing, if you know what I mean, right? So if no type is provided, we also have to check for"
2511120,2518320," that. And it would be easier to just use a type stack for that. And do we use the type stack as"
2518320,2523120," intermediate thing for that, or as not an intermediate thing for that? It's just like kind of..."
2526080,2531040," I know, let's let's use type stack. Right, so this is going to be type stack. But if we're using type"
2531040,2537920," stack, that means it could be accidentally empty. There's a lot of room for error in here. So if we"
2537920,2542400," intend the variables to be just like a single type of thing, I think I'm just going to go with an integer"
2542400,2549120," in here. That's right, I'm just going to go with an integer in here. So I think I want to make a small"
2549120,2556720," break. And after the break, we're going to continue doing all that. All right, let's continue. So the"
2556720,2565120," only thing that is left to be implemented is parsing the types, right? So let's go ahead and do that."
2565120,2573520," Maybe we're going to introduce something like parse var type. All right, and essentially, it will accept the"
2573520,2582800," Lexa. And it should return the type of the variable. Right. And in terms of types of the variable var type,"
2582800,2591760," it is a pointer. So it should be possible for me to just... Oh, boy. So this one is really interesting."
2591760,2603360," Can I do size of var tmp alloc and just have the variable of some sort, right? Var in here."
2603920,2612000," So I can just do my my usual stuff and then do something like var var type a pointer plus,"
2612000,2622240," right? And save it as an integer. The question is, do we clean up the temporary buffer on each iteration"
2622240,2631760," of the compilation? So do we do tmp anywhere else? Looks like we do, but we also rewind. Okay,"
2631760,2636400," for the constants, we just like literally rewind everything back, which is something that we can"
2636400,2645920," also do, right? Like this tmp rewind, because why not? That would be a little bit more convenient to"
2645920,2653920," basically rewind, excuse me, till sick, rewind every iteration of the compilation loop, but I'm not quite"
2653920,2663840," sure. Anyway, so this is basically what we're doing, right? And do we need to do anything else? This one"
2663840,2671680," is rather interesting. So here is the, here's the word. And on top of that, it would be nice to maybe,"
2673360,2681520," uh, you know, set the variable name somehow. So it's going to be value at str. And it's just going to be"
2681520,2688160," variable, variable name pointer plus, right? And then just like save this entire string."
2688880,2695760," Uh, let me take a look size of war. So what else do we need? We define the name, we defined the, um,"
2695760,2702320," the type, uh, we also need to define the location. I presume, I presume the location is super important."
2702320,2709760," So let's quickly do that. Uh, location, uh, right. And var, var log pointer plus,"
2709760,2715680," maybe we're going to even do something like size of location and then just mem copy this entire thing."
2715680,2725120," Right. Hopefully that's how we're going to do that. Uh, let me realign everything just in case."
2725120,2732160," Uh huh. So this is the sources. This is the destinations. And that's how we set up"
2732320,2738000," everything. Not sure about the offsets. How do we do that in there? Okay. So as you can see here,"
2738000,2743760," we even copy a str instead of actually using like, um, you know, spilling stuff."
2743760,2756240," Okay. That's cool. Uh, memory size. So we have const type and memory size. And that's how we use a memory size."
2759600,2766880," So we take the global memory capacity. Right. And we assign the global memory capacity as the, uh,"
2766880,2780000," as the size of this thing as the offset. Right. Then I take the global memory capacity. And I suppose"
2780000,2787920," I add, what do I add in here? Right. I'm not quite sure. So apparently I add something,"
2788480,2795920," but what do I add? I suppose I add memory size that I actually assigned in here. Uh, right. So that makes"
2795920,2801920," sense. And then we define this entire thing. All right. So that actually makes sense. I might as well"
2801920,2808320," actually steal that code for the variables, uh, for the variables, it's going to be a little bit easier."
2808320,2815840," I think. Uh, so we take global memory capacity. Right. So this is the global memory capacity."
2815840,2823280," And then I take var and I take var offset and I just save it as it is. Then I take the global memory"
2823280,2830000," capacity and I add the size of the variable for now. It's going to be always eight, right? Uh, because we"
2830000,2836720," don't have any other types than of the size eight. Um, and then we just like added into the global memory"
2836720,2844400," capacity capacity. Though we could have just used, um, something like ink, uh, 64 by, I'm pretty sure we"
2844400,2854000," could do something like this. Uh, right. So it's going to be eight and ink 64 by, right. Then you could take"
2854000,2864480," var and do global var define, right? So we can define a global variable like so. So we set the location, we set the name,"
2864480,2872880," we set the type, we set the offset. Everything seems to be set appropriately. Uh, right. And we might"
2872880,2880720," as well actually do the following thing. I'm going to align like so. As you can see, everything is set"
2880720,2890080," appropriately. The entire structure. Uh, then we increment the global memory capacity, uh, and then we just set global var"
2890080,2895520," var define. Mhm. Cool."
2895520,2910160," Interesting. So is that it? As far as I can tell, that is basically it. Uh, we don't really need anything else."
2910160,2917040," Though we may, we might want to have local variables, right? Uh, but even with the local variables, I'm not 100%"
2917040,2922080," sure, uh, how we're going to approach all of that. That doesn't really matter. Okay. So here's the"
2922080,2928880," compilation of the, of the variable, right? So let's go ahead and just try to compile the entire thing."
2928880,2936960," And we don't have a parse var type. So let's quickly define this thing. So this is going to be the pointer"
2936960,2946080," to the LACSA, right? And in here, I'm going to just drop that and say, uh, parse var type is not implemented"
2946080,2958000," yet. Right. It is not implemented yet. Okay. Unknown word global vars, uh, define. Is that how it's called? Okay."
2958720,2969920," Uh, integer. Um, so parse var type should return the type that it managed to parse. All right. So it is the"
2969920,2977680," type. And for now I can say that it's maybe data type integer. It doesn't really matter. So just have"
2977680,2983760," something. Okay. So, and it says that this thing is not implemented. Cool. So the first thing, it's kind of"
2983760,2989200," interesting that according to the current type system, you can't really defined anything, but"
2989200,2998240," just a primitive type and a bunch of pointer twos, right? So the type system does not allow you to do"
2998240,3006800," anything else, but that, excuse me. And maybe we're going to go, go off of that. So let's go ahead and"
3006800,3017760," try to do that. Uh, memory token size of token, right? So Lexa, I'll probably have to go to Lex,"
3017760,3025920," Lexa next, uh, next token. So we provide the pointer to the token and it will be also probably nice to"
3025920,3035840," just bind Lexa to something, right? So it's going to be talking Lexa, Lexa next token, right? So this is a"
3035840,3043760," Lexa next token. And if is, this is not available, right? This is not available. Uh, we should throw"
3043760,3049520," sometime, some sort of an error. I presume we should throw some sort of error, but what kind of error do"
3049520,3061040," we want to throw? Um, we need to know the current location of the thing, right? So Lexa, um, get location. So here"
3061040,3069760," here we have to provide the pointer to the location, uh, right? So token lock pointer plus, then the Lexa,"
3069760,3075920," then, um, Lexa get location, right? So this is how we get the location."
3077920,3083680," And then I'm going to do you put lock, right?"
3083680,3094000," Excuse me. Expected, uh, primitive type, uh, but got nothing. Right. So this is what we're going to say"
3094000,3101920," in here. Um, I swear to God, um, one day I'm going to just remove company mode. It is not helpful"
3101920,3110960," whatsoever. It is insanely how it is unhelpful. Um, okay. So what's the next thing? We need to now"
3110960,3116960," take whatever we've got and try to parse it as a primitive type, right? Uh, so, but it has to be"
3116960,3121520," specifically a word, right? So we need to check that it is a word. We have to do a lot of checks."
3121520,3129040," I really don't like that. Um, I really don't like how many checks we have to do, but it is what it is."
3129040,3137440," Token, uh, type, right? So pointer plus, and if it is not equal to token"
3139360,3155280," um, word, right? So if it is not equal to token work, we have to say that expecting expected a word."
3155280,3160560," So I'm going to put it to do, um,"
3164480,3173440," report, um, expected word, right? So I really don't want to spend too much time, like, uh,"
3173440,3177600," you know, carefully reporting everything because it's just like too much busy work"
3177600,3182640," instead of like actually getting the feature as quickly as possible and seeing how that feature"
3182640,3187440," plays out with the rest of the language, right? You can spend the whole day just like, you know,"
3187440,3192800," ratholing about this, like little tiny details and refactoring everything. So it's easy. But the main"
3192800,3199520," goal right now is to get to the working feature as quickly as possible, uh, mainly, uh, the variables"
3199520,3204400," and the ability to read and write the variables in a type safe way. That's it. So, and the rest of the"
3204400,3209120," stuff can be done later, much, much, much later because the language isn't finished anyway, right?"
3209120,3216960," So we don't even know how the language looks like. Um, so this is not a word, right? And then we can go"
3216960,3224400," ahead and just take, uh, token value, right? So point plus, uh, read it as a string and then"
3224400,3234640," we need to parse it somehow, uh, data type, uh, how is it called by name, right? So data type by name,"
3234640,3244800," data type by name. And if it's not, uh, a data type, right? If this is not a data type, we're going to say, um,"
3245520,3255440," report expected primitive, uh, data type, right? So emacs stop. Okay. So if it is a primitive data"
3255440,3262240," type, we can keep it in here on the stack. We can even check how it works in here, uh, right? Argument"
3262240,3270480," not equals. Um, I think we, I have to read it first, right? So stop in the compilation. And here is the,"
3270480,3278880," is the thing, right? So here is the thing. So, uh, we now have the type, which is cool. Uh, nice."
3278880,3287920," We can probably also unpack the type, unpack, uh, the type and essentially get the, um, you know,"
3287920,3295600," the point account and the primitive type. Uh, so, and then here we'll have to pack it back. So now what"
3295600,3303360," I want to do, I want to keep like reading the data from the Lexa, right? I want to keep reading the data"
3303360,3314640," from the Lexa. So while, um, oh, this one is also rather interesting. Um, so token Lexa, uh, next"
3314640,3316080," Alexa, next token, right? And if it is not a thing, right? If we couldn't read the next token, uh, we'll need"
3316080,3329920," to report an error saying something like, uh, uh, report expected, um, maybe something like reached and before, uh,"
3329920,3352400," uh, reach and the file before the end, uh, of the var definition. Again, I'm going to make like a proper error"
3352400,3361920," reports, uh, like much later. Uh, all right. So in here, if it's not like available, we don't care about"
3361920,3369040," that. And the next thing has to be, uh, the following stuff, token type point to plus an integer. And we"
3369040,3375200," might as well just do something like this. So it's going to be an integer emacs stop. I'm really going to"
3375200,3387280," remove the company. It's like not useful. Uh, okay. Uh, type equal token. Um, so what do I care about?"
3387280,3393920," So it's a word. If it's a word, I'm going to do one thing. Otherwise, if it's a keyword, right? So this is"
3393920,3400480," the second thing that I care about. If it's a keyword, if it is something else, right? We have to report that."
3401040,3412080," Uh, so report on expected token type in the variable definition. I can't see a definition."
3412080,3417760," There we go. Just too many errors, too many errors. I need to report. It doesn't really matter right now."
3417760,3427440," Okay. So if it's a keyword, right? I ex specifically expect the, uh, and keyword, right? So I want to do the"
3427440,3433040," following thing. Uh, might as well actually do token, token value point to plus and just like"
3433040,3439600," read it though. It depends, right? So the value could be anything, right? Depending if it's a word,"
3439600,3444320," the value is going to be a string. And if it's a keyword, it's going to be an integer. So what we"
3444320,3449920," want to have in here is in fact, something like this, right? And the value I'm going to read it as an integer."
3449920,3459440," And if the keyword is an end, right? If it is an end, we're going to just like return false indicating"
3459440,3469040," that we need to finish the loop. So here it's also false because it's an error, right? Otherwise, uh, to do"
3469760,3478720," report, uh, unexpected keyword in the variable definition, right? So that's what we're going to"
3478720,3485200," have, right? This is false. In case of a word, I'm going to take the value, read it as a string,"
3485200,3491520," and I'm going to compare it to the point to two. Um, all right. So comparing that to point to two,"
3492160,3499760," str equal. And if it is that I need to actually check, what do we have on top of the stack? Uh,"
3499760,3508240," do while, uh, do is not preceded by while. Are you insane? You are insane. This is the while. Um,"
3508240,3517920," okay. That is, um, preceded by light instead. So I forgot to close whatever I have in here. I think I"
3517920,3524800," know what is going on. So I should put a star in here. Okay. So there we go. Okay. So we have a"
3524800,3530080," couple of integers and both of the integers come from unpack type. So that's precisely what I would"
3530080,3537040," expect in here. Uh, right. So, and that means I can just take the point account and the primitive type,"
3537040,3545840," uh, right. And simply point account one plus, uh, and primitive types. So that's it. And then, uh,"
3545840,3553840," simply continue iterating. Uh, otherwise, if it's something else, I have to report, uh, unexpected"
3553840,3559920," word in the variable definition, right? So that's what we have in here. And we're going to return"
3559920,3568080," false as an indication that the stuff is done. Okay. So after that, we can pack the type back,"
3568080,3574720," right? We can pack the type back, pack type and call it a day. There we go. There's all the things"
3574720,3580480," that needs to be reported properly, but that is fine. That can be done later, much, much later."
3580480,3586240," Okay. Global wars, uh, is not defined. Okay. So here we're trying to define this thing. And what"
3586240,3592240," we need to do, we just need to copy the structure to an array of global wars, which should be pretty"
3592240,3601760," straightforward. A global memories, uh, define global memory define. Right. So that's how we're going to be"
3601760,3614400," doing all that. Uh huh. So we assign global memory. So global wars capacity, global wars, global wars count,"
3614400,3622160," and then we just append this entire stuff. And that should be it. Global, uh, wars definitions capacity"
3622160,3634400," exceed it. Yeah. There we go. Uh, global wars overflow, in fact, uh, overflow, global wars overflow. There we go."
3634400,3642960," There we go. Cool. Hmm. Hmm. So a lot of shortcuts, but that's fine. Uh, main procedure was not defined."
3646080,3654640," Wow. Wow. That is super sus. The fuck, which makes sense. All right. So it's not as sus as I would expect."
3654640,3661360," So it actually went further. So it parsed the, okay. That's actually super cool. Uh, if I remove this thing,"
3662480,3673440," Uh, right. If I remove this thing, it will not work. Report an expected word. Uh, report expected word,"
3673440,3679600," right? Report expected word, but got something else. So if I provide an integer, it will work. It will say"
3679600,3685440," that main is not defined, but it will still work. Uh, point to two, uh, what do we have? Uh, report expected"
3685440,3690800," primitive type, but this is not a primitive type. Uh, right. And if I try to do something like this,"
3690800,3696080," uh, yeah, everything seems to be working. So, but for now I just need only that, right? I just need"
3696080,3703120," only that and that will not work because we don't know the word X. This is very, very cool."
3703120,3713360," This is very, very cool. Uh, because now we need to, yeah, I could have just to reuse, um,"
3713920,3724160," OP push global mem, but it doesn't carry any information about the type. So we'll probably"
3724160,3733120," have to introduce a new construction, something like OP push global var, which also holds an index of a"
3733120,3741200," global variable that we're trying to push. Right. So, and of course that makes the intermediate"
3741200,3746000," representation more complicated, but the language is unfinished. Everything is going to be cleaned up"
3746000,3751440," after I'm done with the design, right? So right now I'm just adding features to the design just to try"
3751440,3758000," them out in the wild and see how they play with the rest of the design language. Are they ergonomic? Are"
3758000,3763920," they difficult or easy to use? What could be fixed about the ergonomics of this feature? And then once I"
3763920,3768480," decided, okay, I'm going to keep that feature. I'm going to go ahead and clean up intermediate"
3768480,3774080," representation. I'm going to make the code a little bit more, uh, you know, a little bit less"
3774080,3781440," how to say that maybe like, I will go out and just like, uh, pay off the technical depth and stuff like"
3781440,3788800," that. The goal right now is to get the feature working as quickly as possible. Right. I know a lot"
3788800,3794000," of programmers like get really, really triggered when they just like, try to get the feature as quickly as"
3794000,3799440," possible and write a lot of these like very hacky code, but that's what you do if you want to get"
3799440,3804800," the feature as quickly as possible. Because then later, once you know what exactly is the feature that"
3804800,3813760," you want to have, you can just go back and write the clean satisfying code. Right. So I do understand that"
3813760,3820720," that it is painful sometime to write this hacky code, but you just have to grow up and acknowledge that"
3820720,3826480," sometimes that's what you have to do. Sometimes you just need to get the done. Otherwise you won't"
3826480,3832160," gather any information and wouldn't know, would not know what you need to implement in the first place."
3832160,3833840," Right. It's not always like, you know,"
3835840,3841280," rainbows and unicorns. Sometimes you just need to, you know, get your shit together and just implement"
3841280,3847040," the feature and see if it works or not. And once you know, if it works, you go back and, you know,"
3847040,3853120," clean up everything. So, yeah, anyway, so, uh, we're going to introduce the new intermediate representation"
3853120,3857920," instructions specifically for the variables, because that's the easiest thing to do right now. It's going"
3857920,3862960," to be fixed in the future. Don't worry about that. Uh, so yeah, but before, let me actually commit"
3862960,3878720," everything I have. All right. All right. Introduce variables. Introduce variables. And now, um, let me see."
3878720,3892080," Yeah, let's go ahead to the compilation. Intrinsic. Uh, and what do we have?"
3893120,3901520," Uh, not really intrinsic. I actually have to go to, um, OP maybe? OP push. Uh-huh. Okay."
3901520,3914560," Emacs. Jesus fucking Christ. Okay. Global. I'm not going to document it right now. Uh, OP push global var one offset."
3916880,3920400," Uh, okay. So, it has to be somewhere."
3920400,3927360," OP push global var. Global var."
3927360,3932720," OP push global var. Uh, I'm going to actually do something like to do."
3932720,3943680," Document. Um, yeah. Doesn't really matter right now. It can be done much later. Um, so push."
3945440,3950720," Yeah. That's what we need. We only need push. All right. So, let's go ahead and just like try to"
3950720,3958640," compile this intensive. Uh-huh. Uh-huh. So, global memory, global var."
3961680,3973040," Uh, 25, 26. I keep explaining people over and over again the reason why I write quite often like this"
3973040,3978640," hacky code and nobody listens. Like, I mean, I think I should stop doing that. I think I should stop"
3978640,3983280," explaining that. Yeah, yeah, it's temporary. I'm gonna go back and clean, uh, clean everything over"
3983280,3988000," because people can't hear that. So, I'm definitely gonna stop explaining that over and over again. I'm"
3988000,3995840," really tired. Um, so, okay. So, in here, when we introduce a new intrinsic, this is precisely what"
3995840,4002800," we need to do, right? So, here we look up for the local memories, for the global memories, for some other"
4002800,4014160," stuff. So, let me find the global memories. Cool. So, what we do is drop, dupe, uh, global, uh, vars, look up."
4016160,4029920," Uh-huh. And then we do op, push, global variable, right? Um, swap memory. That's actually var."
4029920,4040960," Is it has to be a var of set? Uh, what I want to do in here is I want to have an index for a variable,"
4040960,4049680," right? I want to have an index for a variable. Um, if I want to do that, I'll have to do something."
4049680,4052480," Okay. So, let me take a look at what I have in here."
4052480,4066160," It's, it's not gonna let me do that. It's so annoying. Okay. Uh, I suppose, uh, here I just have a"
4066160,4071760," pointer to the, uh, to the variable, right? So, it's just a pointer to the variable."
4071760,4082320," Uh, I can take this thing and take global vars, right? So, this is the pointer to global vars."
4082320,4088400," I can swap that and I can find the pointer difference. That will give me the index. Well,"
4088400,4095360," it's gonna give me a set which I'll have to divide by the size of the structure. And that is the index"
4095360,4101840," that I can probably push, uh, as the operand of the intermediate representation. So, that's probably"
4101840,4112480," what I can do. OP push global, uh, global var, right? So, and then it's an index, right?"
4117840,4124880," Yeah. Yeah. So, it's an index, then the token, and then a push OP. Hopefully, that will work."
4124880,4132880," Right. So, okay. Let's take a look at this stuff. The, uh, type checking. Okay. The type checking is"
4132880,4141120," actually super interesting. This is super interesting thing. Right. So, it's an else type,"
4141120,4151200," uh, integer OP push global var, right? So, what we'll have to do, we'll have to take the index of that"
4151200,4158800," thing. Do we have an operand somewhere? So, here is the operand and operand is a pointer. So, I can do"
4158800,4167520," operand, uh, read it as an integer, multiply it by the size of the vars, and then take global, uh, vars,"
4167520,4174640," and do an offset. And that gives me the global var, gvar. Right. And in here, what I can do,"
4174640,4182960," I can take the gvars, uh, type, var type pointer plus, right? And read it as a type. Then I can unpack"
4182960,4189520," this entire thing. All right. I'm unpacking this entire type. And, uh, here we have a pointer count"
4189520,4195840," and the primitive type. So, and what I do, I just take the primitive count incremented by one,"
4196400,4202720," all right, incremented by one, and, uh, bring this thing back and pack everything back. And that's the"
4202720,4210640," type that we're going to be pushing into, into the type stack. Right. So, then I can take the location"
4210640,4219040," stack and just do type stack push. Right. Uh, interestingly is that I don't really need gvar for"
4219040,4228640," anything else. So, that means I can just basically squash these two things like so. Right."
4228640,4237760," That's very cool. So, I take the type of the global variable, I unpack its type. Then I increment the"
4237760,4243680," pointer count of that type, pack it back, and just push it into the type, uh, type stack. And then I need to,"
4244240,4250080," uh, basically add information to the queue for the BFS because here we're doing BFS over all of the"
4250080,4257840," control flow to type check everything. So, yeah. IPQ is basically the queue of IPs instruction pointers."
4257840,4263600," Right. So, it's just like a queue for the BFS of type checking. Um, all right. So, that should be it."
4264160,4270160," Right. Uh, let me take a look at the assert. Did I increment the assert? I didn't remember actually."
4270160,4275040," So, and here is the generation. And in terms of generation is going to be just like pushing the"
4275040,4286160," global memory, I presume, uh, OP, uh, let's actually see OP push global memory. Right. But it's slightly"
4286160,4295120," different, right? Because in the operant, we don't have the offset, right? We have the index of the variable."
4295120,4301600," So, first we'll have to query the variable by the index, take its offset and only then use that offset to,"
4301600,4310720," you know, push the thing. OP push global variable equal to that. Right. So, then I need to take the operant,"
4311440,4321440," again, multiply it by var, then, uh, put global vars, uh, pointer, and that gives me the global variable."
4321440,4329680," Might as well, actually, right away, um, var offset. Right. So, this is a var offset pointer plus. Read it"
4329680,4335760," as an integer and there, here is the offset. I'm going to call it off because offset is a keyword. And then I"
4335760,4343840," can just like put it like this. Instead of an operant, we're going to use off. Um, yeah, that's,"
4343840,4349600," that's literally it because the global variable is stored in the same region as the global memories,"
4349600,4353520," right? The global variables are the global memory. It's just like more type safe."
4353520,4361280," Uh, it's just more type safe. Okay. So, what else do we have in here? And I forgot to increment"
4362720,4373600," 2526. Right. Uh, and that seems to be compiling surprisingly. The example is compiled, believe it"
4373600,4380800," or not. Uh, I think, I think it is compiled. Right. Okay. So, let me try to do the following thing. So,"
4380800,4388240," we have X, right? And if you just put X in here, it's not going to do anything. It's going to actually fail"
4388240,4395120," and handle data on the stack. And it says that the type of that data is int pointer to the type of the"
4395120,4400240," variable is int. But when you try to access this variable, you get the pointer to this variable."
4400240,4406320," Right. Which makes sense. If you just make it pointer to, uh, you will get pointer to pointer."
4406320,4413840," Right. So that makes sense. That makes a lot of sense. Cool. So then we can do something like 69 and"
4413840,4421040," save this thing like that. Right. Does it work? It does in fact work. Then I can try to read this"
4421040,4427280," entire thing. And on that stack, we should have an integer. And if I try to print, uh, whatever we"
4427280,4432880," have in there, right? So let me actually get rid of this thing. Uh, if I try to print, it should print"
4432880,4439760," 69, but we don't actually run the program limit. Uh, okay. And it does in fact print 69. Would you look at"
4439760,4447760," that? It's actually pretty cool. So now we can define, uh, a type safe version of ink 64. Right."
4447760,4455600," So let me, let me show you what I mean. So in core, we have ink, uh, 64, which takes untyped pointer"
4455600,4462880," and tries to interpret whatever is behind that point as 64 bit number and increments it. Now I can define"
4462880,4469040," the following structure, uh, function ink, uh, which just accept a pointer to an integer and that's it."
4469040,4475600," Right. And then here, uh, right. So we have a pointer. What it will do, it will just read"
4475600,4479760," the value of that thing, increment that value by one and save it back."
4479760,4489040," So, yeah, that's actually pretty straightforward. And, uh, so here I'm saving 69 to X, then I can say X"
4489680,4496000," increment, then I can read the X and print again, and it should be equal to 70. Right. Uh,"
4496000,4504560," and it is in fact equal to 70. Right. And, uh, if I try to at any point, like save, uh, I don't know,"
4504560,4510800," true into this entire thing, right. If I try to save true, it will just not work because the pointer of"
4510800,4515760," this thing is supposed to be a Boolean, uh, integer, but we're trying to save a Boolean in here. So you can't"
4515760,4521600," do that. Uh, but you can define something like flag, which is going to be a Boolean. Right. And then you"
4521600,4528720," can say, uh, true flag and just save true into that flag and that will work. Right. So as you can"
4528720,4535840," see, this thing becomes sort of overloaded based on the pointer, on the type that is behind the pointer."
4535840,4542640," Right. So we have memory safe pointers. Now, uh, they're not really powerful that much. Right. So they"
4542640,4548560," only can work with primitive types, but in the future, we're going to introduce, um, composite"
4548560,4553520," types. I think this is how they call it like structures and unions and stuff like that. And"
4553520,4559520," this mechanism of the, you know, type safe pointers is going to be very, very useful for all of that."
4559520,4566160," Right. So yeah, that's basically the feature that I wanted to implement. Right. So it's a rather"
4566160,4572080," complicated feature. So it required, um, I don't know, two or three hours to properly implement,"
4572080,4579440," but we got there. Um, so it's already kind of useful. I already can use these for counters. Right."
4579440,4587600," So I have a lot of, uh, global variables in the global arrays, um, in the, um, in the compiler. Right. And"
4588880,4598960," let me take a look. So like a global vars, you know, and they usually accompanied by a counter variable,"
4598960,4604160," right? So there's this counter variables. I can now convert all of these counter variables into like"
4604160,4610640," actual variables, like global vars count integer. Right. And they already going to be a little bit more"
4610640,4615440," type safe and a little bit more pleasant to work with. And in the future, as the type system becomes more and"
4615440,4621120," more powerful, uh, even those like global arrays can become also variables. And at some point,"
4621120,4626240," we're going to completely get rid of memories and we're only going to have variables of specific types."
4626240,4633280," At least that's the plan. That's the plan. Right. I'm not really sure if I'm going to get rid of the"
4633280,4640320," untyped pointers because sometimes they're quite useful for describing, I don't know, opaque types."
4640320,4645200," Right. So it's, it's kind of equivalent to void star as already mentioned. Right. So void star,"
4645200,4650240," you don't know the size of the data behind that pointer, but it's a pointer. It's pointer somewhere"
4650240,4658000," in the memory to a thing of unknown size. At least you don't know the size. Maybe the code that accepts"
4658000,4662640," that pointer knows its size, but this, the actual size of the data behind that pointer is kind of"
4662640,4668800," none of your business. So it is kind of useful for these opaque types. Uh, we'll see, we'll see, we'll see."
4668800,4674960," So maybe I'm going to keep on untyped pointers. Right. But, uh, that's basically it for today."
4674960,4679520," Thanks everyone who's watching me right now. Really appreciate it. Have a good one. And I see"
4679520,4687360," you on the next Zozin session where we'll make Porth even more powerful language. Okay. Love you."
