start,end,text
0,13080," All right, looks like we're live. Hello, everyone, and welcome to another Zozing session. How about"
13080,18480," that? Hello, copper case it Hello, hello. So let's make a little bit of an announcement and tell"
18480,26880," people on the discord server that we're live. How about that? So we're gonna say a red circle live"
26880,35460," on Twitch as an opposite of being offline on YouTube, right? So and today, we are continue"
35460,41220," making a self hosted compiler. And that's right. So for the past, like month, we've been developing"
41220,47820," a compiler for our own programming language called port, you can find the link to the source code in"
47820,54340," the description. And the compiler is written in Python, but it became mature enough to be rewritten"
54340,61420," in itself. And people are already throwing money at me just a second, copper case, port time,"
61420,66580," exactly. Thank you so much for 26 months of tier one subscription. Thank you, thank you, thank you. And"
66580,72400," welcome to our epic port club. So you can find the source code to the project in the description. If"
72400,76540," you're watching on YouTube, if you're watching on Twitch live, you can find this thing in the chat,"
76540,81640," right, just do the today command or project command. And the bot will tell you everything. Hello, hello,"
81640,91300," everyone. Hello, well, I need to be prime craft work in P seven, as I could deal. They lean zero. Hello,"
91300,99520," hello, welcome, welcome, welcome. So we already kind of started doing self hosted thingy, right? So we've"
99520,105340," already started writing the compiler in itself. And this is basically how it looks like. So what's"
105340,113740," interesting is that we basically defined a bunch of operations in the internal into in the intermediate"
113740,122500," representation of the language, right? So so far, we have push integer plus and print. And we allocated an"
122500,129160," array where we keep all of the separations. And what we implemented is just a compilation of that array and"
129160,137140," simulation. So and we fill up that array inside of the compiler itself, right? Literally inside of the"
137140,144840," compiler, we call something like program 123. And we push the instructions of the program 123 into the"
144840,151960," operation array like manually. So the programs right now are hard hard coded within the compiler itself,"
151960,158200," right? So and of course, it's not acceptable for a final final result. But it's okay to just like"
158200,166360," develop the skeleton of the of the compiler. Right? So what I want to focus on today is on actually"
166360,174520," unhard coding the program that the compiler is supposed to compile and interpret. So to unhard code this entire"
174520,181900," thing, we need to be able to get the path to the file that the user provides, why the argument of the"
181900,188140," command line or something like that, open that file, read the content contents of that file,"
188140,196060," create the contents into words, iterate each individual word and see if it corresponds to number,"
196060,204140," plus or print, and push the corresponding operation code into the, you know, operations array, and then call"
204140,211180," the simulation or a compilation. So that's basically the plan for today, essentially. And we have to do all of"
211180,219260," that import, right? So yeah, we have all of the necessary sys calls to do that. I think we're going"
219260,225260," to use memory mapping, right? I'm not going to open file and read it chunk by chunk because it's kind of"
225260,230620," tedious and also error prone. So what I want to do instead, I want to just take the input file that the"
230620,236620," user provided and memory map it. So I have the entire file in like mapped into memory, so I can treat it as a"
236620,243500," string and just split everything and just extract those operation codes that they need to compile or"
243500,252060," interpret. So and after that, we're going to have basically a very small subset of ports re implemented"
252060,257580," in ports. And once we have that, the only thing that is left is to just keep extending that subset"
257580,263900," until the compiler is capable of compiling itself. You see what I mean? So that's basically the plan"
263900,273100," for today. Sounds good. Sounds Gucci. Sounds Tomaguchi. So does anyone have any questions?"
275900,286220," Do you have to recompile language in original? So somebody submitted like, I think it's a donation."
286220,293820," The nation by they're so used they donated $6.24. Nice stream me like have a good day. Thank you."
293820,300140," Thank you so much for for the donation and have a good day as well. Thank you. So do you have to"
300140,307260," recompile language in original compiler whenever you add a new feature? Ah, it's a tough one."
307260,312060," Well, eventually, I want to get rid of the original compiler. So"
312060,320620," yeah, so I suppose maybe people don't really understand how the whole dynamics of this thing"
320620,332620," works. Maybe I will try to I will try to explain. So to do two. So essentially, the compiler right now"
332620,344380," is written in Python. So it's something like port port dot by port dot by into Python script. Right? So"
344380,353340," essentially, you feed that script into Python, right, Python interpreter, Python dot exe, or whatever,"
353340,357660," I know that it's on Windows. But I mean, I just want to emphasize that this, this is an executable,"
357660,364860," this is a native executable. So then imagine that you have a port program, right? So hello,"
365660,376940," dot port, right? So we have hello, dot port. Essentially, you give that program to the port script"
376940,385580," interpreted by the Python interpreter, right? And that entire thing turns into hello, exe, right, dot exe,"
385580,392940," the final native executable and the final native executable is a actual sequence of instructions"
392940,399660," that are executed on CPU, right? So Python interpreter is an actual sequence of instructions that actually"
399660,408540," executed on CPU, they interpret the compiler script, which takes our language source code and generates"
408540,416460," the actual sequence of instructions, like similar to how like Python exe is like a native executable,"
416460,422460," right? And at some point, right? And at some point, we'll say, okay, let's rewrite port in itself,"
422460,428620," right? Let's actually write whatever we wrote in here, but in port itself. Right? So it's going to be"
428620,438940," port dot port. So we're going to feed this thing into into port that by compiler. And that thing will produce"
439420,449580," port port port dot exe executable sequence of native instructions that functionally similar to this script"
449580,456540," interpreted by the Python interpreter. And at some point, when the implementation of port dot port is"
456540,465500," future feature full, I think this is how it's a feature full, you can just go ahead and"
466140,473500," feed the source code to itself and keep extending it like in this specific loop, you see, and once you"
473500,480620," get into this specific loop, you can just cut that connection completely, and remove all of that shit"
480620,485820," from here. Right? Well, you don't have to remove the the hello, right? So you can just remove this entire"
485820,492300," thing. And then you'll be able to compile hello with port dot port and so on and so forth. Actually,"
492860,500860," I think it has to be more like more like this. Yeah. So this is the dynamic of the of the bootstrapping"
500860,506780," of our language, right? So at some point, we're going to just get rid of this entire crap, right? Once"
506780,512860," the port, the port is capable of compiling itself right now, it is not capable. So we have to rely on"
512860,519660," the Python implementation. But at some point, we'll be able to just use it, you know, as it is. So hopefully"
519660,524860," that makes sense. Hopefully that clears up some of the questions and misconceptions and stuff like"
524860,528940," that. It's pretty straightforward process, right? Nothing particularly special."
528940,537420," Oh, didn't know that's how it's done. Well, this is how I'm doing it. I suppose different compiler"
537420,543740," developers may do that differently by the idea is pretty much this, right? But on a technical level,"
543740,549020," things may differ. It's just like for whatever language I picked and for whatever language I'm"
549020,555340," trying to develop, it's going to be like that. Right. So we'll see how it goes. We'll see how it goes."
560780,567500," So the compilation concept seems very straightforward. I was just curious about the simulation simulation"
567500,578380," also going to be rewritten import. It's the same thing, essentially. All right. So what do we need"
578380,589260," to do? Let's create a separate branch, right? Self hosted parsing, right? And first thing we need to do,"
589260,595820," we need to learn how to memory map files, right? Because I don't really know. Well, I think I did it"
595820,604300," once in port some time ago. So let's actually go ahead and try to memory map file, memory map file,"
604300,610700," how many of you know, there's a memory mapping of the file. So in Linux and in POSIX, generally,"
610700,618140," we have a Cisco called m map. And it allows you to map the memory pages. And in fact, you can map"
618140,626460," different files into the memory and also different devices well on Unix, you know, devices or files. So"
626460,631500," and this is exactly what I want to do. I want to just take the input source code, map it into the memory"
631500,638860," and just work with it. So he acts zero subscribed with tier one. Thank you so much for seven months of"
638860,649100," tier one subscription and welcome to our epic port club. So, all right, so let's go ahead and try to,"
649100,655660," to see what we can do in here. So I'm going to include STD ports. And let's provide the"
657820,664540," the file that we're trying to read as the command line arguments, right. So if the user didn't"
664540,673020," provide enough command line arguments, we're going to complain saying something like error. No input file"
673020,679500," is provided, right, I'm going to print that to the standard error and we're going to exit with non zero"
679500,684380," exit code. So that's precisely what we're going to do. Maybe it would make sense to print the usage of this"
684380,691020," entire thing. So how I'm going to print the usage. So I want to print the name of the program with the"
691020,697900," which the user called the program. So I think the easiest way to do that would be to actually get the"
697900,705260," zeros command line argument. But the problem here is that the zeros command line argument is a C string,"
705260,709820," right? So first, what we have to do, we have to convert C string to P string,"
710700,716300," right. And this thing basically converts the C string to the port string, and port string is a"
716300,721500," sized string, right? So basically, it consists of two words. The first one is the size of the string,"
721500,725100," and the second one is the pointer to the beginning of the string. So it's more of like a string view."
725100,733180," Right. And then we'll be able to print this entire thing and then continue with something like file,"
733740,738460," right. And then this is going to be a new line. And there we go. So this way, we're essentially"
738460,742620," printing the usage and failing with the error. So in here, we can do something like, okay,"
742620,749660," there we go. So let's try to compile this into I think port compile memory map file, and it in fact,"
749660,756300," successfully compiled. So and if I try to do something like this, it says no input file is provided. And it"
756300,761180," explains how you're supposed to use this entire thing. If I provide the file that we want to read,"
761180,765900," it will say, Okay, you see, so this is actually pretty straightforward. Right. So that's what our"
765900,769740," language is capable of doing. Pretty cool, huh? It's pretty cool."
769740,779420," So he does have wasm inspired type checking, we might as well go full web depth. Haha. Well,"
779420,783660," at some point, I'm going to actually implement a compilation to WebAssembly as well. So yeah."
783660,789820," But we do have like a wasm style, you know, verification and stuff like that."
791980,798060," Okay, so we need to now grab a file, maybe I'm going to do something like,"
798060,810060," so file name is puts first and our V first and third we sister to pister."
811900,816300," And then I'm going to print this entire thing. Yeah, there we go. So I just wanted to check."
816300,823660," In fact, I can recompile and run the entire thing simultaneously. So it says that it is not available."
823660,831660," And then it says the file name is this thing. Okay, so as far as I know, in the standard library, we have"
832300,840140," a wrapper around open at an open that is a Cisco which allows you to open files. And I already use"
840140,848220," this Cisco for implementing cat. And what it does it accepts, I suppose, like three arguments, actually,"
848220,857180," it may accept four of them. But we implemented only like three. So flags. If I remember correctly,"
859260,866300," flag is supposed to be what? So this is going to be flags, then we're going to have path name,"
866300,872780," then we're going to have dear FD. So relative to which directory, we're opening this entire thing,"
872780,878940," and then we call open at. So what's going to be the flags, we're going to call this entire thing with"
878940,887180," with, I think it's going to be all read the only where's read only. There we go. So all read only."
887180,893100," So the path name is going to be the, the first argument of the command line, right? So this is"
893100,900220," the first argument of the command line. And dear FD is going to be a special constant, which is called at"
900220,906380," fdcwd, which means that open the file relative to the current working directory, right? So this is"
906380,913260," basically what we're having here. And then the Cisco returns either the file descriptor of the"
913260,920380," of the file it opened or minus one indicated that it couldn't open that file, right? And we should be"
920380,926060," able to easily check that. So we can say if we're going to duplicate that thing, if this entire thing is"
926060,932380," less than zero, we want to print an error, right? So this is going to be something like error, could not"
932380,940620," open file, it puts and which file you couldn't open? Well, you couldn't open the input file. And then we"
940620,948140," want to put the new line in here and exit with non zero exit code. Right? And then we may want to"
948140,958140," print something I don't know, opened file opened file. Oh, this one is actually has to be like a sister to"
958140,967660," pster as well, we need to convert like this. Opened file. Okay, so we'll just say open file, right? I don't"
967660,977980," want to put too much too much stuff in here. Okay, so unhandled data. That's very interesting. Oh, yeah."
977980,985020," So since this thing returned the file descriptor, we only duplicated it, we didn't handle it. So we don't"
985020,989980," really need it right now. One of the things we can do, we can simply close the file descriptor, but closing"
989980,995500," file descriptor may also fail. So we have to drop that file descriptor. And now it works. As you can see,"
995500,1000860," file name is that and it opened the file. So if I try to provide a non existing file,"
1000860,1006220," it will save could not open this file. Okay, so as you can see, we can actually detect whether we managed"
1006220,1012060," to open file or didn't manage to open files. So this is actually pretty cool. We already can open files in"
1012060,1021580," this language, which is quite nice. All right. So the next thing we need to do, we need to memory map"
1022300,1028460," that file, right? And to memory map that file, we need to know its size, right? So the easiest way to"
1028460,1036380," know the to get the file size is to call something like f stat. I remember I used f stat already before"
1036380,1041100," when I was experimenting with with the language. So maybe I already have that in the standard library."
1041660,1049500," Um, actually, I don't I think I forgot to commit that shit. Um, all right, so I think we'll have to"
1049500,1056620," do that one more time. The problem with f stat, by the way, the problem with f stat is that it returns a"
1056620,1063420," bunch of information about open file, right? But it returns it into a structure. So you have to allocate a"
1063420,1069820," little bit of memory and give this Cisco the pointer to that memory, right? So that's essentially what you"
1069820,1075740," have to do. And the structure is actually quite involved. And we don't have a structure support in"
1075740,1081260," our language. So if you take a look at it, this is basically the structure. So it has a bunch of things"
1081260,1088460," in here. And the only way to access the fields of this structure in our language is to actually know the"
1088460,1097020," offsets of the fields within that structure and actually get them directly. So, um, and that's"
1097020,1101580," exactly what we need to do. So first we'll need to get those offsets."
1101580,1117180," I noticed in ports called Jen, you always just a second, you always move a racks something and only"
1117180,1123020," then push racks when I just push you word something. Okay, so let's take a look at what you're talking"
1123020,1130540," about. It's actually a very good question. So if you take a look at the push int intrinsic, right? So"
1130540,1137660," and how we compile? Yeah, there we go. So I suppose you asking why first we put into the register and"
1137660,1146540," only then we push that register. Okay, so let's actually try to replace this instruction with something"
1146540,1151820," else, right? So this is going to be right. First of all, let me run the compiler and make sure that"
1151820,1158380," all of the tests fail, test pass not fail, right? So we have a bunch of tests in here and they should"
1158380,1164300," pass. So this is like a different test cases and different features of the compiler, the compiler"
1164300,1171420," different different aspects of the compiler, right? So and let's just get rid of that and actually output"
1172220,1183660," something like push D and OP operand, right? This is basically what you mean? Why don't we just push that"
1183660,1190860," value like immediately? So okay, let's actually go ahead and try to, you know, rerun the tests and see if"
1190860,1206380," they all you know, work or not. So something didn't work. Something didn't work in a test case stack and"
1206380,1216060," we have an interesting problem. So the Nazem itself complains that signed D word immediate exceeds bounds."
1216060,1224780," So basically, you cannot push very big numbers immediately, you cannot push them immediately,"
1224780,1233020," but you can push them through an intermediate register. So that's why we do it like that. So it basically,"
1233020,1238780," I think it doesn't have full 64 beats to store immediate value that you want to push onto the stack."
1240460,1248540," So yeah, push immediate 64 doesn't exist. That's why. Yeah, so I suppose that's why."
1248540,1263100," Okay, people say put a D word. So the question is why the compiler itself didn't suggest me to do D word or"
1263100,1270220," didn't substitute it in there. Let's actually take a look."
1270220,1274540," Still complains."
1274540,1282860," Still complains about that. So here is your answer. Here is your answer. Thank you for asking this."
1284300,1293980," Okay, so let's continue. So we need to memory map this entire thing. We need to actually get the"
1293980,1301660," description of the of the stat structure, right? That's what we need in here. We need the description"
1301660,1305740," of the stat structure."
1305740,1319740," Just a second."
1329340,1335660," All right, so let's go ahead super quickly and create the C program."
1335660,1341740," Let's create the C program and within the C program, we're going to analyze all of that."
1341740,1349260," Right, so let me go to F stat. And I'm going to import this entire thing."
1356620,1361820," For himself for thank you so much for two months of tier one subscription. Thank you. Thank you. Thank"
1361820,1370860," you. And welcome to our epic course club. All right, so let me let me see. So if I take a look"
1370860,1377180," at the field, so here are the fields that we need in here, right? So here are the fields. Might as well"
1377180,1388300," actually grab the entire definition of this structure, right? Like so that's actually a pretty big definition."
1388300,1394300," I'm not sure if we'll need everything. So to be fair, we only need one offset in here, the offset in"
1394300,1402220," st size. So yeah, maybe we're not going to get all of them, but it's not really that difficult for us to"
1402220,1408300," get all of them. So might as well actually do that. So one of the things we'll need, we'll need the size"
1408300,1415100," of the of that structure, the size of a of a stat. So let's actually print it. So this is going to be"
1415100,1428140," size of stat is equal z u size of stat. There we go. So gcc all main dot c, this is going to be main,"
1428140,1438140," and we forgot to include STD out. So this is the STD out. And there we go. So the size of stat is one."
1438140,1446220," The fuck? This is because it took the size of probably of the of the function. So it has to"
1446220,1454780," be a struct stat. There we go. So the size of this entire structure is actually 144 bytes. For some"
1454780,1460620," reason. Well, it's actually pretty big structure. Well, I mean, it's it's not that big. Right. But for"
1460620,1466060," for a thing that's coming from the kernel, I think it's relatively big. Is that maybe? I don't know."
1466060,1473820," So let's go to the standard library of port and straight up yoink that definition. So that's"
1473820,1480300," precisely what I want to do. I want to yoink that definition. So I'm going to define a macro called size of"
1480300,1487100," stat. And the size of stat is going to be 144. So I can use that in memory, like layouts and whatnot."
1487100,1494780," Right, so we're going to yoink that might as well actually straight up generate the port code."
1494780,1500300," That's actually sounds like a pretty cool idea. Yeah, there we go. I'm going to be generating the"
1500300,1506860," port code. So the next thing I want to do, I want to grab all of these things and basically generate"
1506860,1513660," the macros for accessing those things too. Since Linux 2.6, the kernel supports nanosecond precision."
1513660,1520620," So I suppose our language is only going to support Linux kernels after 2.6. Does it make any sense to"
1520620,1526140," support all the kernels? What do you guys think? So I suppose we're going to have a self-hosted language"
1526140,1537100," that only works on Linux with the kernel that is newer than 2.6, right? And only on x86.64."
1537100,1547180," So yeah, I think that's a good decision. Anyways, so let's go. So I want to be able to use a little"
1547180,1555340," bit of Emacs magic to actually, you know, do all of these things. So let me quickly. This one is hard."
1555340,1562780," So I want to remove all of these comments. So to do that, I'm going to be using the rectangular selection."
1562780,1572860," Boom. So in here, we might as well just adjust those things like so, right? So here they are. And that makes"
1572860,1578780," it super easy for me to use the rectangular selection yet again, to get rid of these things."
1578780,1584060," Right? There we go. So now we have only these fields. And in C, as far as you know, there is a"
1584060,1595980," keyword of set off. So of set off. Are you going to support structs or class import? So we're going to"
1595980,1602780," have support for structs after we're done with the self hosting. So of set of essentially"
1602780,1609180," takes the type, right, and the member of a particular structure, and returns of set in bytes,"
1609180,1615100," since like starting from the beginning of that structure, right? So that's basically what it does."
1615100,1621500," And we're going to be using that to get the actual offsets. So let's actually do the following thing."
1621500,1632700," So print F. So I'm going to copy paste this into I think offset off struct struct. Right? Maybe it"
1632700,1641580," has to be something like this. Let's actually define the macro like so macro stat dot. Right. And then"
1641580,1647980," we're going to put something like ZU. And this is going to be like plus because that's how you compute"
1647980,1653420," the offset. And then we're going to have the end and the new line. And then here we're going to put offset"
1653420,1661660," off struct stat. And the member is going to be this thing. And then boom, there we go. So we have the sort of like"
1661660,1669100," accessors to two different fields of the stat structure. Though it didn't really work implicit"
1669100,1674940," declaration. Okay, so what it wanted is std def, right? So it wants std def. Otherwise, it doesn't"
1674940,1681500," know how to have offset. There we go. So now we generated the the port code that we can use in"
1682780,1689340," in our standard library. So that's actually pretty cool. So we can basically take. So maybe we should"
1689340,1696300," write a tool that takes some sort of like a C structure declaration and generates the accessors"
1696300,1706460," like this. So I don't know, is that a good idea? Maybe. So it will be also nice to know all of the"
1707180,1712460," the sizes of those fields, if you know what I'm talking about, right. So let's actually also define"
1712460,1718860," those. So somehow I'm going to copy paste this entire stuff like stuff like so like so and let's"
1718860,1726540," use a little bit of more Emacs magic. So this is going to be more of a like a size off of this entire thing."
1727100,1736380," And this is going to be like so. And here we'll have to do size off, but we'll have to take all of"
1736380,1744700," that from a specific thing. So I think we'll have to define start buff on the stack. And just do"
1744700,1749500," something like this, right? So and let's actually put it on the stack somewhere. So it's gonna be struck to"
1749500,1758860," stat, stat buff. And there we go. RDB 42 waves to all. Oh, it's gonna read it. Thank you so much"
1758860,1763500," for eight months of tier three. Holy shit. Thank you so much for tier three subscription and welcome to"
1763500,1773740," epic fourth club. Thank you. Thank you. Thank you. Hello. Hello, my comrade. Welcome."
1775580,1781340," Okay, so these are the sizes of different fields. So this is the size of the whole structure. These"
1781340,1786780," are offsets within the structure. And these are the size. And through the size, we can see what kind of"
1786780,1792940," types they are, right? So we can clearly see that ST size is eight bytes. And that means we'll have to"
1792940,1801260," read it as 64 bit word. So yeah, and we're going to actually put this into I think into the like standard"
1801260,1809660," library of of port. So every time you want to use the, you know, F stat Cisco, you can use these things"
1809660,1823340," to access the, you know, the fields of the stat structure. All right. Okay, so I'm not sure if this is"
1823340,1831420," useful, right? Because zero plus, well, things like this should be automatically optimized out, but our"
1831420,1837980," compiler doesn't have optimization yet. So and it doesn't really matter. So I mean, yeah, we can just"
1837980,1844220," keep it. So you can't go slower than Python anyway. So you can do whatever you want, even like add zeros."
1844220,1850540," So we won't be slower than Python anyway. Okay, so let's actually see if we can access all of that"
1850540,1861340," information. So let's do memory map. So we managed to open open the file. So you know what, I think I"
1861340,1867100," want to actually allocate a little bit of a space in the memory to store the file descriptor. So let's do"
1867100,1873180," something like FD memory. And there you go, here is the file descriptor. So after we confirm that the file"
1873180,1879100," descriptor is not, you know, minus one, we're going to do something like FD, and we're going to store it in"
1879100,1884780," here. So there we go, we have the file descriptor stored in the memory. So then we want to allocate"
1884780,1890460," a little bit of memory for the stat buffer. So this is going to be stat buff. And we're essentially going"
1890460,1895820," to allocate it after FD. And since the size of the D is eight bytes, we're going to do it like that. So"
1895820,1904060," here's the stat buffer. So let me take a look at the F stats. So F stat accepts two things, the pointer"
1904060,1916140," NFD. So that means the Cisco is Cisco two. So this one is going to be a macro F stat, Cs F stat, Cisco two,"
1916940,1942620," electric Google. So 64. And now, what do we want to do, we want to put the pointer to the stat buff,"
1942620,1952940," F and then the file descriptor, right? And then we call F stat, right? And if F stat returned minus one,"
1952940,1961660," that means we couldn't get the the size of the file, right? So if this entire thing is less than zero,"
1962220,1973500," then we're going to throw an error. Error could not open, could not determine the size of file. And it"
1973500,1980380," would probably make sense to also print this entire thing like so. So let me just copy paste this entire"
1980380,1987260," stuff. It puts, right, it puts one exits. There we go."
1987260,1996060," And to to do two, so could not determine the size of the file. And if we manage to determine the size of"
1996060,2005100," the file, we should be able to do something like stat buff, then we can try to exit access stat st size. And"
2005100,2011100," then we can try to read it. And after that, we're going to try to print it. Right. So after that,"
2011100,2017820," we'll print it. So and after that, we should probably close the file, right? We should close the file,"
2017820,2023340," but the operating system is going to close it for us anyway. So that should be fine. So let's try to"
2023340,2030860," recompile the entire thing. So and yeah, not enough arguments for the Cisco two, huh? I thought I"
2030860,2037340," provided Oh, yeah, you're supposed to use reading, right? You're supposed to use reading. So it's at"
2037340,2043340," 64. There we go. So it couldn't open this file because the file does not exist. Let's actually try"
2043340,2054540," to open this thing. And successfully open it. And in the ST size field of the stat structure, we have 624."
2054540,2061660," So let's take a look at the size of the file. It's 624. Look at that. So we managed to successfully"
2061660,2071900," get the size of the file using port, by the way. So we successfully got the size of the file. So we"
2071900,2076220," open it and we know its size, we know its description, we can actually access other different things,"
2076220,2081420," probably. Right. So we have an access to all of these fields, we probably won't be able to read the"
2081420,2089180," fields that have the size for because we don't have intrinsics for reading 32 bits. But once I need to"
2089180,2093900," access these things, only then I implemented, I'm trying not to implement things unless they are like"
2093900,2103740," needed. So, yep, that's pretty cool. So and knowing the size is actually quite useful, because we can"
2103740,2108540," finally use it to perform the memory mapping, right? So we can finally perform the memory mapping."
2108540,2119980," So let me let me see. So let's take a look at the map map. And it's quite a lengthy Cisco, as you can see."
2121260,2129740," So it has a six arguments are rdb 42 gifting 10 tier one subs. Holy shit. Thank you so much for so many"
2129740,2135180," tier one subs and everyone who goes to the subs. Welcome to our epic epic community. Does anyone have"
2135180,2138380," any questions maybe about what we're doing?"
2139820,2149100," Um, to to do to why not create a macro for errors? So why we can just ignore the errors? If you ignore"
2149100,2152140," the errors, you don't have to handle them. So I don't understand the question."
2152140,2160220," Uh, to do to do. So there's other questions. Can I make a website with port theoretically?"
2160940,2167900," Theoretically, you can. Um, let me actually write it, write it down. Thank you so much. Uh, I need to"
2167900,2175500," Yeah, that sounds like a critically baited title. Writing websites in my own language."
2175500,2180860," I need to write that down somewhere. I lost my pen. Just a second."
2180860,2190460," So I have that. Do anyone have any other questions while I'm writing this down?"
2191500,2197260," Uh, so I only understand 5% of everything. Don't worry about that. I only understand 5%"
2197260,2202780," of everything as well. So I don't understand shit. So don't feel bad about that. Um,"
2202780,2208780," so where is my pen?"
2216780,2223180," Uh, why are you doing less Haskell? Uh, this is because I kind of got bored of it. Um, so I don't"
2223180,2232060," really stick to a single paradigm or single language or single technology for like a very long time. I just"
2232060,2237260," learned something that catches my interest. And once I get bored of it, I just move on to something else."
2237740,2246060," Uh, so I got bored of Haskell. So yeah. So at some point I realized, oh, okay. I get the idea of Haskell,"
2246060,2251340," right? I get it. That's how you can develop things. It's one of the way to develop things."
2251340,2255340," Okay. Moving on, moving on to something else, moving on to other ways to develop things."
2255340,2265420," Um, so yeah, it's just, it is what it is. I just got bored of it. Um, web site in Porth."
2267900,2271340," So yeah. So thank you so much for suggesting this topic. I think it's going to be very interesting."
2271340,2275500," Uh, to, to, to, to, um,"
2275500,2286860," and related questions. Why not use org mode since you use Emacs? Uh, well, I mean, I'm programming in Porth,"
2286860,2293340," right? So, uh, how org mode is going to help me to program in Porth."
2294860,2304060," So, um, could you make an OS kernel in Porth? Theoretically, yes. Um, might as well write it"
2304060,2309660," down. I might, I may try to write like a simple, uh, bootloader in Porth. That would be interesting."
2309660,2321740," Um, so OS level development in Porth. So I'm going to just like write down all of the cool things that we"
2321740,2323900," may try to do in Porth at some point."
2323900,2338780," Yeah. So, uh, essentially some time ago, uh, right. I developed, uh, a game that fits into MBR 512"
2338780,2344140," bytes, uh, boot section. Uh, you can find this thing in here. I'm going to post it in the chat. And for"
2344140,2350460," people who's watching a new trip, I'm going to post it in the description. Right. Uh, boot loader game."
2350460,2357660," Right. We can try to do something like that, but in Porth. Um, and since this game was developed using"
2357660,2365340," also Nazem and the, um, the Porth compiler also uses Nazem, we can try to come up with some special mode"
2365340,2373100," that will let you compile into 16-bit real mode, uh, assembly, um, and write something in Porth."
2373100,2378060," That would be actually very interesting. Um, so maybe we're going to have like special features"
2378060,2381980," for that mode in Porth and yeah, you'll have like a proper programming language for that."
2381980,2395900," All right. Uh, thank you so much for, uh, 10 subs and let's continue. Let's continue our epic"
2395900,2401260," development of an epic programming language. Holy shit. I forgot what I was doing. I forgot what I was"
2401260,2407500," doing. Um, all right. So we know the size of this entire thing. Let's actually do a memory mapping,"
2407500,2417500," right. So this is what we want to do in here. Um, so memory map. Uh, so we usually use, uh, we usually"
2417500,2422700," push the arguments in a, in a reversed order because it's like stack based and stuff like that. So first"
2422700,2429500," one is going to be upset, uh, which I know is going to be zero. Then we have a D which I can get from the"
2429500,2436220," variable, right? So it's going to be something like this. So here's upset. Here's FD flags, flags are"
2436220,2445660," interesting, right? So, uh, flags. So for reading from file, I think we only need to map, uh, map"
2445660,2451260," private, uh, right. Create a private copy and write updates are not visible to other processes with the"
2451260,2460620," same file. So yeah, this is what we're going to have in here. Uh, map private, uh, right. So protection"
2460620,2465660," level, all right. For the protection level, I think we're going to only need, uh, something like, uh,"
2465660,2471100," prot read, right? Because we're not going to modify the, the file. We only need to read the file."
2471100,2478060," So this is prot, uh, the length length. We know the length. Uh, it's basically, uh, this thing. So here's"
2478060,2483340," the length. Uh, we can grab it from the, uh, from the stand buffer. So this is the length."
2484940,2492380," And the address, the address is basically a hint for the kernel where to place the, uh, the mapped"
2492380,2498220," memory. So if you put new in there, that means you allow the kernel to just choose the place for you."
2498780,2502860," Right. And do we have like a macro funnel? Uh, I don't quite remember. Yeah, we do have a"
2502860,2508700," macro funnel. That's nice. Okay. So, and let's perform the map call. Right. And as far as I know,"
2508700,2515420," this entire thing will return you the pointer or it will return an error like minus one if it couldn't"
2515420,2522540," memory map anything. So, uh, let's allocate a little bit of memory for the pointer, um, of the content of"
2522540,2530060," the file. Right. So let's create content, uh, and it's going to go after stat buff, uh, stat buff."
2530060,2535660," So we'll have to do something like size of stat plus, right. And this is precisely why we need to"
2535660,2541500," know the size of the structure so we can allocate more things after that structure. Uh, right. So that"
2541500,2548860," allows us to do this thing and, uh, let's right away, uh, save everything in here. So we called the, uh,"
2548860,2555180," a map and we just save this thing in here right away. So, and as far as I know, you have to do it like"
2555180,2563180," that. Right. Uh, if the content, uh, if the content less than zero, that means the, we couldn't map the"
2563180,2571740," memory file. Right. So let's report an error saying precisely that, um, could not determine the size of"
2571740,2580140," the file could not, uh, memory map file this, and then, uh, we're going to do something like this."
2580140,2586140," So after that, I think we could try to print the pointer to the mapped memory just to see if we actually"
2586140,2591740," got something, um, right. And let's just try to compile the entire thing and see if it worked unknown"
2591740,2599180," word. Oh yeah, we don't, we don't have that in the standard library yet. Okay. Uh, so basically I'm,"
2599180,2606620," I'm slowly re-implementing, uh, Leap C as I go, right. The more features I need from Leap C,"
2606620,2613660," uh, I just implement them. So the question is what is map private? Uh, that's a very good question. Uh,"
2613660,2623180," can we just go to a man dot H and find a private or something like that, or at least just like find a map"
2623180,2630620," map private. Uh, it's not located in here. Maybe it's located somewhere in here. Okay. So it's"
2630620,2638460," defined in a man, uh, Linux and it's actually two. Okay. So that's fine. Um, right. So this is more of a,"
2638460,2648460," like a two. Okay. So let's go and recompile this thing one more time. Prot read. Okay. So we also need to"
2648460,2660380," define prot read. Uh, what is prot read? Uh, so do we have, uh, prot read defined? Okay. So it's actually"
2660380,2668780," one, which is nice. Okay. Uh, anything else? And we don't have a map. Okay. So we need to wrap the"
2668780,2675980," M map, uh, C school, where are the C schools? I didn't see the C schools. Here they are. So macro"
2675980,2682540," M map, uh, C's M map. And as far as you know, C school has a six arguments, if I'm not mistaken,"
2682540,2689340," right? Uh, one, two, three, four, five, six. Okay. So it has six arguments. So it's going to be C school"
2689340,2694460," six. Uh, yeah, the first C school with the six command line arguments. How about that?"
2696220,2703420," How about that? How about that? Okay. So this does this look like a pointer? I think it does look"
2703420,2710620," like a pointer. Uh, if we take a look at like hex of this thing, uh, does this look like a point? Yeah,"
2710620,2715820," it actually does look like a pointer to be fair. Like it's, it's within like the usual and it's usually"
2715820,2723820," within like the same range. Okay. So that's cool. So maybe we can try to print, uh, the string that we"
2723820,2732380," got, uh, from the file. So that will be interesting. Um, okay. So I'm pushing. Oh, by the way,"
2732380,2743100," puts expects two things on the stack, right? It expects two things in the stack, the size of the string"
2743100,2748780," and the pointer to the beginning of the string, the size of the string is located in stats, right?"
2748780,2755420," So I can literally do that. And the beginning is located in contents. So by doing these two lines,"
2755420,2762700," I already have everything to give to the puts, uh, Lavev seven. I hope I knows your name correctly."
2762700,2768300," Uh, thank you so much for gifting tier one sub to the design community. And they lean zero or welcome to the"
2768300,2776700," Epic Ports Club. How about that? Cheers, by the way. Hmm. So essentially this should be enough to print the"
2776700,2785260," contents of the file. I hope, uh, we'll see how it goes. And there we go. So we implemented another cat,"
2785260,2794060," essentially. That's pretty cool. We actually implemented another cat, uh, by memory mapping the file. So,"
2794780,2801100," yep, that's pretty cool. So we, we can now read the whole file into memory. Uh, we're able to read the"
2801100,2807100," whole file into memory and that's actually really useful because it's, it's a first step in actually"
2807100,2813260," parsing the source code. You can't parse the source code if you can't read the entire file into memory,"
2813260,2821260," right? So like, you just, you just can't. Uh, so, and we're already a little bit closer to actually,"
2821260,2827420," you know, unhardcoding the, um, the program within the compiler. So the next thing we need to do, we"
2827420,2835980," probably need to split, uh, this entire thing into, uh, into lines, right? And, uh, I think we'll need to"
2835980,2843100," introduce a bunch of macros and a bunch of data structures to, um, to, uh, uh, efficient, effectively,"
2843100,2856300," to effectively do that. Mm-hmm. Hmm. So, all right. So what I want to introduce, I want to introduce a"
2856300,2862620," structure that is similar to the string view that I constantly use in my C programs, right? In my C"
2862620,2868620," programs, quite often, if I need to parse something, uh, I tend to use this library that I developed myself,"
2869820,2876140," um, which is called SV stands for string view and string view is essentially a very simple structure"
2876140,2881020," that has, uh, the amount of characters in the string and the pointer to the beginning of the"
2881020,2887740," string in the memory. And this library has a lot of different operations for, um, slicing and parsing"
2887740,2895740," these string views, right? So, uh, it allows you to chop by a particular delimiter, um, just trim and all"
2895740,2900060," all sorts of things. Check if the, if it starts with a particular prefix, if it ends with a particular"
2900060,2906860," suffix. And, uh, that allows you to do quite a, like a huge range of different parsing things. Um,"
2906860,2911500," I'm going to put this thing, uh, in the description for people in the chat, I'm going to put it in the chat."
2911500,2916540," So, and for people on, uh, on YouTube, I'm going to put it in here."
2917740,2927580," String, uh, view library in C. So I want to use a similar approach, but in port, right? Because this"
2927580,2932860," approach, at least for me was, um, proven to be quite effective when you need to parse something."
2932860,2939100," So, uh, I'm going to go ahead and just like define that structure, but inside of port. And the way we"
2939100,2946380," define structures is of course by a bunch of macros. So let's actually introduce maybe like a string view"
2946380,2952620," or something. To be fair, I think I'm going to just call it string, because if you think about it,"
2952620,2961420," strings in port are already sized. So essentially, if you do something like hello world, this token"
2961420,2968540," pushes the size of the string and the pointer to the beginning of the string on the stack. So this"
2969100,2976860," is already string view effectively. So it basically we can call string views the strings of port,"
2976860,2983340," right? So I'm going to call it, uh, basically str. So I'm going to find a macro size of str. And since"
2983340,2988860," we have the amount of characters and pointer to the beginning, each of them are eight bytes. The size of"
2988860,2994780," the whole structure is going to be 16 bytes. Uh, there we go. So we need to also have different accessors."
2994780,3000700," So the first one is going to be count and, uh, count is going to be at the beginning of the structure."
3000700,3004700," So we're not going to add anything, or maybe I'm going to actually do like zero plus to emphasize"
3004700,3011180," that this is, this is an accessor. And then we can have a, uh, data, which is, uh, basically has a set"
3011180,3016940," of eight. Uh, there we go. So we basically define the structure. So this is how we define structures in"
3016940,3023180," port. So, which leads me to think, do we really need like a proper support for structures? I'm not even sure."
3024460,3029260," So Margie Dano subscribed with tier one subscription, your first subscription, by the"
3029260,3035660," way, thank you so much and welcome to our epic port club. How about that? Uh, so yeah, cheers."
3035660,3049900," How do you code without autocomplete? I do have autocomplete look. So I start to type ma and it just like"
3049900,3053980," and it autocompleted it. So I do have autocomplete. It's just like very,"
3053980,3064700," very, very fast. Uh, all right. So, um, I suppose one of the things that I want to do in here is maybe"
3064700,3075260," make the content str. Yeah, that sounds interesting. So what if the content is not going to be just a"
3075260,3083660," pointer to the string? What if it's going to be the str? Hmm. That is very, very interesting. All right."
3083660,3089340," So after we read the size of the file, right? After we read the size of the file,"
3089340,3097900," uh, what do we do with it? Uh, we can try to save it to the content. So first I do content, then str count."
3099100,3112620," Um, right. Uh, so maybe I need to do stat buff st, uh, stat st size and I read the value and then I write"
3112620,3121020," it into the content count like so. So you see this reads, uh, the field st size from stat buffer and then"
3121020,3128460," writes it into the field count of the content, right? So that's basically what it means. Um, okay. So, and then next, uh,"
3128460,3135340," we can do things like this, right? Uh, we can do things like this. There we go. So this is going"
3135340,3143180," to be the length and then we're saving this entire thing into a str data, right? We're saving this stuff"
3143180,3151740," in str data. Uh, okay. And then I get that str data and I read from it and then we're trying to print this"
3151740,3167500," entire thing. Hmm. So I'm thinking what if we also had a very interesting macro like at str and what it"
3167500,3177180," will do, it will accept the pointer to str and it will push both the count and the data on the stack. So you"
3177180,3184220," can just print the size string, basically print the string view. That's actually pretty cool. I really"
3184220,3190380," like that. So imagine that you have this on the stack, like a, like a pointer, uh, right. And essentially"
3190380,3196940," what you need to do, uh, we need to maybe duplicate that pointer. So we're duplicating it. Um, and then the"
3196940,3201820," the first thing I want to do, I probably want to read the count. So it's going to be str count. Uh, right."
3201820,3207820," So this is going to be the count and then I read it. Uh, so this is going to be 64. There we go. So after"
3207820,3214780," that, I want to swap it. So the count comes first. And after that I need to get the data and read it again."
3214780,3221660," And there you go, I have the data. So essentially we had, uh, the string view on the, in the memory"
3221660,3229020," and we pushed it into the stack in a form that is suitable to be, uh, passed to puts. That is actually,"
3229020,3234780," so essentially pushing the structure into the stack. Yeah. We're deconstructing the structure on the stack."
3234780,3238300," That's basically what we're doing. Holy shit. This gives me a lot of interesting ideas."
3239900,3246220," So what's funny is that I don't really even need like a proper support for structures in the language."
3246220,3254700," I can simulate them quite effectively effectively with just macros. Uh, and yeah, I'm actually surprised"
3254700,3262780," how powerful macros are. Uh, so yeah, of course it would be nice if the structure definition was part"
3262780,3269260," of the type checking, right? It would be kind of cool. And I think for that we need to have a special"
3269260,3275580," language support, but, uh, for just accessing stuff in the structures, it's not really that much needed."
3275580,3293180," I think. Hmm. All right. Hmm. All right. So, um, and what I want to try now, right? So essentially content,"
3294620,3300700," right. Content is a pointer to, uh, the string view, right? It's a pointer to the, to the string view."
3300700,3307820," And, uh, I just read it as a string and then it, uh, do puts and that should automatically just,"
3307820,3313100," uh, you know, write that string into the memory, right? So it should allow me to do that. And it works"
3313100,3321740," actually, it actually freaking works. That's fucking cool. That's freaking cool."
3321740,3331260," Um, so the next thing I want to be able to do, uh, I want to be able to split a string, uh,"
3331260,3338700," by L by a new line, right? So, because I need to be able to split this stuff, uh, by new line. So, um,"
3339820,3347100," that would be a rather interesting. Uh, so let me think, let's do macro chop, uh,"
3347100,3352780," chop line, right? So this is going to be chop line. And what this entire thing is going to accept"
3352780,3359820," um, string view in port payment. Yeah. Yeah. So basically doing string view in port."
3360460,3377500," Um, okay. Here it puts, uh, to do not implemented. It puts one exit. So I need to test this entire stuff,"
3377500,3383740," right? So we need to think about how we're going to even do this thing. Uh, so what's going to be the"
3383740,3391340," input and what's going to be the output? Uh, I think we can basically accept two pointers. So the first"
3391340,3399980," pointer is the pointer to the string into which goes the line. And the second pointer is the input"
3399980,3405260," pointer from which we're chopping the line. So we accept only two arguments in here. And essentially,"
3405260,3412060," this macro is going to just read stuff from here and construct, uh, stuff in here. And then you can"
3412060,3418620," just use this line for whatever processing you want. So that's, that was reasonable, I guess."
3418620,3425580," Um, so, and to do that, we probably need to allocate, uh, you know, that line somewhere in memory. So let's"
3425580,3433100," define line and it's going to come after the content. And, uh, we're going to add size of str. There we go."
3433100,3439820," So maybe I'm going to put the definition here. Uh, yeah. So, and what's funny is that this is the"
3439820,3449100," definition of the structure. Uh, and that definition is not that much bigger. If we had, uh, direct"
3449100,3452780," support for the structures in the language, we don't have a support for the structures, but you can kind"
3452780,3458300," of emulate them and, uh, it doesn't really require too much code, but you have to work with specific"
3458300,3462460," numbers in here, which is error prone, of course. But I mean, for now, I think it's fine."
3463100,3475980," Uh, is it allowed to define, uh, macros and macros? Yes, it is allowed. Um, I didn't forbid that"
3475980,3485100," explicitly. And to be fair, I have, I don't know any implications of that. Uh, I don't have a use case"
3485100,3491820," for defining new macros within the macros. Um, but I didn't explicitly forbid that either. So maybe somebody"
3491820,3496460," will find a use case for that. Um, at some point I can't think of one right now, maybe later."
3501420,3509100," So essentially what you can do right now in here is something like macro fool, uh, 69, right? And"
3509100,3518460," basically that will not define fool unless you use str somewhere. So, and that theoretically should work."
3518460,3522940," Uh, that theoretically should work. Let's actually take a look at this kind of stuff. So you won't be"
3522940,3528940," able to include that str twice because you will be redefining fool, but you can include once at least,"
3528940,3535580," which is maybe you can find a use case for that, uh, for something. I don't know. Uh, but, uh,"
3535580,3541660," macro fool, right? So we have macro fool, uh, which says fool and brings that to the standard like output or"
3541660,3549500," whatnot. So, and I'm going to include, uh, the standard library just in case, just to see, uh, just to be"
3549500,3557260," able to be able to do puts and let's do fourth by compile a run for fourth. Uh, there we go. So index"
3557260,3565980," out of range. Uh, and I wonder what the hell has happened. We found a bug. Yes. Yes. Yes. Yes. Look away"
3565980,3574220," freaking this. So that's very freaking interesting. Um, so we have a city. So yeah, we literally found a bug."
3574220,3583340," So if I put something like test, uh, puts, yeah, now it works. Okay. So there's some sort of a bug in"
3583340,3590300," type checking, uh, which is actually rather cool. So I'm going to actually like put that, uh, other to do."
3590300,3596620," Uh, so that's actually, thank you for, for asking that we, we found a bug while testing this entire thing."
3597340,3605100," So, uh, type checking, uh, fails on code, uh, that looks like this, right? So this is going to be like"
3605100,3611500," that and I'm going to fix that a little bit later. So for now we have a workaround, uh, right. So I"
3611500,3617420," probably forgot to just check for something like, so obviously IP went out of the range and I don't check"
3617420,3624460," for IP getting out of the range in here. So obviously I need to do that. Um, we'll see how to do that."
3624460,3632060," Uh, because of the known instruction. Oh yeah. So maybe just empty file, right? So let's actually"
3632060,3640380," try to do something like empty, uh, empty port. Uh, yeah. Why did you create a folder empty? Maybe I can"
3640380,3648140," do touch empty port, right? There we go. And then if I try to compile empty port, yeah, it's the same."
3648140,3654620," Thank you. Thank you so much. Okay. So we caught an error. Type checking, uh, fails on empty programs,"
3654620,3663740," right? So we have a smaller example to reproduce now. Okay. Um, so let's take a look at this stuff. Uh, right."
3665660,3672460," So as you can see, uh, yeah, uh, you don't have foo because you never use it. If I do foo,"
3672460,3677340," it will print test foo. We might as well actually put new lines in here just to separate these things."
3677340,3684700," Cool. So you can define a macro within the macro definition, right? So this is going to be bar,"
3684700,3691180," uh, at least theoretically. I haven't tried that yet, but theoretically you can do that, right? So it prints"
3691180,3697820," test foo and after that you will be able to use bar, right? Test foo bar. But as soon as you remove foo"
3697820,3703580," and you don't use it anywhere, it will say that bar is a known word, right? So essentially it only"
3703580,3709500," included the definition of bar after it's included foo. And furthermore, if you try to include foo twice,"
3709500,3715580," it will say that you are redefining bar and the previous definition is, uh, located in here. That's"
3715580,3721420," actually quite funny, right? So redefinition of bar and the previous definition is located in exactly"
3721420,3728460," the same place. So that's what compiler says in here. So again, I have no idea what you can use it for,"
3728460,3734620," but you can do this. If you can find a use case for that, well, all props to you. Uh, but like"
3734620,3741020," forbidding doing that, it just like takes more effort than just allowing that. So, uh, that's why it's"
3741020,3752940," allowed. Our macros have equivalent of functions. No, they're not. They're literally copy paste their"
3752940,3762460," body into where you use them. Because it was easy to implement. So, all right, hopefully that makes sense."
3763340,3766940," And we also found a bug in the type checking, which is kind of cool."
3766940,3777340," I could use a use case where you use a different macro in bar and redefine that we don't have"
3777340,3783660," redefinition of bar like of macros. If we implement redefinition of macros, maybe that feature will become"
3783660,3788300," useful. Until then, I don't think it's useful because you cannot redefine macro right now."
3789740,3795420," So, and the redefinition of macros might be useful, right? At least undefining macros, right?"
3795420,3802300," That will be interesting. But it's not a priority right now. So what is priority right now is to"
3802300,3810780," split a file by new line, right? That's what the, what's the priority. So we need to implement a chop line."
3810780,3819020," Okay. So how are we going to be doing all of this stuff? I suppose when, okay, so here is the line. So,"
3819020,3827660," hello world, new line, full bar, and there we go. So when you chop in the line, the line actually will"
3827660,3836060," start at the same place where input starts, right? So here's the idea. I'm going to initialize the line"
3836060,3843340," with the data equal to whatever we have in the input, but with the count zero, right? The count is going"
3843340,3850460," to be zero. So it's going to be like this. We're going to be iterating over input. And while we're"
3850460,3856540," iterating over input, we're going to be incrementing the count of line. And as soon as we encounter new"
3856540,3864140," line, we stop. And inside of the line string, we're going to have the line, right? So this is how we're"
3864140,3870940," going to chop the line. Right? So that's actually I think should work at least this. I think this is how"
3870940,3876940," we do that in string view. I don't quite remember actually. So"
3880780,3887420," did you already mention why you switched to GitLab? If not, can you quickly go over the reasons? So"
3887420,3895260," the reason why I switched to GitLab is because GitLab is obviously better than GitHub, right? So if you open"
3895260,3905180," GitLab and GitHub side by side, right? So this is how GitLab looks like. Look at how good it looks, right? So it"
3905180,3910140," suggests you to customize this page, which is beautiful. GitHub doesn't suggest me to customize"
3910140,3918860," anything. Also, it suggests me a free trial gitlab.com ultimate. Does GitHub have a free trial"
3918860,3927740," of gitlab.com ultimate? Does it? Also, look at the buttons. Look at the buttons. They are like,"
3927740,3934540," they're rounded a little bit. But they're not as rounded as the GitHub buttons. Look at what the"
3934540,3941340," fuck. That trend is already gone. Seriously. And look, also look at that. What the hell is this?"
3941340,3953340," Is this an iframe? Wait, iframe in 2021? What is this, 2005? I've been developing shit like that when"
3953340,3960380," I was in school. Like, dude, who fucking uses that in 2021? Holy shit. So..."
3963900,3969420," There you go. The choice is obvious. The choice is fucking obvious."
3969420,3975100," All right. So let's implement your plan."
3986380,3992060," All right. So we have a line here. All right. So let me let me see."
3992060,3995180," Line input."
3995180,4004780," How are we gonna be doing all over that? So I need to probably initialize this thing. So I'm gonna do to"
4004780,4011660," dupe. That will copy both of these things on the stack. Right? Then"
4011660,4016060," I'm going to maybe"
4016060,4019420," get the"
4019420,4029340," get the data. So this is gonna be str data, right? So that gives me that. And then I'm reading that data."
4029340,4035900," There we go. Boom. We're reading that. Then I want to swap to bring to bring the line"
4035900,4043340," in front. Right? So there you go. Then I'm gonna take the data from the line. So here's the data."
4043340,4050460," And I'm gonna save the contents of the data for the input into here. Right? So effectively, what I'm doing"
4050460,4058380," in here is just like, I'm doing this thing. Right? So this is the operation that I did with this single"
4058380,4067020," line. Right? There we go. So and the next thing I probably need to do now I need to set count to zero"
4067020,4074620," as well. So I'm going to do over, which will copy the line in here, right? So this is going to be over,"
4074620,4082300," then I will need to take the count. Right? So this is the count. I'm going to set the zero. It will set"
4082300,4086940," it in here, but it has to be on the other side. So it's going to be like that in here. And then I'm"
4086940,4092300," going to do 64. There we go. So we initialized everything. So effectively, what we did in here"
4092300,4100620," with this line, we set line data equal input data. That's literally what we did. And with the second line,"
4100620,4107820," we did count equal zero. Right? So this is the second line. And to be fair, this is like a C equivalent."
4107820,4113980," And this is the port equivalent. And port equivalent is just like only a little bit, you know, longer."
4113980,4120380," But it's not like magnitude longer. Right? It's just the same amount of complexity, I think. So it's just"
4120380,4130860," like two things in here. Yeah, pretty much a good thing. So maybe we could also test this entire stuff."
4130860,4138380," So here's the contents. I can do line, content, chop line. And after that, I can take the line"
4138380,4148140," and just try to print. There we go. So if I go and do memory map worth and handle data on the stack. So"
4148140,4156220," it comes from the content. Oh, okay. So I suppose we forgot to actually, you know, get rid of that data"
4156220,4162460," afterwards, we have to do two drop to get rid of the line and input. There we go. So we didn't provide"
4162460,4168940," this entire thing. And this is going to be memory.port. And it didn't print anything because line right"
4168940,4174140," now is supposed to be empty because we explicitly set it to zero. But what if we explicitly set it to"
4174140,4182540," five? Will we see anything? And there we go, we have include. And this is precisely first five characters"
4182540,4189580," of the first line. So we are on the right track. Isn't that POG? Isn't that POG? I think that's pretty"
4189580,4197420," freaking POG. So yeah, let's go ahead and just organize some sort of a loop. So and how we're"
4197420,4206700," going to organize the loop. We're going to loop until input has like anything in it, right? And"
4206700,4213420," the current character of input is not equal to new line, right? And as soon as it's equal to new line,"
4213420,4218300," we have to actually stop everything and just like, you know, return from the user. So"
4219260,4224220," input, I need to duplicate the input. So I'm going to just put the copy in here."
4224220,4230940," So here's the input. And I want to take the count of that thing, right? So this is going to be the"
4230940,4239660," count. And then I need to read the value of this thing. Yeah, there we go. So we read the count. While"
4239660,4248700," count is greater than zero, we now need to check, we now need to check if the first character of the input is"
4248700,4253020," not new line. And it would be nice to have some sort of like a short circuited,"
4253020,4260940," you know, and but we don't have a short circuited end. So the best thing we can have is actually have"
4260940,4268380," two nested ifs, right? So if this thing is true, then we can try to get the first character of the input"
4268380,4277580," and just check it. Right. Otherwise, I think this has to be false. There we go. So yeah, by the way,"
4277580,4283500," this is the condition of while. Since this is a concatenative language and condition can be any"
4283500,4288620," sequence of operations, you can have ifs inside of condition for while. And as a matter of fact,"
4288620,4296140," you can have nested while inside of the condition that checks for another while. So it is possible in"
4296140,4301500," the concatenative language that we're developing like it's you can do that. So which is actually"
4301500,4304380," mind blowing. But once you get used to it, it's actually pretty cool."
4304380,4318300," So use use use. How are you freaking this? Then we actually kind of cool to find a use case for while"
4318300,4324140," inside of the condition of another while. But they haven't found a use case yet. But I know a use case"
4324140,4331420," for if inside of the while, it's usually needed for, you know, for short circuited ends and ors and stuff"
4331420,4340060," like that. Okay, so here I want to duplicate the input yet again. Right. So this gives me yet another"
4340060,4346380," input. But this time, I'm going to take the data of the input. Right. So this is the data. And then I"
4346380,4352620," read it. So in the data, I have a pointer. So we'll have to cast this entire thing to a pointer. So I have"
4352620,4358940," this stuff. And, you know, read by default interpreted as an integer. So we have to kind of like force it"
4358940,4367340," to be cast into the pointer. And after that, I need to read a single character, right? So I'm going to read"
4367340,4375420," it like that. There we go. So now we have a single character. And if the character, right, if the character"
4375420,4382140," not equal to a new line, we're going to continue like developing this thing. So this thing will become"
4382140,4388300," a condition that will go into the do. There we go. So this is basically what we're doing here."
4388300,4396700," Right. It's pretty cool. So we checked while we have something inside of the input and the first character"
4396700,4401900," is not equal to a new line. You know, we have to keep iterating and how we're going to be iterating."
4401900,4408380," First, we need to shrink input by one character. Right. So that's, that's the thing we need to do. I'm going to"
4408380,4413820," duplicate the input. Right. So that gives me the input and to shrink it, I need to decrease its count."
4413820,4421660," Right. So I need to take STR count. Right. Here's the count. And I'm going to be doing deck 64. Right."
4421660,4427900," So this is a deck 64. And that basically decremented the count. So then I need to dupe this thing again,"
4427900,4435660," and I need to take its data. And data is a pointer to the beginning. Right. And I need to increment it"
4435660,4445660," by 64. Right. I'm incrementing it by 64. There we go. So after that, I need to increment the counter of the line. So to do that, I need to swap,"
4445660,4465180," swap, swap, dupe, swap dupe, str count, increment 64, and swap this entire thing back. Right. And there we go. Now we have a loop. Now we have a loop,"
4465180,4473420," a loop, which actually tries to chop a single line. Let's see if we succeed it or not, chat."
4473420,4480780," So after the while loop, I suppose we have two pointers on the stack. Right, we have two pointers"
4480780,4485660," in the stack, and the result is going to be actually no pointers. So we need to drop both of them. So there"
4485660,4494140," we go. We implemented chop line. So that chops the string that we wrote, that we read, not wrote. It"
4494140,4500780," basically chopped the line out of it. All right, so let's take a look. It kind of worked. But it actually"
4500780,4509980," put a Mac in here. And I know why. I think I know why. Because we made a huge mistake. We initially we"
4509980,4519340," forgot to initialize this thing with zero. Right. So yeah, there we go. So as you can see, we got the"
4519340,4529180," first line of the file. We got the first line of the file. Isn't that Pogue? Yep."
4531260,4539260," So what's interesting is that right now the input, the input points to a new line. It points to a new"
4539260,4546380," line. And we need to get rid of that new line completely. So I suppose after the loop, we want"
4546380,4551740," to check something. So here's the line. And here's the input. We need to check if"
4554460,4562460," the input is greater than zero. We need to decrement that input yet again, like additional iteration."
4562460,4569900," And we don't need to increment the the other thing, I suppose. Right. So this is going to be like a one"
4569900,4578060," one time thing. All right. Seems to be working. Okay. So this will enable us to actually iterate over"
4578060,4586620," each individual line of the file. Look, so this is going to be very interesting. So while content,"
4586620,4596940," str count is greater than zero, what do we do? We chop a line from the content, we chop a line from the"
4596940,4604540," content. And then we simply print that line. But printing that line will produce the output that is not"
4604540,4612060," distinguishable from from just, you know, printing everything, let's actually surround the lines with"
4612060,4618300," something to indicate that we actually parsed the line. So let's actually put something like bar in"
4618300,4625500," front of the line and bar at the end of the line. And also separated by new lines. You see, you can't"
4625500,4630940," surround the new of the each individual line of the file if you didn't actually figure out the edges of the"
4630940,4636700," lines. And like properly parsed it. So let's take a look if we manage to do that. There we go."
4636700,4646540," We are capable of iterating text file line by line in port. And that's how easy it is. So we have a"
4646540,4652700," content as a string. While this size of the string is greater than zero, you chop a single line out of"
4652700,4658140," that content. And you just print that line. So yeah, that's how easy it is. It's just like literally four"
4658140,4665660," lines and all of the heavy work is stuck under the chop line macro. And this language doesn't"
4665660,4672540," even have a support for structures. Think about that. It doesn't even have a support for structures."
4672540,4682460," like this is how we do that. It's just like the more I develop forth, to be fair, the more I develop forth,"
4682460,4688460," the more I'm starting to think that people overcomplicate languages. Well, I mean, it's this is"
4688460,4696220," not a good language by any means. But it's not as hard to program in as people would probably claim because"
4696220,4702860," of the lack of all of these features they got used to. Right? So it's just like, it's not super"
4702860,4709980," cool experience, but it's not absolutely horrible. It's not like it's easier than programming in"
4709980,4714860," brainfuck. And it's definitely easier than programming programming directly in assembly."
4714860,4721420," So that's what's interesting about it. So I would say that convenience of this language is between"
4721420,4729740," assembly and C. So it's more convenient than directly assembly and a little bit less convenient than C."
4729740,4735900," But I think we can push the convenience of the language over the convenience and C once we start"
4735900,4742780," working on working on some, you know, some good features, I think. So I don't want to introduce too"
4742780,4748540," many features before I made the compiler self-hosted. Right? Because again, if I introduce too many"
4748540,4752860," features, it will be difficult to reimplement the compiler in itself. Right? And I want to just keep"
4752860,4761100," things easy for me. Is it more or less convenient than 4th77? I have no idea. I've never programmed in 4th."
4762300,4767660," Oh, you mean Fortran. Same thing. I never programmed in Fortran. So"
4767660,4779500," All right, so that's pretty cool. So we're really can we can even write a program that counts the amount"
4779500,4784300," of lines, though, to count the amount of lines, we don't need string views, you can just load the"
4785180,4792060," file into memory and count the new lines characters, you don't need to split anything. But yeah."
4792060,4806220," Okay, so what I'm thinking is that now we want to split things word by word. But to be able to split"
4806220,4814380," things by word, I need to be able to trim leading white spaces. You see? So we need a way to trim"
4814380,4820780," this stuff. So we can find the next space and we can drop off like a single word from this entire stuff."
4820780,4829420," Once we will be able to split everything by words, we're pretty much good to go. And we can unhardcode"
4829420,4837100," the programs from the compiler itself. So yeah. Okay, so let me see. Can we just do something like,"
4837740,4849580," let's implement macro trim left, right? So you will accept this thing. And essentially, this thing will"
4849580,4856460," shrink the string, while it starts with space. It's as simple as that."
4859580,4866460," To be fair, I'm going to keep repeating like this sort of operation over and over again. And it feels"
4866460,4875420," like maybe it deserves its own macro. I'll think about that. Okay, so here we have an input. And while"
4875420,4882060," yet again, so we can use the same thing in here, actually, right? While"
4883580,4891180," it's its size greater than zero and its starting character is equal to the space,"
4891180,4897980," all right, we're gonna keep shrinking this thing, right? We keep shrinking it."
4902940,4912780," And that's it, actually. I think that is it. So yeah, while it starts with space, just shrink it by one"
4912780,4922700," character. Okay, so and then we can drop this entire thing. So all right, we read the line. And then we can"
4922700,4930460," do line trim left, right? So we chop the line, we trimmed it. And now we can try to read it. Okay, so"
4931100,4936620," here's how the source code looks like right now. This is how it looks like now with all of the"
4936620,4942140," leading whitespaces trimmed, trimmed rather, rather trimmed. So"
4942140,4946140," yep, that was easy."
4946140,4957900," And yeah, we're starting to repeat this pattern over and over again. So maybe we can do something like str"
4957900,4964860," shrink, right? And essentially, we can just do something like this, right? So in here,"
4964860,4974460," so what we accept in here is like a single str, right? And we duplicate it. And since I suppose this"
4974460,4981260," macro is going to be consuming this thing, we need to drop it afterwards. Right shrinks str shrink,"
4981260,4991500," maybe it's going to be shrink str. Right? So and in here, we can also, you know, we can talk this thing"
4991500,4997420," under a macro as well. Yeah, that would be actually kind of cool. Okay, so here we're going to do dupe"
4997420,5008140," shrink str. So this is the first shrink str. This is the second shrink str, dupe shrink str. And this is"
5008140,5015660," another one, right? So this is actually quite common, you know, instruction, quite common set of operations."
5015660,5021660," So it makes sense to sort of like extract it to this thing. And it seems to be working, though. And now we"
5021660,5028780," can actually extract this stuff into its own macro and maybe customize the character, though, I'm not really"
5028780,5035660," sure about the character, because sometimes it's equal or not equal. So yeah, I'm not sure."
5035660,5044220," I'm not really sure. I'm not really sure. But I think it's fine for now. So one of the things I"
5044220,5049900," want to be able to do, I want to be able to chop a word. And what's funny is that chopping a word,"
5051100,5057820," chopping a word is the same as chopping a line. But instead of new line, you use space."
5057820,5067740," So it would be nice to actually refactor this macro to accept three arguments in here,"
5067740,5073660," line input and the character, right? Line input and the character."
5075180,5081500," So yeah, but I'm not going to do that right now. So maybe I'm going to do the following thing."
5081500,5093260," Chop word to do merge chop word and chop line into a single macro. There we go."
5098140,5105020," So whatever we need to do, whatever we need to do, whatever we need to do, whatever we need to do,"
5105020,5109340," whatever we need to do, I want you to allocate some space for the word, right? So this is going"
5109340,5117420," to be word and it comes after the line. There we go. So there we go. And the way we're going to do that."
5117420,5123260," Okay, so while content is not empty, we chop a line. While line"
5125660,5138620," is not empty, we trim the line, we trim the line and we chop the word. And we're printing that word."
5138620,5145980," There we go. So we're iterating over each individual line and within the line we're iterating over each"
5145980,5153980," individual word. Also trimming all the white spaces. And will that work? It fucking worked."
5155660,5171020," there we go. Entirely imports. Entirely imports. Entirely."
