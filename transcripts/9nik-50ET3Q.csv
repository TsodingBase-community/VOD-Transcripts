start,end,text
0,12960," All right, looks like we're live. Hello, and welcome to another Zozin session. How about that?"
12960,20240," How about that? I bet you didn't expect that shit to happen. So let's make a little bit of an"
20240,33200," announcement as usual and post a message on our Discord server. So red circle live on Twitch."
33200,39200," And today we're doing functional programming. That's what we're doing today. So I need to also"
39200,45680," give the link to the Twitch channel. So it's going to be twitch.tv/todding. And we're going to ping"
45680,54960," everyone, everyone is binked. Everyone is binked. So hello, hello, chat. Hello, Demki. Hello to the"
54960,62320," prime. Hello, hello. Welcome, welcome, welcome. So what are we doing today? Today we are solving 99"
62320,70080," OCaml problem or 99 problems on the camel. So basically, this is a set of problems like 99 problems,"
71120,79600," which is inspired by 99 lisp problems, which in turn was inspired by a prologue problem at least."
79600,86400," So essentially, it's more of like a challenge, right? So if you are learning a camel, you can basically"
86400,94720," practice your camel skills in the like using this set of problems. Some time ago, I think, like, I don't"
94720,100080," know, I think I was not already a student, I think I graduated from uni. But some time ago, I already"
100080,108640," attempted to solve some of the problems. And I think I still have like a repo on GitHub, where I tried to"
108640,118400," do that. So let's actually search for camel in here. Yeah, 99 problems to 2013. Oh, my God, I was a student."
118400,124640," I was actually a student. I was in uni when I was trying to sell. Okay, so I managed to solve like 25 of"
124640,133120," them. So yeah, but that was long time ago, like eight years ago. And this is eight years is the last"
133120,139440," update, right? It's the last update. And I started this entire thing. Well, I mean, yeah, I basically"
139440,146320," briefly tried to solve this entire thing. And I just like stopped. All right. So back when I was"
147200,153680," a student, I managed to solve 25 of them. So I'm not going to look into any of these solutions. And I'm going"
153680,162000," to try to attempt to solve them today with my current knowledge and see how much I degraded as a developer,"
162000,167840," right? Because I'm getting older, I'm getting dumber, I'm losing brain cells. So probably I won't be able to"
167840,177280," solve 25 of them today. So yeah, I'm going to give the link to this repo in the chat. And for people who's"
177280,187360," watching on YouTube, I'm going to give the link in the description, my old attempts at solving these problems,"
187360,193440," right. So but today, we're going to actually start in a completely fresh and new repo. We're going to start"
193440,201280," on GitLab. Because the buttons on GitHub are poopoo. We already established that that the buttons on GitHub are"
201280,210080," shit. And that's why we're using GitLab. So tiny CLG, thank you, CLJ. I'm sorry for my English. I thank you so"
210080,215760," much for three months of Twitch Prime subscription. Thank you, thank you, thank you. And welcome to Epic OCaml Club."
215760,224880," That's right, we are a camel developers. So, um, alrighty, alrighty. So in photoshoot is no camel is a"
224880,232880," functional sort of like function leash programming language. It's more of like, you know, multi paradigm"
232880,241200," because it also has all p part that nobody uses. And also it has imperative parts, right. So essentially,"
241200,247920," it has like a seamless experience between functional programming and imperative programming, it also claims to have"
247920,253520," object oriented programming, but nobody fucking uses this piece of shit, right. So everybody who programs in a camel,"
253520,260480," they usually use the functional aspect of a camel and imperative aspect of a camel. Right, so object oriented"
260480,266080," programming, I think they just edited because at the time of the camel development, there was like a huge hype"
266560,274400," around OOP. So to market the language better, they just edit OOP well, because of the time. So and since"
274400,280560," there's already code that depends on OOP features, I presume, the object orientiveness of a camel was left"
280560,286240," as a scar on the face of the language, right, you cannot really get rid of it, because there's still code"
286240,291760," that uses that. But at the same time, the new code rarely use those features. So you don't really know what"
291760,298080," to do with this with the shit. So it's just like there. Right. So that's what usually happens. So with"
298080,305680," features like that. So like, I presume, it's purely for like marketing purposes. So it's rather"
305680,311360," interesting, it's rather interesting, it feels like Haskell, but it's not lazy, right. So one of the"
311360,318640," things in the camel is that it's not lazy, but it has lazy evaluation. Right, just in case you need it,"
318640,330560," right. Hello, hello, everyone. Hello. Oh, underscore camel user says a camel school. Well, thank you for"
330560,337120," your unbiased opinion. Thank you so much. Yeah, I also think that the camel is cool. So how are you guys doing?"
337120,343760," Hello, hello, hello, hello, this used Demki, fluffy Poga, Eddie, pop it, Chan, crazy chicken. So many cool"
343760,348000," names. Hello, hello. Welcome. Welcome. Welcome. Cheers, by the way."
348000,357600," Alrighty, so let's actually clone this repo. And let's take a look at the problems, shall we?"
361680,368800," So this is a Zozing and I'm going to do git clone. Do I even have a camel installed on my machine?"
368800,376400," I do have a camel 4.10.0. And I'm not even sure if that's the latest camel, but a camel is not rust,"
376400,379360," you don't have to have the latest camel. Right, so"
379360,385200," got him. Alright, so we have this read me. And"
386640,389760," so this is like a crap that was auto generated by"
389760,397360," GitLab. So I think I'm going to actually remove all of that. So at least for now. So we're only going"
397360,403440," to have this thing. And in terms of the license, I'm going to distribute all of that under MIT license."
403440,409520," So you can do whatever the fuck you want with it. Right? And except claiming that you made this thing,"
409520,415200," right? So this is basically MIT license, do whatever you want, except claiming that you created this thing,"
415200,419920," including selling, by the way, you can make money off of the code. Just don't say that you made it."
419920,428960," Right. So this is that. So let's create a simple hello world in a camel. I wonder if I still remember"
428960,435840," how to program in this language. So well, a camel from eight years ago is probably the latest. So"
435840,442240," effectively, you have the latest camel without even trying. What's funny, when I was solving this problem,"
442240,449920," I think a camel didn't even have the pipe operator, right? So in the pipe operator essentially allows you to sort of pipe"
449920,458000," values through a sequence of functions and so on and so forth. I I'm so fucking old. I remember a camel not having"
458000,463440," this operation. That's how fucking old I am. So and I remember the times when I was"
464000,471440," ranting about a camel not having this operation, right? And how all the other languages or all the"
471440,476640," other cool kids do have it and I have to implement that operator myself. That's how fucking old I am."
476640,487120," Oh, boomer zozin. Yeah, exactly. Boomer zozin. Okay, so let's actually write hello world. I think you write it"
487120,498000," like this. I almost actually wrote hello world. And then print and line because I've been programming in"
498000,506080," ports too much lately. Right? Because I'm right now I'm actively rewriting ports in itself. And in fact,"
506080,512560," right, so I think it's already like 1000 lines of code or something. I don't fucking remember."
513680,521520," So let me take a look at the current state of port. So I'm going to fix the latest right and take a look"
521520,528480," at the port port port dot port. So here's the current state of port. As you can see, I already added"
528480,533840," all of the intrinsics. Adding all of the intrinsics was relatively simple because we already have"
533840,540960," implementations for them in Python. So I just had to click copy paste them into port. All right, so and"
540960,548480," the current size is 1064 lines of code. Right? So and that's basically the current state. So here"
548480,554400," is the parsing of all of the intrinsics. Right? So here we have interpretation. So with the interpretation"
554400,559680," for some of them is not implemented, because it may require like a simulating memory management. So"
559680,564320," and I didn't come around to actually do that. But simulation for the rest of the things is actually"
564320,569040," there. So you see, we have a simulated stack. And we're basically simulating these instructions"
569040,574400," and also compilation for all of the intrinsics is pretty much there. Right? So here's the compilation"
574400,581680," and all that works actually. So all of that works. Which is pretty power, which is pretty power. So for"
581680,588880," those who doesn't know port is the programming language that I'm developing from time to time on this"
588880,594640," channel, I'm going to give the link to the source code in the chat for people who just joined. And for"
594640,601120," people who's watching on YouTube, I'm going to put this thing in here, my programming language,"
601120,612080," which is not as cool as a camel. Of course, right? My language doesn't have OP, right? So which makes"
612080,620960," so camel even cooler than my language. Okay, so yeah, what I want you to do, I want you to implement"
620960,630240," Hello World. If I remember correctly, you implement it like this. So you call functions in a camel without"
630240,638000," any parentheses. So it's almost like port, but the other way around, you see. So in port, I would first put"
638000,644080," the string literal and then the function in a camel, I first put the function and then the string literal."
644080,650000," So basically, it's pretty much the same thing. So"
661040,666960," All right, let's see if this thing is going to work. As far as I know, you can interpret the camel, right?"
666960,670800," So let's actually do all of that in the terminal."
670800,680400," And let's go to this folder. So if you do a camel main dot ml, it will just straight up interpret this"
680400,686800," entire thing, nothing particularly special. But a camel has a compiler called a camel C,"
687440,696160," right? And what it does, it compiles a camel into an executable, which you can run like so. And as you"
696160,700880," can see, it says hello world. But you know, what's interesting is that you think that, okay, it's a"
700880,705840," native executable, probably. But let's actually confirm, is that a native executable?"
707920,717040," It's a camel run script. This mother flipper, instead of generating a native code, just debated us and"
717040,725040," generated some sort of a freaking script. The fuck? Okay, let's take a look inside of this thing."
725040,731760," That's a funky looking script. Look at that. So essentially, it didn't really generate a script."
732560,740400," It generated a bytecode. But here's the trick. It basically wrapped it into a shebang."
740400,746080," So have you ever seen a bytecode binary with a shebang?"
746080,753040," Like, I don't know, like, the only like the only place where I saw this shit like that is in a camel."
753040,756720," Does anyone know any like anyone else doing this kind of trick?"
757280,762800," Right? Because I've never seen it like anywhere except in a camel. I mean, bytecode is fine. But"
762800,768960," it's just kind of an interesting idea. I mean, it works. It's actually five head. I do agree with that."
768960,775520," But I would never think about doing it like that. So it's kind of cool. So it's a really big brain."
775520,780960," Right? It kind of looks like a native executable. And you can run it as an active executable,"
780960,785120," but it's not an elf. It's not an elf executable. It's actually like a shebang script."
785680,791760," Um, what's interesting is is though it doesn't mean that a camel isn't capable of doing native stuff."
791760,798800," So for native stuff, it has a separate compiler called a camel opt, right? And if you try to use a camel opt,"
798800,804320," right, it will generate this thing again. And as you can see, this thing is a little bit beefier than"
804320,810560," it was before before it was 20 kilobytes. Now it's actually one megabyte. So generated shit ton of crap."
811440,816480," And if we take a look at this file, right, if we take a look at it, not not fight, I don't know what"
816480,823520," this fight even means. Yeah, so as you can see, it's an elf 64 bit executable. And if you run it,"
823520,829760," it's it says hello world. So basically, you have several options, you can use a camel as a script,"
829760,836400," right, you can interpret it with a camel, you can have a ripple as well. You can compile it down to byte"
836400,844080," code, which is cross platform, right? So you can have like a sort of like a JVM, right? JVM byte code"
844080,850000," where you compile program once and run it everywhere. And also you can then compile the entire thing to"
850000,859600," native code if you need them speed, right? All right, thank you so much porn theory for five months of tier"
859600,875200," one subscription. So the real bangers. Thank you. Thank you so much for the real bangers. Okay,"
875200,878160," welcome everyone back to our epic camel club."
878160,881280," So"
881280,892720," okay, so we managed to create a hello world, managed to create a hello world. So this is how a camel"
892720,900640," language looks like essentially. So through a let, you define like sort of a binding, sort of a function. And"
900640,908560," this is an entry point, right? So and you call functions like so you define, you provide a function"
908560,917280," name, and then the arguments like a, b, and c. And this is equivalent to f of a, b, and c in conventional"
917280,924160," languages. So this is how you do this, but in a camel, right? So first comes the function name, and then"
924160,929760," the like, separated by spaces, the rest of the arguments. So this is basically how you call this"
929760,936240," function. So you may, you may ask, how would you call something like this, right? So if you have, like,"
936240,941200," two nested functions composed together, how you call something like this? Well, in a camel, you will have"
941200,946400," to do it like that. And then you'll have to wrap this thing in parentheses. So you still kind of use"
946400,953600," parentheses, but just to emphasize what is a function and what is not a function, you see. So that's basically the"
953600,958560," difference, like syntactical difference between the function calls of conventional languages, like a"
958560,966480," c style languages and languages from the family of ml, right? So, right, ml, in that case, that doesn't"
966480,972240," stand for machine learning, it stands for meta language. So there's a whole family of languages where you call"
972240,981040," functions like this, not like this, right. So and one of such languages is also Haskell in Haskell, you also call"
981040,986480," functions like this, and that one is a camel. So then sml, and so on and so forth. There is a whole"
986480,993520," family of functions like that, of languages like that. All right. So let's take a look at the problems"
993520,1002000," that we need to solve, right? So we need to solve 99, not even 69, 99 camel problems. Okay, so what's the"
1002000,1007520," first problem? The first problem? The first problem is working with list working with list is like a"
1007520,1015200," section. So all of the problems are split into seven sections, lists, arithmetics, logic and codes, binary"
1015200,1023440," trees, multiway trees, graphs, miscellaneous problems, right? So we start with working with lists. And this is"
1023440,1031520," a fundamental data structure in a camel, just like in Haskell, or maybe in lisp as well, right. So we need"
1031520,1040560," to write a function that is called last, and it accepts a list of elements a, right. So basically, this is a"
1040560,1048880," generic list, and returns an optional a, right, it returns the last element of that list. And the reason is why"
1048880,1053920," it's optional is because if the list is empty, there is nothing to return, you should return"
1053920,1059920," none, right. So and this is how it should work. You call last on this list, as you can see, list is"
1059920,1067040," separated by semi commons, not commas, right. So it is needed to actually debate you and make a lot of"
1067040,1074080," compilation mistakes. And then if you're in this thing should return some D where D is the last element of"
1074080,1080240," that list. And if you provide an empty list, it should return none. So that's basically what we need to"
1080240,1091680," implement. What kind of syntax is that LMIO? Well, it is a different syntax, right? Different languages may"
1091680,1101680," have different syntaxes. Right. So in fact, there is nothing fundamentally correct or incorrect about the"
1101680,1107760," C style syntax is just like something that was established historically. But you may have a"
1107760,1114240," different way of expressing things, right? So you're not necessarily have to write think one way, you can"
1114240,1119840," write them the other way. Right. So syntactical thing is just like a color of the bike shed, it doesn't"
1119840,1125280," really matter. What's important, in my opinion, is the semantical difference and semantical differences in"
1125280,1131600," the camel. Between the camel and classical C languages are actually rather interesting syntax. Syntax is just"
1131600,1136240," like something that you can quickly get used to. Usually I when I look at the languages and I compare"
1136240,1144080," the languages, I rarely care about the syntax of the language like a rarely care for me, it's what's more"
1144080,1150880," important is the semantic of the language. In fact, this is one of the reasons why I'm not excited"
1150880,1160960," about Lisp as a lot of Lisp fans. Because for me, Lisp is just a Python with s expressions, right? Since"
1160960,1168080," I don't care much about the syntax, I look at least beyond its syntax. And beyond its syntax, Lisp is"
1168080,1176160," basically Python. So especially commonly, especially commonly, like it's just like straight up Python,"
1176160,1181120," nothing particularly special about it. It's just like, yeah, you slap s expressions on top of Python,"
1181120,1190960," you get Lisp. So yeah. But maybe there's something with my brain, right? So my brain does not find"
1190960,1196080," syntaxes of languages exciting or interesting, because it's just like something just slap on top of the"
1196080,1216720," line. Okay, so how can we implement last? Right? So we're going to have last. And this thing accepts"
1216720,1225920," a list of any elements, right? So the way this way, you say that you have a list of A's and A is sort of a,"
1225920,1235520," like a generic, like a generic, right? So list of integers would be int list, list of floats would be"
1235520,1243120," float list, list of strings will be string list, list of any element, we don't care what that element is,"
1243120,1252640," is going to be prime A list. In fact, prime A is basically a generic. So basically, this is equivalent"
1252640,1261840," to something like list of T, where, you know, prime A is basically that T that you don't care about."
1261840,1268320," Right? So that's basically what it is, right? You know, prime A list is basically list of T is just"
1268320,1276240," like a generic list. And then you want to say that last is supposed to return a option, right? And that"
1276240,1283040," basically means that it will return like optional T, right? You have a function last, right? Function last"
1283040,1291360," that accepts list of T and returns optional T. So that's basically what it does. So it's just like an"
1291360,1296720," alternative syntax to that, right, an alternative syntax to that. That's what it is."
1299120,1303520," So when the camel type variables come before the type. Yeah, yeah. So if you have a type that is"
1303520,1310720," parameterized by another type of the parameter of the type comes before the parameterized type. So"
1310720,1323280," Alrighty, so what we need to do, we need to pattern match access, right? If I remember correctly,"
1323280,1332000," you pattern match in a camel with match with, right? So that way you can check. Okay, so if the list that"
1332000,1339440," we've got is an empty list, right? If it's an empty list, we have to do something, right? So in case of an"
1339440,1345760," empty list, I already mentioned, there is nothing to return. So we have to return none, if I remember"
1345760,1350640," correctly. So maybe this is incorrect code, but the compiler will tell us if something's wrong. Okay,"
1350640,1357600," So then we need to deconstruct the list, we need to deconstruct the list into its head, the first"
1357600,1365920," element and its body. Maybe it's too late, actually, if you think about it, what's the most trivial case"
1365920,1372000," for the last function, right? So you need to implement the function that gets the last element, what's the"
1372000,1378400," the simplest and the most trivial list from which it is obvious what is the last element?"
1380400,1387360," It's the least with a single element, right? If you have a list with a single element, the last element"
1387360,1392960," of that list is that element, right? So you just basically go ahead and just return x."
1392960,1399520," It's pretty so far, but it's the simplest case of like when you can just get the last element."
1399520,1406160," All right, so and the general case is going to be when you have more than one element, right? So in that"
1406160,1414640," case, we can trace, we can try to destructurize the list into its like head and the rest of the elements,"
1414640,1420800," right? So in this particular case, as you can see, like x is the head, and this is the rest of the"
1420800,1428080," elements, right? Since none of these patterns were like successfully matched, it will try to match this"
1428080,1435280," pattern. And how can we get the last element out of here, right? So we know that there is more than"
1435280,1440800," one element in here. So that means the last one is not going to be this one, the first one is not the"
1440800,1446240," last one. So in that case, I can say, Okay, well, let's just ignore that one. So and the last element"
1446240,1452640," of that access list is going to be the same as the last element of the rest of the element without the"
1452640,1458640," head, right? So that means we can do this entire thing recursively. And there we go, we implemented a"
1458640,1466400," function that finds the last element recursively, right? So we have a couple of bases of the recursion."
1466400,1472560," In case of the no elements, you just return none. In case of a single element, it's a trivial case,"
1472560,1478000," it's the base of the recursion. We return that element. And when you have more elements, it's the"
1478000,1483840," same as last element of the list without the first one. And as you go, we have like a recursive process"
1483840,1488960," that basically chops off the element of the list until it reaches the list of the single element,"
1488960,1495600," and it just returns that list to you. So here's the function. Is that clear? Does it make any sense?"
1495600,1502080," Hopefully, that makes sense. Okay, so what we can do in here, I think we can try to"
1502720,1510320," maybe compile the entire thing. I forgot how to use OCaml actually. So, okay, so here is an interesting"
1510320,1520000," thing. I'm trying to call last while being inside of last. And the compiler complains that it cannot"
1520000,1532240," find last. And this is because the functions by default in OCaml are not recursive, right? They are by"
1532240,1539520," default not recursive. So to indicate that a particular function is a recursive, you have to put a rec in"
1539520,1546720," here. And only then you would be able to compile your program if it has a recursive function. So this is"
1546720,1551120," very interesting. So all of the functions in the camel, if you define them, you cannot call them"
1551120,1557200," recursively. And yeah, you have to specifically say that it's a recursive function. And I wonder why,"
1557200,1567920," why it is so maybe because the camel is one pass compiler, right? So until it actually has the whole"
1567920,1573600," function, it doesn't know its name. So you have to sort of like, indicate that like forward declare"
1573600,1579120," it or something. So it's kind of, it's kind of strange, but it is what it is. And it isn't what it"
1579120,1587600," isn't. So right. So we have a function last. Okay, I wonder if we can just like load some of the function"
1587600,1596320," in a camel, right? So if I provide the camel, a repo, so it's gonna be ml, and it doesn't allow me to just"
1596320,1607440," have a ripple and load this entire thing. So I do remember that I had you talk or something, but I don't"
1607440,1617680," quite remember. But but anyway, so a camel repo load file, I really don't remember how to load files"
1617680,1627520," into into a repo or camel. Forgot how to do that. So, okay, cut file, you can use that file. That's actually"
1627520,1636080," pretty cool. Okay. So if I do use, and then I say main dot ml will that work. So I also have to put"
1636080,1644640," this double semicolon. And that kind of worked. And now I have lost in my repo. So I can define a couple"
1644640,1654080," of things like one, one, two, three. And there we go. So as you can see, we have, you know, we have this"
1654080,1660880," list and last returned the last element, right? So it's not particularly convenient, right? So a camel by"
1660880,1668720," default that does not define any functionality like a read line functionality. Right? So we may want to"
1668720,1674000," use something like a real RL wrap. For those who doesn't know, by the way, so it's actually a very cool"
1674000,1680800," thing. If you have a program, right, if you have a program that by default doesn't have any history,"
1680800,1688240," and doesn't allow you to like, move around left and right with arrows, you can always just install a"
1688240,1697120," program called RL wrap, right? And it will automatically have a history and like everything"
1697120,1703840," that you get used to. So it automatically adds like a read line functionality to, to your ripple,"
1703840,1707680," your ripple program that you have in here. So I think it's actually pretty cool thing."
1708000,1723680," So, um, um, our L wrap, our L wrap. So, uh, read line wrapper. Is that the official repo of this,"
1723680,1728640," uh, of this thing? I think, well, it has a lot of stars and it definitely deserves a star. If that's the"
1728640,1734160," official reaper, uh, it definitely deserves a star. Uh, and I suppose you can find it in here, but it's"
1734160,1741440," usually available in all of the like Linux distros that I used. So it's just like, yeah, it's available."
1741440,1747680," Uh, and I'm going to put that in the description for anyone who's watching right now. Um, so RL wrap,"
1748640,1759920," so you can use this thing in here if you want to, of course, um, um, okay. So we've solved the first"
1759920,1765200," problem, believe it or not. We solved the first problem we solved like last. And, uh, what's"
1765200,1771360," interesting is that since last is a generic function, we already discussed that it's a generic function."
1772160,1779840," Uh, so, um, you can use it not only with numbers, you can use it with strings, right? So you can do"
1779840,1786400," last and it will return you about, we have to use this entire thing. So it has to be main dot ml. Uh,"
1786400,1791280," there we go. And then I can just do something like, uh, this and there we go. So it also works"
1791280,1797680," with strings. It works with any types because it's generic, right? So unlike some of the modern"
1797680,1803040," languages that are younger than a camel, a camel is actually a pretty old language. A camel does have"
1803040,1810240," generics, right? I'm not going to point any fingers on any of the modern languages, right? But this thing"
1810240,1817280," has, uh, you know, generics and they work pretty fine. They work fine. Um, all right. So, and again,"
1817280,1825120," if you, uh, use this thing on an empty list, uh, right, it will return on. Okay. So this is the first"
1825120,1831120," problem. Um, as far as I know, the comments in a camel are kind of weird. This is the way you define"
1831120,1837520," comments. And as far as I know, uh, there's only multi-line comments. There's no comments that comment"
1837520,1844480," a single line. Um, a camel has generics, but it doesn't have a single line comments, right? So there's"
1844480,1852000," always a trade off. That's the price you have to pay, uh, you know, to have, uh, generics, right? It's like with"
1852000,1856960," Python, right? So there's a trade off. You can either have, uh, you know, a newbie friendly"
1856960,1863360," language or a fast language, right? And in here, it's the same. You can only have generics or, um,"
1863360,1867920," like single line comments, right? That's the price you have to pay. You cannot have both,"
1867920,1872160," right? It's impossible to have a fast and newbie friendly language. It's literally impossible."
1872160,1878400," Computer science haven't solved that. Uh, the same goes with, uh, you know, single line comments and"
1878400,1883840," generics, right? So the, these are mutually exclusive things. Okay. So this is going to be"
1883840,1891680," the problem. Uh, the problem zero one, right? Problem zero one. Uh, cool. Uh, so maybe we're"
1891680,1896000," going to actually, uh, just comment everything. So also camel, one of the problems to the camel is"
1896000,1903360," that it produces a lot of garbage, right? Uh, so every time you compile, it's just like CMI,"
1903360,1912720," CMO, CMX, ML. Well, ML is the garbage that I wrote. It's, it's my garbage like .o, um, a.out. So"
1912720,1919920," usually we, we want to actually kind of like, you know, git ignore all of that. Uh, so git ignore."
1919920,1924960," So let me take a look at what we have in here. So first one is going to be, and I'm going to actually"
1924960,1938080," keep it like that. So git ignore CMI, CMO, CMX, O, and usually we're not going to have a, a.o. So I'm"
1938080,1947600," going to just straight up like remove this entire thing. Uh, there we go. There we go. So, uh, are we"
1947600,1954000," going to have like some, I don't know, like a quick start instructions? I don't think so."
1954000,1957040," We don't, we're not going to have any quick start instructions because we don't have that many"
1957040,1965120," solutions anyway. Uh, right. So, uh, let's do something like this, uh, solution for problem"
1965120,1970800," zero one. And I'm going to push that right into the repo. And yet again, uh, the source code is"
1970800,1976400," available right here, right now. You can find it in here. And for people who's watching on YouTube,"
1976400,1980160," you can find the source code in the description. So I keep track of what I'm going to put in the"
1980160,1986080," description and hopefully I won't forget and won't lose this file when I'm about to upload this video."
1986080,1992080," So that may happen. That actually happened a couple of times. Uh, I remember actually like keeping track"
1992080,1998400," of what I want to put in the description and then, uh, I just deleted that file and I don't remember what"
1998400,2003920," I wanted to put in the description. So if that will happen this time, I apologize. You can always Google"
2003920,2009760," all these links, right? So it's just like, yeah. Uh, anyway, so what's going to be the next problem?"
2009760,2013840," What's going to be the next problem? We have 90, 98 of them. We already solved one."
2013840,2025680," Finally, find the last, but one, uh, last and pen ultimate elements of least easy."
2027360,2034080," Well, it's not really easy to understand, but okay. Um, oh, I suppose you need to return last"
2034080,2040560," and the, the one before last last two. Okay. So that makes sense. Um, all right. So it literally"
2040560,2048320," even called last two, holy shit. The function itself is called last two, uh, problem zero two. Okay. So"
2048320,2055200," this is going to be last two. And yet again, it is going to accept a generic list, right? And I suppose"
2055200,2062400," it is going to accept, uh, return, uh, a pair of elements, right? So it's supposed to return, uh, a,"
2062400,2070720," a, uh, a option. Oh, and I think I remember. So can I rise something like not implemented or maybe like"
2070720,2077920," not implemented? Look, look, look, OCaml has exceptions and you rise exceptions like, like in Python."
2078640,2086400," It's literally like in Python, right? So majority of people believe that the syntax of the language"
2086400,2093280," equals to the language. So if some of the languages share keywords, that means they are basically the"
2093280,2099520," same languages. What is semantic? I've never heard of semantic. The fuck is semantic. The syntax,"
2099520,2112800," syntax is the language. Uh, syntax is the language. Um, I bet those in could rewrite the port compiler"
2112800,2118000," in a camel, and that would be still faster than Python code. Yes, it would. Because I actually worked"
2118000,2126240," with both big Python projects and big camel projects. And bigger account projects are generally way faster"
2126240,2131760," than parts and projects way faster because I mean, it compiles and optimizes the native code. Right."
2131760,2138160," And in fact, uh, it has a way better type system. So it catches more errors, but I mean, Hey,"
2138160,2145520," at least it's newbie friendly, right? Um, anyway, so, uh, let me take a look. I don't remember how to"
2145520,2151120," actually do not implement it, but, uh, whatever, might as well actually do something like assert, uh, false,"
2151760,2159040," maybe that way. So, uh, here's an interesting thing about, uh, tuples. And here's an interesting"
2159040,2167840," thing about tuples. You define tuples, uh, not like this, right? So this is a tuple type, right?"
2167840,2176960," This is a tuple type. This is a tuple with two elements, but, uh, so this is the type,"
2177760,2187360," but the value of tuple, uh, oh my God, the value of, of such tuple is actually, uh, going to be, uh,"
2187360,2193440," one, two. So this is how you define a type. Since this is two integers, let's actually define this"
2193440,2201120," thing as two integers. Okay. So this is the type and this is the value, right? Uh, and it makes it super"
2201120,2206160," easy to make a mistake and confuse them. Like, and I remember multiple times actually defining a type like"
2206720,2211920," this and then trying to understand what the fuck is going on and why the compiler complains about that"
2211920,2219120," when in reality, you have to define it like this. And in fact, uh, there is another pitfall in here."
2219120,2227440," You don't have to even put parentheses around the tuples. Just using a comma is enough."
2228560,2235280," And this is one of the reasons why lists in a camel are separated by semicolons,"
2235280,2247520," not commas. Because this is not a list with two elements. It's a list with a single element and that"
2247520,2255600," element being a tuple of two elements. A list with two elements, in fact, is something like this."
2257760,2265760," So yeah, it is very freaking easy. If you're coming from a different language, it is very easy to make"
2265760,2270960," a mistake of defining the list like that. And then still like looking at the compilation errors thinking,"
2270960,2276480," where the fuck did I make a mistake, right? Because you're not defining the list with two elements,"
2276480,2282880," you're defining the list with one element, which is a tuple. So yeah, welcome to account."
2282880,2298560," So it is what it is and it isn't what it isn't. Anyway, but you get used to that quite quickly."
2298560,2305040," So it's just like Rust. It's like Rust. The language is not shit. You just have to get used to it. It is not"
2305040,2310880," shit. You just have to get used to it. Just like Rust. So now let's actually go ahead and implement this."
2310880,2316240," I think so. Yeah, I've explained all of that just to explain what the fuck is going on here."
2316240,2324320," Okay, so this time we actually have a couple of different cases. So in case of the"
2324400,2332320," empty list, we have to return none. In case of a single element, we also have to return none. I"
2332320,2338640," wonder if we can sort of like collapse these two, these two branches, maybe not, I don't know. But in"
2338640,2345120," case of two elements, right, in case of two elements, you have to return those elements. So it's going to be"
2345120,2354640," some x and y. There we go. So and then what we have to do, we have to like repeat this iterative"
2354640,2361280," process, right, we're going to destructure the list into like the rest of the element. And last two of"
2361280,2368320," that list is basically last two of the rest, right, last two of the rest. And this thing has to be"
2368320,2373760," recursive. There we go. It's pretty much the same solution, except we have additional keys, right?"
2376640,2384480," Um, how would you do three elements tuple? You will do it like this. Like so"
2384480,2397440," Okay, so let's see if this entire thing compile, I'm going to try to compile and this thing"
2397440,2405280," returns none. I suppose I have to actually put parentheses in here. Because okay, so there is a"
2405280,2414400," difference. There is a difference between this and this. This is a tuple where the first element is a,"
2414400,2420560," and the second element is optional a. If you need an optional that contains a tuple of ace, you have"
2420560,2425440," to do it like that you have to, you have to be careful with the order of things that you define,"
2425440,2430560," right? Because this thing is not the same as the one with the parentheses, right? So this is like a"
2430560,2434880," tuple with two different elements. First one is not optional, and the second one is optional."
2434880,2450560," I always wonder the language creators reasoning behind syntax choices. Well, the camel comes primarily"
2450560,2457040," from academic environment. And academic environment is usually quite isolated from the industry,"
2457040,2462400," and they don't care about the conventions of the industry. And that's the reason why you sometimes see"
2462400,2469520," the language is like that. So yeah, right. Because people in academia don't even know that somebody"
2469520,2476640," programs for like, for money and for other people, they think that programming is just like a branch of"
2476640,2483280," mathematics, right? So for for academic people is just yet another branch of mathematics. Yeah. And"
2483280,2489680," everything in academia, there's everything there is to programming, and there's nothing outside of academia in"
2489680,2497360," terms of programming. So that's why you end up with conventions and languages like that. So it's just"
2497360,2503920," another branch of mathematics, right? Just applied mathematicians, nothing special. Anyways, I think we"
2503920,2511760," solved this thing, right? Can I reuse the same file and redefine some of the things I wonder? I can so I can"
2511760,2517680," stay in my repo and I can just update this function and just can reload them and stuff like that. Can I just"
2517680,2527760," reload or something like that unknown directive for reload? Did you mean load? Maybe? Did I mean load? I"
2527760,2533840," don't even know what is load in terms of like a camel repo. I know a thing or two about the camel, but I know"
2533840,2542080," almost nothing about a camel ripple, which is kind of strange. So which is kind of sus, not going to even"
2542080,2549120," lie. So if I try to do okay, do we have help? Do we have help? We do have would you look at that? So"
2549120,2558560," apparently, we have some shit in here. So we have help, we have quit, you can quit through the pound."
2559520,2566560," You can do CD, change the current working directory, add the given directory to search path for source"
2566560,2575760," and compiled files, load in memory a bytecode object produced by C. So you can load recursively things,"
2575760,2583520," you can remove directories and stuff, read compile and execute source files, show print the signature"
2583520,2592800," of the components of any categories below show class show exception. That's pretty cool. Okay,"
2592800,2599920," so I didn't know that you have so many so many epic things. But even though a camel comes from academia,"
2599920,2606720," right now in 2021, as far as I know, it's used as an industrial language, right? So it's used quite"
2606720,2612560," actively in an industry. And the biggest user of a camel, as far as I know, is a Jane Street company,"
2612560,2617280," right? I think that that's the biggest user of camel. Does anyone know about this company?"
2617280,2627360," Right, so it's basically a trading company. And so one of these sort of like, you know,"
2627360,2634320," one of the feature of that company is that they're using a camel there for everything. It's just like"
2634320,2644160," the main language of this company, like everything is in a camel. Yep. So I suppose a lot of people know"
2644160,2650800," about Jane Street, if they're mathematicians, and maybe watch some mathematical content on YouTube,"
2650800,2657040," like, you know, stand up math or a three blue one brown, because as far as I know, the math YouTubers"
2657040,2663760," actually partner quite often with Jane Street. And they're sponsored by them to promote them as the"
2663760,2669360," workplace for potential like students like something like that. So yeah, I'm going to leave the link to"
2669360,2672480," the Jane Street in the description for anyone who's interested. So I'm going to put them in here."
2673680,2680400," I'm just stupid to work in there, unfortunately. So yeah, but it's a I heard it's a cool company."
2680400,2696560," All right, so what I want you to do, I want you to test last two, right? So let's test last two."
2696560,2704240," If I have something like one, two, three, four, right, it returns last two elements in here. And if you"
2704240,2709680," have a single element in here, it's supposed to return none. And if you have an empty list, it also"
2709680,2713920," returns none. So we basically solved the second problem. Isn't that cool? Isn't that cool?"
2713920,2727200," I think it's pretty freaking cool, mate. Okay, go. So yes, okay. Add solution to problem,"
2727200,2731360," problem 02. And I'm going to push that right into the repo."
2731360,2738880," Okay, so what's the next problem? So we have 97 problems to go."
2739600,2743120," Find the kth element of a list. Easy."
2743120,2750800," Okay. So you have to define a function at which accepts the number and the list and returns you the"
2750800,2758480," nth element of that list. So in our case three, it will return one to Oh, it even starts with one."
2759200,2766080," Okay, remark, a camel has list nth which numbers elements from zero and rises an exception if the"
2766080,2773760," index is out of bounds. Right? So and so people to make people not use nth as a solution, this thing"
2773760,2780240," doesn't rise exception and also starts with one. Disgusting. Anyway, let's go ahead and implement this"
2780240,2792000," thing. Okay. So we need to implement at. So as you can see, it accepts integer k and list of ace and"
2792000,2797840," supposed to return optional a right there we go. So we have to implement this thing."
2800240,2810400," Um, I wonder if you provide zero, I suppose it also should return like none. Um, so we have"
2810400,2813680," like a couple of situations like if k is"
2813680,2820560," Oh, boy. Oh, boy. Oh, boy. Where is my soil?"
2823840,2830880," I guess we could match access like so, right? You can match access like so. And in here,"
2830880,2839760," we're going to have x and rest. If I remember correctly, on top of having the the parents in"
2839760,2847040," power and match construction, you can have like guards, right? So here is the pattern. And there's"
2847040,2853680," also additional condition. And I think it's something like that. So when access has this particular pattern,"
2854240,2862240," and when k is equal to one, then you can safely return, uh, return x, but I don't remember for"
2862240,2868720," sure. Right. So I want to actually Google it up. A camel pattern matching anything. They're called guards."
2880160,2887040," guards. It's like mods. Oh, yeah, there we go. So you can have a pattern and then you can have one"
2887040,2898480," width condition. Pretty cool. It's pretty cool. Okay, so if we have just something else. Well, I mean,"
2898480,2909920," we have several situations, right? When k is less than zero, right? When k is less than zero, and when"
2909920,2915760," k is greater than one, in all of those cases, we want to actually go to different places, right? So"
2919040,2927600," right. So in case of k, like less than one, this is a straight up none, right? Because you cannot go"
2927600,2937600," less than one. You cannot go less than one. But if it's greater, you want to actually recur, you want to"
2937600,2947120," actually recur. So in case of this thing, if it's greater than one, if it's greater than one, you want to"
2947120,2958560," do something like at k minus one, rest, let it go. So and if you end up with an empty list, for whatever"
2958560,2966640," reason, right, so with an empty list, this is also known, essentially. So can we simplify this entire thing,"
2966640,2973360," we could probably move all of these conditions inside of this branch. But I don't know."
2973360,2981680," Is the rest a special match word? No, it is not. Actually, it's just like, it's just a name for a"
2981680,2990240," variable, right? So basically, I'm bounding the first element of access to x, and the rest of the elements"
2990240,2996320," except x to word rest, I can call it something like wise, and it's gonna be the same. What's interesting is"
2996320,3004960," that in here, we don't really care about rest, so I can do something like this, right? So, yep, if k is one,"
3004960,3013600," and you have like at least one element in here, you can return that element. If for whatever reason, for"
3013600,3022480," whatever reason, k is less than one, you have to return none. Interestingly enough, maybe we can even remove"
3023280,3030080," this case and just put something like this in here. And I think that will work. Yeah, this is actually"
3030080,3034880," greatly simplifies the situation, right? So if you have at least one element, k is equal to one,"
3034880,3039760," the result is that element. If you have more than one element, but the k is greater than one,"
3039760,3046240," you recur with k minus one, and the rest of the element. If your list is empty, or k is less than"
3046240,3050960," zero, well, in that case, it's just like a straight up none. There's nothing to do in here."
3054480,3075040," That is very interesting, actually. It seems you totally ignore what I'm telling you. Well, here's the"
3075040,3082000," thing. Mr. vodka is the bot of this channel. So it does, in fact, ignore everything you say,"
3082000,3087760," because it's a bot. I'm really sorry to tell you that. But I think I like I don't like to be that guy."
3087760,3096240," But I think you need to know that Mr. vodka is a bot. All right, so let's see."
3099760,3106560," Let's see, is it going to work? Can actually just like do use? Yep, yep, yep. And it seems to be"
3106560,3112160," working. So let's take a look at some of these test cases in here. 99 problems."
3112160,3120640," I might as well just like do that. And this thing should return some C. And as you can see, it returns"
3120640,3127680," some C. If we're going to do something like this, it returns none. And furthermore, if I try to do zero,"
3127680,3134080," it also returns none. Right? So that makes sense. But if you do one, it returns some A. I think this"
3134080,3140080," is a reasonable solution for this problem. What do you guys think? Right? I think this is, in fact,"
3140080,3149680," a reasonable solution. Maybe you can compress it even further. Right? But that's fine. It's fine."
3154080,3161200," All right. So this is a problem. Problem zero three, problem zero three. And let's go ahead and"
3161200,3172880," just commit that add solution for problem zero three. And we're going to push that right into the repo."
3172880,3180640," So what's going to be the next problem? So far, so good. So far, we only have easy problems. And as far as"
3180640,3187520," now, there's also medium problems. And the medium, the first medium problem is flatten nested list structure."
3187520,3194400," It's actually not that much difficult than the previous values. What is the first hard problem?"
3195040,3204800," A half month code. That's quite a quite of a jump. I mean, okay, between flattening the structure"
3204800,3210480," and half month codes. I mean, half month codes are not that hard. But between flattening the structure"
3210480,3217520," and implemented half month codes, there's quite a bit of a gap. It's not as much of a gap as between easy and"
3217520,3227360," medium. I'm not quite sure. And actually, the first hard problem is actually 50th one. So to be fair,"
3227360,3233920," I planned to implement half month codes as a separate stream topic, actually. So"
3236640,3242720," so it will be interesting. I don't know if we're going to actually get the 50th problem. It's actually"
3242720,3247680," it's a halfway through. But half month codes are actually very interesting. I remember implementing"
3247680,3254480," them when I was a student. And they're really, really fucking fun. So the idea of half month codes is like,"
3254480,3261200," essentially, you have a sequence of like of beats. And the most common,"
3262560,3269280," the most common sequence of beats should be represented with the shortest sequence of beats. And basically,"
3269280,3277600," you gather you build that substitution based on the statistics of the sequence of beats. And you do that"
3277600,3283520," with a tree or something. Yeah, I think I quite remember, like, roughly remember. So I probably need to"
3283520,3288400," read on half month codes a little bit more. But they're quite like, they're usually used for compressing stuff."
3290720,3295360," half month code is small in the camel. Okay, so maybe that's why they put it in there. Because"
3295360,3299600," maybe the functional approach works really well with half month codes."
3299600,3308560," Um, okay, so what's going to be the next problem, right? What's going to be the next problem is going"
3308560,3318720," to be something like a problem. 04 problem 04. Find the number of elements of a list. Easy. Okay,"
3318720,3325600," okay, most standard library has least length, but we ask you that you re implemented a bonus for a tail"
3325600,3338080," recursive solution. Oh, who knows what is a tail recursion. Um, tail recursion. Undertale recursion."
3338080,3344320," So let's go ahead and try to do that. So this is going to be like a length. And in here, we're going to"
3344320,3350000," accept the list, right? And this entire thing is going to return an integer. Okay. How would you"
3350000,3358640," implement the such function? Right? So let's go with the recursive approach yet again, we're going to match"
3358640,3365840," access, right? And what's the simplest case? What's the simplest list, the length of which"
3368160,3374640," you can calculate easily. Let's put it this way. Um, I suppose it's an empty list, right? So if you have"
3374640,3380800," an empty list, you can straight up say that the length of that list is zero, right? If you have a list where"
3380800,3387040," you have more than one element, right? So the length of such list is going to be the length of the list"
3387040,3395120," without the first element, plus one. There you go. We implemented a very simple function that calculates"
3395120,3405280," the length of the list recursively. Um, to do two. So let's actually do use. And it doesn't compile yet"
3405280,3412400," again, because you have to mark this function as recursive. Right. So and let's do length, and I'm going to"
3412400,3424720," provide the empty list. It is zero, one, uh, two, I'm sorry, uh, three and so on and so forth. Right."
3424720,3432640," So, but they also promised extra bonus for tail recursive solution. Who knows what is a tail recursion"
3432640,3442160," and how you can implement this thing tail recursively? Who knows what it is? So they even provide the link to"
3442400,3448400," uh, wikipedia article about tail call. So let's actually read about it. So I don't know what is"
3448400,3456560," a tail call, right? In computer science, a tail call is a subroutine call performed as the final action of a"
3456560,3464320," procedure. If the target of a tail is the same subroutine, the subroutine is said to be tail recursive,"
3464320,3471600," which is a special case of direct recursion. Tail recursion or tail end recursion is particularly useful"
3471600,3479360," and often easy to handle, uh, optimize optimization in implementations. Thank you, wikipedia. Very cool."
3479360,3485760," This is a very clear, uh, description of a tail call, tail recursion, tail end optimization, whatever"
3485760,3491200," the fuck you want to call it. It's just the only important rule in here is just to have word tail on"
3491200,3498160," it. Right. So we have to use words tail and call recursion in any order you want. Right. And it will mean"
3498160,3512640," something tail recursion isn't even in fourth. Why would we need to know? That's a good question. We"
3512640,3518400," could probably implement it. We could probably implement it. Yeah. GPT three text or whatever."
3518400,3524400," Yeah, exactly. So it feels like a generated by GPT. Like what the fuck is it? Like is this shit? So maybe if we"
3524400,3529200," read a little bit further, maybe we will know what the fuck it is tail calls can be implemented and"
3529200,3536640," implemented without adding a new stack frame to the call stack. Most of the frame of the current"
3536640,3543360," procedure is no longer needed and can be replaced by the frame of the tail call modified as appropriate"
3543360,3548160," similar to overlay for processes, but for function calls. Yeah, this is already a little bit closer to"
3548160,3554880," what it is. Right. Just a little bit closer. Okay, so let's actually maybe take a look at simple example"
3554880,3560960," like in C. Right. So I would like to use C because it's more of a like a low level language, it's closer"
3560960,3568240," to the hardware and it closer to what actually is happening. You know, on the on the hardware level,"
3568240,3574640," because a tail call Intel recursion, it's more about low level thing, right? It's more about low level"
3574640,3579040," thing. So you have something like this, I'm going to explain what is a tail recursion Intel call"
3579040,3585120," optimization from my point of view. I'm very dumb person, and I'm very uneducated. So I may not know"
3585120,3589600," some things. I'm sorry, I don't have a PhD in computer science. So I'm going to get some of the"
3589600,3595200," academic terms wrong. And I'm going to upset a lot of, you know, PhD researchers. I'm really sorry about"
3595200,3604720," that. I'm going to just say how I understand this kind of shit. Okay, so let me see. So imagine"
3604720,3613760," you have a function that looks like this, right? So you accept an integer and you return an integer,"
3613760,3624320," right? If x is less or equal than zero, right, you're going to return zero. Otherwise, you're going to"
3624320,3637440," return maybe one plus f x, right? One plus f x. So what happens when you call such function, or in fact,"
3637440,3646960," any function, right? On a low level, we have so called call stack, right? It's a small region of memory,"
3646960,3655520," usually on architectures, such as x86 64. It is starting from one place, and it grows towards, you"
3655520,3659520," know, zero address, maybe we want to actually draw this kind of thing real good."
3661760,3678880," So something is wrong in here. Okay. So let's imagine that we have a memory, right? So here is the memory."
3678880,3690560," Here's the memory. It's more of like a virtual address space. So you have a stack that starts in the memory"
3690560,3700080," somewhere here. So this is a stack. As you push more elements onto the stack, they're pushed towards zero."
3700080,3706800," So zero is located here. And the, you know, memory addresses grow towards like right side. So a new"
3706800,3716080," element will be pushed like this, right? And on x86 64, specifically, the end of the stack is kept tracked in"
3716080,3723760," the RSP register. So we have RSP register, it points at the, at the top of the stack, which grows towards"
3723760,3730000," zero, for whatever reason, it's x86 64, right? So essentially, when you perform a function call,"
3730000,3737280," so how an argument of a function is passed to the body of the function. So I don't remember specific details."
3737840,3745920," But if I remember correctly, the call instruction will push the return address on this stack,"
3745920,3751680," right, it will push the return address on the stack. So it knows where to return when you do the return."
3752720,3762160," Right. And it also pushes that x in here. There we go. So and of course, that kind of like modifies"
3762160,3769840," RSP. There's also RBP, which is, you know, like a base of the frame and stack frames, we're not going to"
3769840,3774960," actually go in like that deep into the stack frames, we're going to only talk about RSP and stuff like"
3774960,3782000," that. Right. So here are the things and when you're referring to like x, you're referring to that x on"
3782000,3793920," this stack, it was passed from y to you, why this stack. So recursively, when you call f, yet again,"
3793920,3803360," when you call f, yet again, you need to push today, I forgot to do this thing. I think I forgot to do"
3803360,3809360," minus one, right. So you need to push another frame. So you call f yet again, recursively,"
3809360,3815520," right, you call it yet again, recursively. So that means it will push its return address yet again on the"
3815520,3823600," stack, and then x minus one, and it will keep pushing elements until it will reach this situation."
3823600,3829440," And it will start returning from this recursion by popping all of this element and returning back"
3829440,3835840," from the return addresses like so basically, as you go deeper and deeper into recursion, it will push"
3835840,3839920," more and more things into the stack. And then when it's time to return from the recursion, it will pop"
3839920,3846320," everything and return the results. That's basically what happens on the low level on the machine level,"
3846320,3851200," when you program a recursion. And that's why I'm using C to sort of demonstrate that doesn't make sense,"
3851200,3856320," right. So this is usually what we call a call stack. And this is how it's usually used, right. With all the"
3856320,3862080," call stack, you will be able to, to do like recursive in the classical sense that we do."
3862080,3871040," Okay, here's an interesting thing. Now, let's take a look at the function that looks like this."
3874160,3890480," that looks like this, right. So essentially, we have just x on the stack, and the return address. And then"
3890480,3897440," we call this function again, but then we don't really need the result of this function up until we"
3897440,3902160," completely return from it, right. So in that case, we probably want to maybe assign it to a variable,"
3902160,3909760," right. So we keep calling function to itself. But it will only push the same thing over and over on the"
3909760,3916560," stack. So in this particular situation, one of the optimizations that you can do, you can basically not"
3916560,3926160," push this pair of elements over and over again, and basically reuse this pair for the next F call."
3926160,3933120," Right. So basically, tail call optimization is basically not pushing yet another pair of this"
3933120,3940720," element, this stack frame, but simply reusing it and decrementing x in place on the stack. That way,"
3940720,3946720," the stack is never going to grow. And you can only achieve it when your function looks like this. When"
3946720,3952160," the last call, when the call to the function, recursive call to the function is the last one, and"
3952160,3957440," it's never like the result of it never used except like returning. So when you have a situation like"
3957440,3963280," this, it's quite easy for the compiler to optimize everything and just not push additional frame and"
3963280,3969840," just reuse this same one over and over again. So this is basically what I understand"
3970400,3975840," when I read about tail call optimization and like tail recursion and stuff like that,"
3975840,3980880," but they might be wrong. But if you read the description one more time, tail calls can be"
3980880,3986720," implemented without adding a new stack frame exactly as I said to the call stack. Most of the frame of the"
3986720,3992080," current procedure is no longer needed and can be replaced by the frame of the tail call modified as"
3992080,3998480," appropriate. So as you can see, as I already said, you have a single frame and on each call, instead of pushing"
3998480,4003600," a new frame, you just keep modifying the current frame, basically turning recursion into loop."
4003600,4010800," Just makes sense. So this is how at least I understand it. But again, I probably got some terms"
4010800,4016800," wrong. I probably get some details wrong. And that's why I don't have a PhD, right? That's why I'm labeled as"
4016800,4024560," as a dumb dumb, right? So yeah. So does anyone have a PhD in computer science in the chat? Please correct me"
4024560,4029200," if I'm wrong. So where did I make mistakes in here?"
4031440,4041120," So this is how I understand it. And so functional programming people really like tail call optimization"
4041120,4051280," because it makes their slow languages look good in some certain situations, in some certain circumstances,"
4051280,4060000," right? Because usually functional programming languages, on average, are slow for real world problems. And that"
4060000,4065840," upsets functional programming, functional programmers, because you know, programmers in 2021 are like"
4065840,4074560," sports fan, they're like, they're rooting for their team, and they get very upset when their team is not"
4074560,4081600," doing well. And function programs basically found a way to make their team look good in some certain"
4081600,4088400," circumstances. And that's why they like tail call optimization, right? So yeah, because it allows them"
4088400,4094960," to optimize slow recursion that pushes a lot of stack frames on the stack and turn it into a loop, right?"
4094960,4107120," So and they ask us to rewrite the the length function in a tail recursive fashion, right? So that's"
4107120,4114000," basically what they ask us to do. All right, so right now, this thing is not tail recursive, right? Because"
4114000,4121440," calling to length is not the last thing in this entire implementation. So for this function,"
4121440,4130560," this function need to wait until the call is done. So it can add one to the result of that call. And so"
4130560,4137920," because of the necessity to wait for the results of the lower call, you need to use the stack,"
4137920,4145760," right? So you need to use the stack in here. So one like to make this entire thing tail recursive,"
4145760,4155520," you need to turn this thing into this thing somehow. You need to somehow make this function look like this,"
4155520,4164000," but then it needs to compute the size of the list. Well, the usual trick in functional programming of turning"
4164000,4171920," a recursive not tail call optimized function into tail call optimized one is to use so-called accumulator."
4172480,4178320," There is an accumulator trick accumulator technique. And once you learn that accumulator trick accumulator"
4178320,4185120," technique, you can basically apply it pretty much to any sort of iterative recursive function to turn it"
4185120,4192320," into tail call function. So then it can be optimized by the compiler. And who like who needs imperative"
4192320,4200000," languages after that, right? So who needs imperative languages, am I right? All right, so let's actually"
4200000,4205760," go ahead and just implement this into Asha. So usually, it is implemented like this, right?"
4205760,4216720," Length, let's call it like a tail, right? So essentially, you accept the list, the first thing. And the second"
4216720,4221600," thing you accept is an accumulator. So an accumulator is going to store"
4221600,4228400," the final result. So it's basically the result, maybe we're going to even call it the result."
4228400,4232880," So the result becomes the input parameter for the function."
4232880,4237440," So the result becomes the input parameter for the function."
4238160,4249680," OK, so then we match access. If we encounter an empty list, we don't return zero, we return the result."
4249680,4255440," We return the result. If we encounter the list that is not empty,"
4257280,4266240," we call length tail again without the head, but with the result incremented by one."
4266240,4275440," And there we go. We achieved what we wanted to achieve. So now this function is tail called, right?"
4275440,4279920," So basically, the call, the request of call to the function is basically the last thing that you need"
4279920,4287200," to do. And the result is carried through the arguments of the function, right? So the result is not returned,"
4287440,4292880," but sort of carried through each individual call. And this is something that the compiler can"
4292880,4302640," finally optimize and not push stack frames. You see? So that's a tail call optimized function. And"
4302640,4307440," the way you call this function, right? And the way you call it. So let's actually use something like"
4307440,4313840," use. There we go. So this is going to be length tail. You have to provide one, two, three,"
4313840,4318560," and you have to provide the initial value for the result, right? So in case of empty list,"
4318560,4323440," it has to be zero. So that means the initial value for the result has to be zero. And there we go. As"
4323440,4328000," you can see, we have three elements in here. So if you have two elements, it's going to be two. If the"
4328000,4335360," list is empty, it's going to be zero. Right? So but it's not really convenient to have this extra element."
4335360,4344480," So what usually function programmers do, they sort of like talk the this function under another function"
4344480,4350560," that basically provides that that default element for the for the results. So let's actually call this"
4350560,4360160," thing length tail prime. And let's wrap it into length tail, which accepts only the least, right? It"
4360160,4368560," accepts only the least. And this one becomes the inner function that we just call with the default"
4368560,4373440," parameter zero. So you see in the camel, you can actually quite easily define nested function. And"
4373440,4379200," this function is not going to be visible like outside of this one, right? So the syntax of a camel is quite"
4379200,4383760," ergonomic in that case, because the inner function syntactically is not that different from the outer"
4383760,4391760," function. And it just can quite easily wrap everything. Right. So let's do use. And as you"
4391760,4399600," can see, everything works. And I can do now length tail 234. And there we go. So it works. But like,"
4399600,4406160," there's no difference between like, it's kind of difficult to observe the actual difference between"
4406160,4411600," like tail recursive function and not tail recursive function, because they behave the same. Right. So the"
4411600,4417280," implementations are slightly different, but they behave the same. And do we really improved anything? Did"
4417280,4425920," we really improve anything? Did we? I don't know, we can try to check that. Let's actually write a useless"
4425920,4436160," recursive function, like a useless iterative function, something like F, right, which essentially returns an"
4436160,4444720," integer. And what it does, it basically calls to itself. But it increments its results over and over again. So"
4444720,4450480," essentially, for this function to work, it needs to push things on the stack. And since it doesn't have the"
4450480,4464160," the base, it's gonna go into recursion indefinitely. And since it's not recursive optimized, it will stack overflow, right? Not everybody knows in 2021. But stack overflow is not a website, it's not only a website,"
4464160,4471840," a website is not only a website, but it's also an error that you can encounter if you're not careful with the recursion. Right. So"
4471840,4480640," I'm sorry. So yeah, let's actually try to see what's going to happen if we call this function."
4480640,4486160," It doesn't even compile. Okay, so because I forgot to mark it as a recursive one. So"
4487520,4495200," all right, so if I call this function, and boom, stack overflow during evaluation looping recursion, I really"
4495200,4504960," like how it asks the question looping recursion. Oh, I see what you did there, buddy. Oh, looping recursion."
4504960,4511600," Okay, so how can we make it, you know, tell recursive, right? So this is going to be"
4511600,4518480," f tail. And this thing is going to accept an integer instead, like results."
4518480,4526320," Right. And what it's going to do, it's going to just call itself, but with the result incremented by one, as you can"
4526320,4532880," see here, we carry the result, why the return, but here we carry the result, why the arguments, right?"
4532880,4535600," So but since this thing is the last thing that we call,"
4535600,4542240," it will be optimized and won't push any stack frames. And since it won't push any stack frames,"
4542240,4548160," it's basically going to loop forever and never going to stack overflow. Right. So let's actually do something like"
4548880,4558240," use, and I'm going to do f tail zero. And it's just hanging. It's just looping. It's a recursive"
4558240,4564240," function that keeps looping and looping and doesn't stack overflow. So we can clearly observe that one"
4564240,4569760," function pushes the frame on the stack. And that's why it's stack overflows. And another one doesn't push."
4569760,4572720," So this is how you can demonstrate the difference between these functions."
4576640,4581360," hash trace allows you to see the behavior of the function. I didn't know that. Let's actually take a look at that."
4581360,4585680," So can I do something like help trace, or whatever the fuck it is?"
4585680,4590080," I don't know. Okay, so trace foo."
4590080,4598480," I don't know how to use this function. I'm sorry. But I'm going to read how to use it a little bit later."
4598480,4604880," But anyway, we can actually observe the difference between the behavior just like that. Right. So one function"
4606480,4610720," overflows the stack and another one doesn't overflow the stack. And this is something that you can use"
4610720,4619040," even in not function languages. As far as I know, some of the C compilers, some of the C compilers"
4619040,4624720," also can perform tail call optimization. So let's actually see, let's actually try to apply the same"
4624720,4633200," trick in here. Right. So if we have something like this, one plus F, this entire thing is definitely"
4633200,4640000," going to stack overflow. Right. So it's 100% is going to stack overflow. If I do GCC, you know,"
4640000,4647680," main dot C and then I'm going to just run this entire stuff. So we got a bunch of gifted sub from the"
4647680,4654640," the bone hunter. Thank you so much. The bone hunter for five tier one subs and everyone who got the subs,"
4654640,4661360," welcome to epic tail recursive club. How about that? I know what the fuck is going with me. I think I"
4661360,4668560," drunk too much tea. So how are you guys doing? How are you guys doing? You're welcome. Thank you."
4668560,4671280," Thank you so much. Pretty appreciate it."
4671280,4681200," I just want you to say that your pasta combinator in OCaml is pretty fun to use. Is somebody using it?"
4681200,4688640," You're actually using it? Yeah. Some time ago, I implemented a pasta combinator in OCaml."
4690640,4695600," I don't remember. Parsa, uh, uh, parkour."
4695600,4704080," I forgot that I call it like that. It's like Parsa Combinator of Monat and parkour."
4706320,4712320," So, uh, okay. So my, my sense of humor didn't change apparently, um, over the years."
4712320,4723520," Thank you. Is, is that a donation? Just a second. I didn't expect, uh, the extra genius, um,"
4723520,4730720," subscribed with Twitch prime saying, I like camels. I also like camels. They're pretty cool. And that's"
4730720,4736560," why I program in Perl. Haha. Thank you. Thank you so much for, for, for the sub. Uh, so yeah,"
4736560,4740880," you can find this thing in, uh, in here if you're interested and I'm also going to put it in the"
4740880,4748080," description. I think, uh, I also did it on the stream some time ago. And, uh, so"
4748080,4758480," parser combinators of Monat in OCaml, um, in OCaml. So it's actually a very simple one, right? It's not as"
4758480,4764240," generic as a lot of parser combinators in Haskell, right? Because if you take a, at something like"
4764240,4772000," parsec, uh, if I remember correctly, so where's the hackage? Where is my hackage? Uh, to, to, to, to,"
4772000,4780560," parkum, src, parkum.ml. So this parser combinator, it, you can only parameterize the result,"
4780560,4787600," right? So, uh, the input is always the strength with position and the output,"
4788240,4792160," uh, is always the result and like the rest of the string and so on and so forth. So the"
4792160,4797440," only thing you can customize in here is the result, right? But if you take a look at something like"
4797440,4802560," parsec, uh, let's parse sec. Uh,"
4802560,4811680," arctum. Reshotka trace, name of the function allows you to follow the behavior of functions has a special"
4811680,4815600," behavior for tail recursive functions. Okay."
4815600,4821520," Thank you so much for 500 bits. Uh, let's give it a try. Um, so, so I just have to do it like that."
4821520,4828160," Name the name of the function. Okay. It's just the name of the function is now true. Oh, is now traced."
4828160,4834720," And then I just call this font. Okay. Okay. And it's just like, keep, keep, keeps looping and I can't,"
4834720,4842880," I can't stop it. Ah, okay. It's stopped. Uh, well, it's not tail recursive. Okay. So if we trace tail"
4842880,4850720," recursive one, right. And it's going to be tail, uh, zero, uh, and it even shows the, uh, arguments. Okay."
4850720,4857840," That's actually pretty cool. Okay. Oh, oh, I know why it takes so much time because when you control"
4857840,4864560," C it rises the exception and exception needs to go through the entire thing. Oh, it keep printing."
4864560,4871680," Oh my God. That makes sense. It's just basically printing like everything that, yeah. So it's"
4871680,4876160," basically the stack trace since it's a recursive. Okay. That's actually pretty cool. Thank you so much,"
4876160,4880640," Arctum. I didn't know about that. So that's very, very useful. I'm going to use that from now"
4880640,4885840," on, uh, thank you. Thank you. Thank you. All right. So what I want you to say is that in"
4885840,4890400," case of a parsec, all right. In case of a parsec, if you take a look at the parser committed that they"
4890400,4896560," they defined, you can customize pretty much everything, like every aspect of the parser"
4896560,4903840," combinator, right? So if we take a look at the, uh, at the definition, right? So you can customize not"
4903840,4910400," only the, uh, the return, right? A you can customize the monad that is going to be used,"
4910560,4914320," right? In case of parking, the only monad you're allowed to use is result. But if you want to have"
4914320,4919280," a different monad, well, you cannot do that. In parsec, you can do that. You can customize the"
4919280,4924320," input, the output, and so on and so forth. And that's why it's so complicated. It has a lot of like"
4924320,4929760," these weird things. Like it's super generic, super like customizable and stuff like that."
4929760,4936080," My parsec, you cannot do that. That's why it's so small, so simple, and probably so fun to use because"
4936080,4940880," it's not particularly customizable, right? But this is like a trade-off that you have to have to take"
4940880,4948000," because it's kind of difficult to make such a generic thing in a camel, uh, without like type classes and"
4948000,4956240," stuff like that. Yeah. So I cut a couple of corners to implement this thing in the camel."
4956240,4966000," Uh, all right. So, uh, let me, let me see, let me see. So we wanted to see if the, uh, C compiler"
4966000,4971680," actually optimizes anything in terms of like a tail recursion, right? So here is the not tail recursion"
4971680,4983760," function. Hmm. Let's see if it is going to, um, you know, a stack overflow, um, main that scene is"
4983760,4989360," going to be main, uh, yeah, segmentation fault. So I would assume that segmentation fault will mean the,"
4989360,4995680," um, stack overflow. So maybe it would be nicer to do that with clank, uh, and clank"
4996800,5005200," sanitize memory flag. Um, right. F sanitize, uh, memory. So I suppose it will tell me that"
5005200,5013280," we stack over flu. If I provide this flag, hopefully, hopefully it will tell me, uh, so there we go. So"
5013280,5019440," stack overflow. So now we can like clearly see that it's stack overflow. So if I turn it into sort of like"
5019440,5025840," a tail recursive one, so here's the result and result is going to be simply plus one. Uh, right. So this is"
5025840,5030640," going to be zero and let's try to run this entire thing. And as you can see this, uh, stack overflow as"
5030640,5037840," well. So, uh, the compiler didn't optimize anything, but the question is what if we crank up optimization to"
5037840,5046640," all three? Will it do a tail, uh, call optimization? What's interesting is that it basically illuminated the"
5046640,5056160," entire thing. Thank you, Clank. Very cool. So it's supposed to actually hang, but it didn't hang because"
5056160,5060800," you never use the result of this thing. So it just eliminated the call. Like, I mean, it turned into a"
5060800,5067120," lazy language, right? It straight up turned C into Haskell because this is what would happen in Haskell,"
5067120,5071200," right? You don't use the result of the function. Well, it's, it's, it was never be called. Uh,"
5071200,5078400," right. Pretty cool. Thank you so much. So you don't need GHC to have Haskell. So we can try to print, uh, the,"
5078400,5086240," the result of this thing to sort of force, uh, the, the compiler to not eliminate, uh, the entire stuff and"
5086240,5094640," it printed something. That's, that's what's interesting about it. It actually managed to print something."
5100480,5113120," Thank you very cool. Um, so yeah, very cool. Yeah. I mean, we actually did all three,"
5113120,5118080," which is like very aggressive optimizations, but I guess in this kind of situations,"
5118080,5123440," the optimization is too aggressive. Is it different every time? Uh, yeah, it is different. So it's"
5123440,5130400," probably printing like a random garbage from the stack. I would presume. Um, so maybe that's what it's doing."
5130480,5141440," Um, uh, God bolt, um, um, to, to, to, to, to, so let's take a look at what kind of garbage did it"
5141440,5150960," generate this time. Okay. So, uh, clang, uh, I don't know what's my version of clang to be fair,"
5150960,5157600," so maybe I'm going to just choose, uh, like the latest one or whatnot. So what is it doing?"
5158880,5164640," Uh, to, to, to, to, to, uh, LDR push."
5164640,5176720," Oh, it's our, holy shit. Okay. So I'm an idiot. Uh, or maybe God bolt is not as convenient as it"
5176720,5188080," should be. Maybe it's not me who's an idiot. Oh, very cool. Um, okay. So in main, we jump"
5188880,5198320," back to here. Well, we supposed to loop, right? So, uh, let's maybe use the, uh, the clang that I have."
5199520,5207200," This is not how you do version. This is not how you do version, uh, 701, right? I have a pretty old one"
5207200,5209040," because I'm on dipping."
5211840,5221680," Now that looks like something. Okay. So we push in racks, uh, EDE. Okay. So this is the, uh, the string"
5221680,5230960," we push in the string. Uh, uh, huh. Oh yeah. So essentially it prints. So the second argument as far"
5230960,5241760," as far as now is RSA, right? So, um, um, x86, 64, like system V, uh, call convention. So we'll get a rate"
5241760,5247040," from provost. Uh, thank you. Thank you so much for the rate. How was the stream? Uh, we're just doing"
5247040,5259520," some weird shit. Um, um, so as far as I know, it's first RTI and then RSI, right? So what's the second"
5259520,5264960," argument? Does anyone remember? What's the second one? But I suppose the second one is not even present"
5264960,5271440," there. So basically it will print a random garbage from the, from the second argument register. So"
5271440,5278400," that's basically what it optimized to, um, is this for ports? No, it is not for ports. We're just exploring"
5278400,5284800," how C compiler may potentially perform tail call optimization. That's what we're doing right now."
5284800,5292800," Uh, so we were just discussing the tail call optimization and we just want to see if any of"
5292800,5298960," the compilers actually performed them. So we did this thing. And what's interesting is that clang"
5298960,5307360," on like clang specifically of the version 7.0, uh, with 0.3, it illuminated this call completely."
5307360,5313840," It illuminated this call completely, but it didn't illuminate, uh, print F. So basically it's printing"
5313840,5321040," a random garbage from, I would presume RSI, right? So the first argument is RDI. The second one is supposed"
5321040,5330240," to be RSI, but RSI is never set anywhere because second RSI I presume was eliminated. So nice one clang."
5330240,5338880," Thank you very much. Uh, isn't the code an infinite loop? Yes, that's the point. Uh, and I would expect it"
5338880,5345200," to actually loop indefinitely, but the infinite loop was eliminated. Uh, and now print F just prints a random"
5345200,5353840," garbage from the, from the registers, so LLVM is so smart. Well, uh, in defense of LLVM and, um,"
5353840,5359360," clang, we're using the pretty old version of the compiler, right? Because that's the version on my"
5359360,5364480," old Debian machine. So the latest one actually produces something more reasonable, right? So the"
5364480,5370880," latest one produces straight up infinite loop. So it's jumped to itself, which is precisely what I meant"
5370880,5377200," here. I believe it or not. It even eliminated print F the seventh version eliminated the loop, but"
5377200,5382800," didn't eliminate print, eliminate print F the latest one, eliminate print F, but didn't eliminate the loop."
5382800,5388000," And so this is closer to what I actually meant in here, right? So it's closer to my original intentions."
5388000,5395200," Can you show all one on which compiler, uh, on the old one or a new one? So let's take a look at the old one."
5395200,5406560," So, uh, this one, oh two. Um, oh two is the same shit. Uh, oh one. Oh, one will probably."
5406560,5419920," Oh zero. What about those you. Oh zero. Now produces something reasonable. Like, I mean,"
5419920,5428080," it's just that didn't apply any optimization. So it's just like straight up. Uh, so anyway, uh,"
5428080,5432560," we just were talking about tail call optimizations because we were doing a functional program."
5432560,5437840," Boys and girls, we're not programming in C right now. We're programming this, uh, people who came"
5437840,5445120," from ProVot who knows what this language is. So new people who came from ProVot, what is this language?"
5448080,5453200," Okay, somebody knows this language. Yes. And what we're doing right now, we're solving 99, uh,"
5453200,5458080," OCaml problems. So that's the topic of today's stream. It's not a SML. It's OCaml actually."
5458080,5467440," Right. So the, uh, Godbolt thingy was just basically a tangent. The main, um, the main topic of today is"
5467440,5473280," actually, you know, solving 69 OCaml problems. You can find the source code of the solutions in here."
5475120,5484960," Um, all right. So, oh yeah, that's pretty cool. Okay. So, uh, we looked at two different solutions,"
5484960,5490960," right? The first solution is, um, recursive one. And the second one is a tail recursive one,"
5490960,5498320," but not a single function programming programmer. We'll talk about the third solution."
5499120,5501280," Who knows the third solution?"
5501280,5509280," Not everybody knows. Well, I mean, the functional programmers know about that,"
5509280,5516480," but they will never tell you. But in OCaml, you can have, I think, while loops, right?"
5517840,5526400," Um, loop and the recursion, I think, do you have while loops or for loops looping over lists?"
5526400,5537760," Uh, uh, uh, uh, uh, I think there's only, uh, for loops in here, right? So if I try to do something like,"
5537760,5545760," while there is a while, there is a while. Okay. So let's actually call this best, uh, length. Right."
5545760,5551360," So this is going to be access, uh, a, uh, list. And this thing is going to be like this, right?"
5551360,5558160," One thing in OCaml is that even though it's completely immutable and completely functional"
5558160,5563440," and so on and so forth, you can define mutable variables in there, right? So you can define"
5563440,5570720," variable result and it's defined through a feature called the ref, right? So you define the ref zero, right?"
5571760,5579040," Uh, and, um, then you can have your list, uh, defines, uh, also in the ref, right?"
5579040,5584480," So, and one of the things you can do, you can basically have an imperative loop,"
5584480,5593360," an imperative loop that basically loops while the list is not empty and imperatively increments the"
5593360,5598640," result and then just returns the result when it's done. So this is the third solution that not a single"
5598640,5602960," function programmer will tell you about, but I'm going to tell you because I'm not a function"
5602960,5608080," programmer. I'm a Python developer, right? So I'm going to tell you that little secret that you can"
5608080,5612880," do this kind of stuff in OCaml, but I forgot how to use while loops. Okay. So this is how we do that."
5612880,5619920," You do while true do blah, blah, blah. So if I remember correctly, uh, to read a value from a ref,"
5620480,5626720," you actually use exclamation mark mark and you sort of dereference it. So you basically read this entire"
5626720,5634720," thing and then, uh, you can check if this entire thing is equal to an empty list while this thing is"
5634720,5651360," not an empty list. Do result equal result plus one, and then wise equal, um, wise list, uh, I think tail,"
5651360,5658720," right, uh, list tail, and then done. There we go. And after that, you simply return whatever you have in the result."
5659680,5666160," So this is the third secret solution that nobody except me will tell you. I wonder if it will compile"
5666160,5673520," actually. You can see. Okay. So user, and it does not even compile. Oh yeah. Because you have to, if you"
5673520,5678480," have like a, um, you know, imperative statements, if you have imperative statements, you have to separate"
5678480,5684720," them with semicolons, right? You have to separate them with the semicolons. There we go. So if I use now best"
5684720,5696400," length, uh, right, if I use best length, um, one, two, three, it also works. It also works. So this is the best"
5696400,5708080," way to compute the length of the list in a camel. This is the best one. So, all right, uh, let's do a"
5708080,5718800," committee committee and maybe even push it, push it, uh, at, uh, solution to problem zero four. And I'm"
5718800,5724720," going to push that right into the repo and the repo is a public. You can find it in here. And if you're watching"
5724720,5730720," on YouTube, uh, you can find, uh, the repo in the description, it's the first link in the description."
5730720,5742960," So, uh, okay. Okay. So reverse list. This one is interesting. This one is interesting."
5742960,5753440," Uh, how do you even reverse a list? Well, you can use wild. Oh my God. I just got the perfect idea."
5754320,5763600," Holy shit. Here's an idea. Solve all of the 99 OCaml problems in OCaml in imperative style using"
5763600,5769040," mutable variables, for loops and while loops, and just like promote that shit on all of the social"
5769040,5774880," media to piss off all of the functional programmers. That's beautiful. I want to do that now. Holy shit."
5774880,5777440," I want to solve all of them in imperative style in OCaml. Yes."
5777440,5798720," I don't know. I'm, I'm too tired to be fair. Um, I'm kind of too tired for this kind of shit. Too old."
5798720,5808000," Um, I already have enough people telling me that I'm programming things wrong. So, uh,"
5808000,5827280," you can kind of reverse the list by doing the accumulator thingy. I think, uh, because once you"
5827280,5836560," push into a accumulator, you sort of push things in the reversed order."
5836560,5840960," Hmm. All right. So let's go ahead and do that. And maybe this is going to be the last problem"
5840960,5847520," because I'm feeling a little bit tired already. So yeah, let's do this as a last problem. And, uh,"
5847520,5853440," then we're going to wrap things up and I'm going to think about, you know, uh, 99 kind of problems,"
5853440,5860160," but imperative style, and by the way, so maybe I can even stream that because, uh,"
5860160,5865840," imperative for camel is easier for people to understand than the functional one. Uh, right."
5865840,5871680," Because it's just, yeah, it's just like Python. It looks kind of like Python. Um, so,"
5874000,5883200," okay. Uh, so this is the, uh, list is actually a list and we can have something like an accumulator,"
5883200,5888640," right? So it's going to be like that. And then we're going to return this list. So we're going to"
5888640,5896640," match access. Uh, and if access is empty, we're just returning the accumulator. If it's not empty,"
5896640,5906000," uh, right. We do a reverse, uh, where we provide the rest, but we append X to the accumulator."
5906000,5914480," So here's the thing. So essentially, um, how do we work with all of that? Uh, I wonder if I can just"
5914480,5922640," use, I think I can use tracing to demonstrate how this entire thing works. So yeah, thank you so much,"
5922640,5928880," uh, Arctun for, um, teaching me about trace, because I think I would be able to use it to demonstrate how"
5928880,5936560," this reversing is actually works, because what it does, it chops off the head of the axis and pushes"
5936560,5942560," it into the accumulator on each iteration. So basically like push and pop and push and pop, push and pop."
5942560,5948320," And that's why it's like a reverse. It's like having two stacks. If you pop from one stack and push to"
5948320,5955440," another one, the, uh, second stack will be reversed version of the first one, right? So, and this is"
5955440,5960800," basically the same situation. And I wonder if I can actually demonstrate that with a trace. Uh, so let's"
5960800,5968000," gonna do use. And, uh, of course I forgot to mark this entire thing as a recursive one, uh, use one more"
5968000,5977120," time. And if I try to reverse one, two, three, four, uh, five, it will, um, oh yeah, I forgot to actually"
5977120,5982880," provide the empty list. There we go. So as you can see, the result is actually reversed, but the way it"
5982880,5988720," works, uh, like towers of Hanoi. Yeah. It's kind of like towers of Hanoi. So essentially you have two towers"
5988720,5993920," in here. The first one is an input and the second one is a accumulator, right? So when you just like push"
5993920,6001840," into another one, uh, can we try to do trace a rev? Uh, right. So rev is now traced. And if I do one,"
6001840,6019520," two, three, four, five. Oh yeah, of course. Okay. So, uh, poly, poly, poly doesn't really tell me much."
6023920,6026800," Okay. Um, it's very cool."
6026800,6034560," A roly poly, roly poly, poly poly wants a crack."
6034560,6046320," And it's cool. Um, we can try to maybe, uh, is this because it's carried? Probably."
6049440,6055040," Ah, this is the special behavior. Oh, okay. I see."
6055040,6062480," What if we make it uncurried? So can we try, well, in case of making it uncurried,"
6062480,6065920," will it be still, yeah, it will be still, uh, like recursive or something."
6065920,6076320," Okay. So we can try to do that. So it's going to be access, uh, and we're going to just do it like"
6076320,6084400," that. Right. So if I try to do it like that, will it give me more, uh, information about this thing?"
6084400,6092480," Probably not. It's just probably not. Uh, and then if I do reverse, uh, this is going to be the rest."
6092480,6098880," And, um, yeah, use, uh, and now if I call this thing, uh,"
6101600,6108080," yeah, uh, I forgot to trace forever. Probably not. It's probably not going to. Yeah. Well,"
6108080,6114400," this is a little bit better. So that's at least something that I want to see. I would like to see"
6114400,6122160," the actual elements in there. You know what? Poly, it's probably polymorphic argument. That's probably"
6122160,6130960," what it means. It's a polymorphic argument. Can I make it print actual values? If I specify that"
6130960,6138880," these things has to be integers. Okay. So that's probably something that we can do. So let's reuse"
6138880,6145040," this entire thing. Let's trace that thing one more time and then do it like perfect."
6145040,6153440," You can now clearly see the whole dynamics of the language you see. So here is the first argument."
6153440,6160400," Here is the second one, right? So in here on each iteration, we chop off the first element from the"
6160400,6166240," axis and we add them to the accumulator. And once we reached the end, we just return the accumulator."
6166240,6172960," So look, here's the list. We take one and push it to the accumulator. Then we take two, push it to"
6172960,6178640," accumulator, uh, three, push it to accumulator, uh, four. And until this thing becomes empty. And as"
6178640,6183520," soon as it becomes empty, we return the accumulator. So this is how we reverse it. So I really like that"
6183520,6188800," I can actually visualize that process because this is how I see that in my head when I'm writing this"
6188800,6192560," kind of recursive things, but it's kind of difficult to explain what's going on in here. And I'm really"
6192560,6197840," glad that with the trace that I can at least show what I have is going on. This is actually very cool."
6197840,6211680," So, uh, yeah, uh, to, to, to, to, to, to, to, so yeah, that's pretty cool. Um, uh, to, to, to, to, to,"
6211680,6218960," and I'm going to do a committee committee and then push, push, add, uh, solution, uh, to problem,"
6218960,6225040," uh, problem zero five. And I'm going to push that right into the repo. Okay. So I'm already a little bit"
6225040,6230960," tired already. Um, we managed to solve five problems today, but to be fair, majority of time,"
6230960,6236400," we were primarily discussing functional programming and different concepts and functional programming"
6236400,6241920," and optimization and stuff like that. So today's stream was not about solving these problems,"
6241920,6247760," but more about discussion of functional programming, which I find, which I find to be very productive."
6247760,6253200," I think today's stream was very productive and I hope it was very educational for, for people who only get"
6253200,6259120," into function programming. All right. So I guess that's it for the day. Thanks everyone who's watching"
6259120,6264000," me right now. I really appreciate it. So we're going to have more port streams in the future. So it's just"
6264000,6271680," like a, you know, random chill stream, uh, to get like a break from, from port. Uh, and then, um,"
6271680,6276800," yeah, I'm going to go. Thanks everyone for watching. Really appreciate that. Uh, thank you for all of the"
6276800,6284880," subscriptions, donations and bits and stuff like that. Um, especially appreciate that. And let's maybe"
6284880,6291600," rate somebody because we got rated by, uh, Mr. Provod. So maybe we want to rate somebody back."
6292480,6309200," So is anyone streaming any functional programming on the, uh, software development section of Twitch?"
6309200,6321200," Okay. Uh, so we already rated supiniq. So maybe we can find, uh, somebody else."
6323360,6329920," Uh, D for highness, I guess. Uh, so who's D for highness? Is that somebody who's doing function"
6329920,6334240," programming? Uh, are they doing function programming? If they didn't function programming,"
6334240,6341200," I'm actually down to read them. Uh, recursive Twitch. Yeah. It just goes recursively."
6343040,6352000," Let's broke my team. The fuck. Um, it's makes it really painful to rate people like, holy shit."
6352000,6360160," Uh, so, so it looks like their life. I hope. What are they doing? So what is this language? I don't"
6360160,6368960," recognize this language. Um, it's a shell script. Oh, building blockchain on a camel. Okay. This is"
6368960,6376000," perfect. Let's actually rate them. Um, okay. Blockchain in a camel. Holy fucking shit."
6376000,6381760," Mind gut. Unbe fucking livable. All right."
6384800,6391040," I wish Twitch was a little bit faster. Uh, cool. Um,"
6391040,6398480," I already pressed the rate command and it's still being slow. Uh,"
6398480,6404880," come on. You can do that. Twitch. Come on. Okay. I believe in you. It's already showing,"
6404880,6409840," but it doesn't show me the button yet. That's how slow it is. All right. Get ready for the rate,"
6409840,6424240," boys and girls. Get ready for the rate. And I see you all, uh, next time. See you all next time. Love you."
