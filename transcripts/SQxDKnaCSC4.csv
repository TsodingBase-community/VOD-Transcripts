start,end,text
960,9280," um okay so now let's take a look at something uh very interesting so it's some problem uh that i"
9280,17200," had for quite some time right so uh let's try to implement um a procedure that copies a chunk of"
17200,22960," memory right so let's implement mem copy something that we call mem copy in the industry so this is"
22960,31120," going to be mem copy uh it's not really port right it's rather port there we go so this is going to be"
31120,38080," something like this so we're going to include i think i already have a mem copy um mem copy in"
38080,47360," the standard library so let's actually not include it then um okay um so um mem copy is going to accept"
47360,51760," three arguments it is going to accept the size of the memory chunk that you need to copy"
52480,58320," uh so and uh then it's going to accept the source right the source of this thing and then the"
58320,67120," destination right so it's going to copy uh the memory from here to here so and um implementing"
67120,75520," such um such procedure without any local variables it's kind of difficult actually uh knowing like"
75520,81680," having all of the all of the operations that you have all the intrinsics to work with stacks like"
81680,90000," duplicate uh swap and so on and so forth it's kind of difficult to juggle uh three arguments simultaneously"
90000,96720," so the way i actually implemented that is i uh allocated um a bunch of like um variables right so"
96720,104480," i basically offloaded the uh two these two variables to um to a separate memory so we're going to have mem"
104480,110640," copy um src right and since both of these things are pointers uh we're going to provide the size of the"
110640,115600," pointer right so it's going to be something like this and this is going to be dst so both of them"
115600,120080," are size of the pointer since we don't have the standard library i'll have to define a constant"
120080,128480," myself uh size of ptr and uh the size of the thing is going to be eight there we go right and the first"
128480,134720," thing i want to do i want to actually save uh the arguments into that thing uh so it's going to be a"
134720,140080," 64 right so we take destination and then we're saving this thing in here then we take the source"
140080,146000," we're saving this thing in here and after that on the stack we're going to have only the size so we"
146000,152640," sort of like simplified this stack a little bit for us by uploading the arguments to to the memory right"
152640,159920," so after that we should be able to quite easily iterate uh like n times or rather size times so we're"
159920,166880," going to define a loop uh while duplicate is uh greater than zero we're going to keep looping and"
166880,173040," we're going to be uh subtracting uh we're going to be subtracting one from uh from the current index"
173040,181280," all right after that uh i need to grab the source right so that gives me the pointer i uh read that"
181280,187280," pointer so it gives me the value that i will probably have to cast to the pointer and then i read the"
189920,196880," first character from the uh from the source and then i go and grab the destination i read the value of"
196880,203360," the destination i cast it to the pointer and i'm writing the red character into here right i'm writing"
203360,209120," this character into here and after that i can just go ahead and increment the source by one and the"
209120,217920," destination by one right so and after that uh we only have the zero at the uh at the top of the stack and"
217920,223200," i can just straight up drop it and there we go we implemented mem copy right we implemented mem copy"
223200,231440," but there is a huge problem in here uh right it um uses this uh global memory region which actually"
231440,236560," pollutes the namespace right it but it's the name space and on top of that it's like not part of the"
236560,244400," stack it's not like a local variables so clearly you kind of need local variables to comfortably um to"
244400,251840," comfortably develop functions that accept a lot of arguments right so and um the question is how can we"
251840,260560," do that well as far as i know recently i learned that um fourth allows you to use not only the data stack"
260560,269840," but also the return stack so here's an interesting thing in fact in both uh fourth and port uh there are"
269840,276160," there are two stacks the first one is a data stack and the second one is the uh return stack which stores"
276160,283200," the return addresses every time you call a procedure right every time you do a mem cp cpy we push the next"
283200,290720," address after mem cpy to the return stack and then we jump in here execute and when we reach the end we"
290720,300720," jump back uh to the address that is in return stack so fourth actually decided to allow the programmer to"
300720,310080," push values on the return stack right so as far as no uh like fourth uh return stack right so return stack"
310080,316720," it has a special intrinsics that allow you to basically exchange the values between the data stack and the"
316720,325200," return stack so and because of that you can use the return stack as the location um as the location for"
325200,333120," the local variables right so um essentially in port you would just push src and dst to the return stack"
333120,340000," then you will be keep iterating bringing src and dc dst from the return stack modifying them and pushing"
340000,348400," them back to just increment uh the uh the size and until you like finish the entire thing um so which"
348400,357760," is actually pretty cool idea and um but i had a slightly different idea i was thinking what if we"
357760,368000," go ahead and allow uh the programmer to define the uh memory locations inside of the procedure it is"
368000,375200," possible right now you can define memory locations inside of the procedures but what if you do that"
375200,383120," it actually makes them local and it allocates them in not in the global bss section but on the return stack"
383120,388720," and then once you return whatever memory you allocated on the return stack is going to be"
388720,394960," automatically cleaned up so it basically implements local memory regions"
394960,404960," so and that way we can also make it so in terms of the namespaces uh in terms of analysis we can get rid"
404960,411360," of the prefixes and actually uh you know uh make them local to that specific procedure"
413040,420320," uh to that specific procedure there we go so uh yeah it's kind of similar to the uh like pushing"
420320,425280," values on the return stack it's just like you have a little bit more control of the things that you can"
425280,430640," put on the return stack as far as i know in fourth you can only push the values of the size of the word"
430640,437200," on the return stack which is kind of understandable i suppose because fourth it works in a very weird"
437200,443840," embedded architectures maybe where uh you could have some weird uh memory access limitations and maybe"
443840,448880," because of that like um you want to restrict the size of the things you can push on that stack but i"
448880,454000," don't think we're going to encounter such situations so why not allow um this kind of thing"
454000,459200," and in the future once we have the variables right so you're literally going to have like a local"
459200,463920," variables of a particular type which are allocated on the return stack and it's just like basically"
463920,471520," behaves like local variables and um yeah so i think that's pretty cool so and i'm thinking uh implementing"
471520,477680," the ability to push values on the return stack is actually super easy and will kind of temporarily"
477680,485040," solve the problem with local variables for now right um but having local memory regions is a little"
485040,492080," bit more complicated but yet i think it's a little bit more convenient to use because you have specific"
492080,498480," names associated with the region memories uh memory regions right so you have a specific value called"
498480,503200," src specific like name called dst and it's just like overall a little bit easier to work with"
503200,510800," so and i'm thinking so which one i want to do which one i want to do i want to do the fourth way"
510800,517040," or do i want to do you know the mainstream way because this is more like a mainstream local variables"
518240,525600," so i'm thinking i'm thinking and thinking and i kind of want to try the local memory regions way"
525600,530320," i kind of want to try the local memory regions way i think it's going to be kind of cool"
530320,537680," shouldn't be really difficult to implement it may require introducing a bunch of operations to the"
537680,543760," intermediate presentation right so we definitely need we'll need to introduce a new operation that allocates"
543760,550560," uh a size like a chunk of a memory of a particular science on this stack so it's going to be new uh"
550560,557600," opcode in the intermediate presentation and accessing like pushing the pointer to that region"
557600,566000," is also going to be a separate um separate opcode because the regular opcode that pushes the memory it"
566000,571760," actually pushes it relative to the global memory so for the local one you will have to generate a little bit more code that"
571760,577280," retrieves the current uh position of the stack the current size of the stack and calculates the things"
577280,584080," and only then pushes the pointer on the stack so we'll need to introduce at least two new opcodes uh to"
584080,592080," the intermediate representation with the uh operations that push values on the local on the return stack"
592080,599280," we only will need to introduce like two intrinsics which is kind of the same which is all also kind of"
599280,604800," introducing new opcodes because each individual intrinsic is basically like uh allocated space in the opcode"
604800,611760," space so uh yeah i think these kind of solutions are equivalent in terms of the difficulty of implementation"
611760,617280," i think they're kind of like equivalent in terms of the difficulty and because of that i want to try to"
617280,619760," go the local memory region route"
619760,631040," so and that way by the way we have we're going to have like a proper like stack things and it will make"
631040,634880," it like easier to have recursion right"
634880,640240," though we have a little bit of a problem with recursion"
640880,646960," tap checking doesn't really work with the recursion right now uh but anyway so let's go ahead and try"
646960,654640," to implement local memory regions how about that how about that so i'm going to try to go ahead and"
654640,661200," compile this entire thing so we have a mem copy example right it's going to be ports.py and i'm going to"
661200,668240," compile mem cpy dot port and it doesn't know about increment 64. okay so i already have a mem copy"
668240,676080," in the standard library so if i just include the standard library uh it's not going to compile so i"
676080,682160," probably want to rename mem cpy to something else right i want to rename some uh this thing to something"
682160,689440," else that's actually called mem copy uh right mem copy and see if we can compile this entire thing"
689440,695040," and it compiled it's successfully compiled because you are allowed to uh define memory regions inside"
695040,699600," of the procedures it's just like they're going to be global right so this entire thing is going to become"
699600,707520," global uh right one of the things you want to do in here is um just go to the compiler right and change"
707520,717600," the way we parse things so parse.py so parse uh program and if we encounter uh memory right if we"
717600,728000," encounter memory in here we may always check whether we are inside of the proc or outside of the proc"
728000,735200," right because we keep track of uh of that literally we keep track of that so we have a variable called"
735200,741600," current proc right current proc and it's optional so it can be none none means you're defining globally"
741600,747600," but it had if it has an operation address that means you're currently defined inside of the procedure"
747600,751680," right you're currently inside of the procedure and this is the way we can actually check for that"
751680,760640," right so you're defining the memory and we can assert that current uh procedure is none so uh local memory"
760640,767840," regions are not uh regions are not supported there we go and i'm going to try to compile this entire"
767840,774800," thing and as you can see here we go we hit that assertion so and if i move this entire thing outside"
774800,779520," of the procedure it will perfectly compile so as you can see we can easily detect whether we have a memory"
779520,785920," outside of the procedure or inside of the procedure that's pretty straightforward cool so and if we have the"
785920,792160," memory inside of the procedure right so we have to do this kind of stuff slightly differently maybe"
792160,797680," it's actually very interesting so we probably want to do uh keep doing the same thing we still"
797680,802640," want to parse the name we still want to parse the location check for the work really well checking for"
802640,808640," the word definition is kind of is going to be kind of kind of interesting um so we also want to"
808640,817840," um maybe pre-evaluate this size right and only somewhere around here we want to distinguish whether"
817840,825760," it's a local um memory word or a global one you see what i'm talking about like only then we want to"
825760,830400," uh we want to try to do that okay so here's the current um proc"
834480,843600," here's the current proc if the current proc is um none we check for the redefinition as usual and we"
843600,850400," just add global memory addresses right so these are global memory addresses as a why otherwise we're"
850400,862880," going to do assert false um to do local memory uh regions are not implemented yet right they are not"
862880,870400," implemented yet and they are in fact not implemented yet so how are we going to approach this entire stuff"
870400,878640," so we may try to uh extend the procedure right so we may try to extend the procedure so in the procedure"
878640,884320," we have an address operation address where this entire thing is um you know located in the program"
884320,892240," and location in the source code we may try to introduce something like memories right so here are the memories"
892880,896400," in the memory could be just a dictionary uh right and memory could be just a dictionary uh right that"
896400,904080," maps a particular name it maps a particular name to um i suppose memory of set as well right it could"
904080,913840," be also memory of set since the um since the end since the beginning of the frame i suppose right"
913840,923760," uh and uh maybe we can just go ahead and just put a memory in here so these are local memories we might as"
923760,932560," well call them local memories literally right and uh if we are current uh proc right so for our current proc"
933680,944320," uh we may wanna uh add the memory not uh not to like the global space but rather to the local space of"
944320,950320," the procedure right and but we don't have the current procedure because the procedure is actually created"
950320,957600," afterwards once we reach the end right and the current procedure current proc does not point at the"
957600,965200," current procedure object it points only at op address which makes it kind of inconvenient in my opinion so i"
965200,972720," think current proc has to be not optional op address it has to be optional procedure see what i'm talking about"
982160,991280," okay so and let's run the uh the type checking right so it's gonna be my pie and let's go through all the"
991280,999760," uh type checking stuff so current proc uh if the current proc is dead uh we are assigning this ip"
999760,1007760," so maybe i want to do something like a proc um is it address i think i think it is address so this is"
1007760,1020160," in the class uh it is in fact address so here is a proc ip um so we also have a token lock uh proc location"
1020160,1026400," which is basically like token uh location but i'm not really sure so we're already redefining the token in"
1026400,1034880," here uh which is fine i guess so maybe we're gonna put this thing in here right so it's gonna be token um"
1037440,1047120," yeah proc lock proc proc name check for the redefinition and only then we define proc uh proc name and so on"
1047120,1053120," and so forth but this is only for the oh boy this is only for the"
1053120,1065040," for the end isn't it this is only for the end"
1067120,1076720," okay so we're redefining it like that just a proc name uh okay so i see what needs to be done so we"
1076720,1084320," need to also do current proc uh procs proc name so we want to actually keep track of the uh of the"
1084320,1089920," pointer to that specific procedure all right to the pointer of that specific procedure so let's go ahead"
1089920,1096880," and uh recompile it one more time uh so miss missing positional and then we're going to have local"
1096880,1102720," memories uh and this entire thing is going to be so local memories is the dictionary so it's going to be"
1102720,1111600," like empty one uh okay cool uh unsupported operand types uh plus for these kind of things so the current"
1111600,1122960," proc proc um so i suppose it has to be more of a proc address yeah it has to be more of a proc address"
1123920,1131600," uh anything else no overload variant for this thing uh proc address"
1131600,1144480," so we need a proc address in here which is rather interesting so maybe"
1146480,1157680," uh i see i see so we'll have to use current proc uh current proc uh address but since we have the um"
1157680,1163680," the location we can just collapse this entire thing into just that"
1163680,1170720," right so we can just take a current proc location we know it's that it's not none and that should be"
1170720,1180720," fine anything else okay so that's that's fine okay that's cool uh that is very very cool uh stack append"
1180720,1186320," preparation of our nation and everything seems to be okie dokie karaoke"
1186320,1198720," so uh now uh let's go ahead and try to run this one more time right so we are uh gonna run it one more"
1198720,1206880," time uh and now we should be able to add the memory region to the local memories right so we should be"
1206880,1215200," able to do that um relatively well uh so we're gonna check for the word redefinition right we're checking"
1215200,1221280," for the word definition and interestingly enough interestingly enough um"
1224160,1236240," we want to be able to redefine all these words okay so maybe i'm gonna just basically do the same thing"
1236240,1244240," but instead of memories i'm gonna use the current proc memories okay so because we want to be able uh to"
1244240,1252080," allow the local memory regions to redefine the global ones do we do we want to be able to do that i think so"
1252080,1259760," actually if you think about that uh so they basically will over like shadow them um so the local memory"
1259760,1266960," regions should be able to shadow the global ones or maybe not i actually don't know maybe should they"
1266960,1275200," allow to shadow that um should they allow to shadow that um"
1275200,1286640," so what's what is easier to implement i think it is easier to implement right now to allow them to shadow"
1286640,1292320," that so maybe that's precisely what i'm gonna do uh and maybe later we're gonna you know disallow that who"
1292320,1304640," knows um so so this is gonna be to do so uh local uh memory uh regions uh can shadow the global ones the global"
1304640,1316720," ones uh the question is um is that something we actually want so that's a good question is that something we actually"
1316720,1323040," want i have no idea uh okay so we have uh memory capacity in here and"
1323040,1332000," so in a global way we just keep track of the global like program memory capacity in case of a procedure we"
1332000,1339040," want to keep track of the um of its local memory capacity i think so and this is going to be actually"
1339040,1346240," very useful because it will let us know how much we'll have to deallocate at the end of the procedure"
1346240,1349600," right so when we reach the end of the procedure we'll have to deallocate everything that was"
1349600,1355680," allocated on the stack and since we keep track of the capacity of this entire thing uh we kind of we"
1355680,1364080," kind of know what to do right so that makes sense to me that kind of makes sense to me uh okay so that means"
1364080,1371840," i need to go to uh proc uh so here is local memories and here's the local uh memory capacity right so it's"
1371840,1384400," going to be an integer uh local memory capacity and in here we want to do um prox uh actually current"
1384400,1393840," proc right so here is the current proc uh current proc memories right current proc memories memory name"
1393840,1406560," memory name so memories memory uh memory name and i want to create a new memory with offset uh equal to"
1406560,1418960," the current procedure uh local memory uh capacity uh local memory capacity and uh location it's a memory"
1418960,1426320," location right so this is going to be memory location local memory capacity and then what we have to do we"
1426320,1436400," probably have to increment uh current uh procedure uh local memory capacity local memory capacity plus memory"
1436400,1446560," the size um um uh akileos 77 thank you so much for uh tier one subscription thank you thank you thank you and"
1446560,1454800," welcome to our epic port club uh thank you thank you thank you really appreciate that all right so uh what"
1454800,1466240," do we have in here so it complains about uh local memory capacity does not exist uh somewhere missing one uh oh yeah it's missing one of them okay so"
1466240,1472880," local memory so local memories and then local memory capacity right so it's going to be equal to zero"
1472880,1479920," now go prox doesn't have uh memories uh but this is because it has local memories right so this is the local"
1479920,1486320," variables uh memories and another mistake in here um"
1486320,1496080," there we go uh unknown word dst okay so perfect this is actually very cool because"
1496080,1503920," um it's allocated look look look look look it complains about unknown word dst so it defined this thing"
1503920,1512160," in here but now this thing is unknown right this thing is straight up unknown which is actually very cool okay"
1512160,1523840," now uh what i can do unknown word unknown uh word so here as you can see uh i check if something is defined and if"
1524880,1533600," um the token the current procedure the current procedure is not none so that means you are inside of some"
1533600,1545680," sort of current procedure and uh token value token value is um is in current procedure current procedure"
1545680,1554720," memory local memories you are referring to the local memory so we can quite easily catch the moment when you're trying"
1554720,1560640," trying to refer to a local memory inside of a local memory inside of the procedure you see what i'm talking about"
1560640,1569440," right so and we can do something like assert false uh referring um yeah referring uh to local memories"
1569440,1584560," uh memories is not implemented yet right so this one is going to be to do there we go uh okay and we actually hit that we actually hit that to do cool so now when you are"
1584560,1592320," uh referring to the local variable uh we have to push a new uh intrinsic so in case of a memory we just push mem"
1592320,1602320," right we just push mem but uh in case of uh this one we have to push local mem i suppose right so we"
1602320,1614400," need to do something like push local mem uh program ops append op op type push uh local mem right"
1614400,1621920," so it's going to be token equal token uh and this is going to be current procedure uh current procedure"
1621920,1629760," local memories uh token value and we're going to be using the current of set so there we go and that's"
1629760,1635760," that's going to be just like p plus one so but this is only one intrinsic there should be another intrinsic"
1635760,1639920," to um to allocate the memory"
1639920,1654640," um and i think it should be at the end of the procedure definition right once you define it um a new procedure"
1654640,1665600," um we should have like a lock local memory right yeah i think this is what we have to do okay so let's go ahead and define"
1665600,1672640," uh some new operations so we're going to have a push uh local memory right so this is going to be one thing"
1672640,1679760," um and uh another thing we need to have is maybe a lock uh local memory right"
1681600,1685040," so these are the two operands that we need to have"
1685040,1694960," what is going on in the chats okay so"
1694960,1700720," i don't know what the is going on in the chat but you guys need to calm down"
1701680,1703360," all right so let's continue"
1703360,1709600," let's continue"
1709600,1717840," okay"
1726720,1731600," mods if you have we have any mods anyone who are using that command one hour timeout"
1731600,1735520," okay so uh let's continue"
1735520,1749680," uh so this is going to be that exhaustive op handling so we added two of them so it's going to be 16 and then 17."
1750480,1757040," uh all right so um this is oh this is the type checking by the way right so we'll need to do some"
1757040,1763280," sort of a type checking but i think type checking for this thing is all right uh right because it's not"
1763280,1772480," gonna do anything special so it's gonna be op type or p type push uh local memory right so in that case we're"
1772480,1781280," going to do stack append right stack append data type pointer uh op token right op token then we're"
1781280,1788800," going to increment the ip of this entire thing so in case of the alloc uh i didn't think uh we need"
1788800,1790160," to do anything with the alloc"
1793600,1805520," so op type uh op type uh a lock local mem um so and uh i think we're just not going to do anything"
1805520,1810720," here right because it's just like doesn't need uh to be type checked right doesn't need to be type"
1810720,1820720," checked uh all right so i did i update uh this thing okay i didn't so 16 17 uh push memory all right"
1822160,1832320," so l if op type or p type push uh local uh memory and this is going to be assert false uh not implemented"
1832320,1841600," or p type or p type a lock local memory"
1841600,1850080," so yeah"
1852160,1866240," okay so we hit not implemented we hit not implemented and this is where we should start"
1866240,1875200," uh doing the entire thing um doing the entire thing the question is how we're going to do all of that"
1875200,1881040," that's a very good question um so let me see uh maybe we want to draw something i also want to open the"
1881040,1893680," the window because it's a little bit hot in here"
1893680,1903360," so we have this stack all right we have this stack"
1907120,1915600," and so the stack grows towards the uh the zero right so it grows towards the zero so here is the"
1915600,1923760," stack uh here is the stack so when we call when we perform the call we actually push the return"
1923760,1930560," uh address on the stack so the stack is located in here every time we allocate a little bit right we"
1930560,1938720," allocate a little bit on the stack um we need to keep track of where the top of the stack is located"
1938720,1941600," that's a very actually interesting thing"
1941600,1944720," uh"
1944720,1955600," so we already store the top of the stack in the return stack rsp red stack this is actually super cool right we"
1955600,1962320," already store that which means that we can just update that value to point in here right we're"
1962320,1968080," gonna update it to point in here and uh since we know this offset right we know this offset we can quite"
1968080,1974400," easily just like figure it out so and if we do that several times how do we know how much we have to"
1974400,1982560," subtract at the end well this is precisely why this is precisely why we we kept track of the local memory"
1982560,1988560," capacity because that local memory capacity is precisely the size you have to subtract before"
1988560,1994560," trying to reach for the return address this is actually pretty cool so everything is working out"
1994560,2001360," perfectly so we have all the necessary information to actually uh allocate the memory uh figure out the"
2001360,2006480," addresses of the local memories and we also know how much we at the end have to deallocate"
2007360,2015440," so that's actually super well it's not 100 true actually because you might be um"
2015440,2021920," we might be allocating some memories we might be allocating some memories in"
2025920,2039760," well you know what you know what we can pre-allocate all of that memory so my concern was uh chat chat my"
2039760,2048560," concern was what if you have some sort of a condition here so if uh false uh like some sort of a test if"
2048560,2056160," test you allocate a little bit more right you allocate a little bit more uh so what's going"
2056160,2064560," to happen in here right so if we if this test is always false this thing is never going to be allocated"
2064560,2070640," so we cannot just subtract the whole capacity that we just accumulated right so we can just subtract the"
2070640,2076240," whole capacity um so we need to keep track of the allocated memory dynamically"
2076240,2084960," but another interesting thing as we compile we actually accumulate all of the sizes of all of the"
2084960,2091920," possibly allocated memories we might as well just pre-allocate the whole thing on the stack at once"
2091920,2096320," regardless of whether you're going to reach that thing or not which will simplify the implementation of"
2096320,2101440," course it's going to be wasteful we do a lot of wasteful thing in our compile already we'll do a"
2101440,2107200," lot of wasteful thing but this is because we are experimenting right we're trying to get to the"
2107200,2113280," particular point as quickly as possible so what i'm trying to always find right now is the easiest"
2113280,2118960," thing to implement so the easiest thing to implement right now would be to get rid of the unlock"
2118960,2124800," local memory and just pre-allocate the whole memory capacity at once"
2126320,2133920," uh the whole memory capacity at once so and that will make everything fucking easier that will make"
2133920,2138560," everything easier figuring out the offsets we're gonna make it easier yeah everything is gonna be easy"
2138560,2142240," uh so yeah"
2142240,2146640," all right so let's go ahead and do that"
2153680,2155920," so that's actually really really cool"
2155920,2165600," uh okay so maybe i wanna i'm ready streaming for almost two hours and when i stream for too long i get"
2165600,2173200," really really tired uh super quickly so uh yeah maybe i want to make a small break"
2173200,2179920," um i'm gonna make a small break super quick and after the small break i'm gonna continue"
2180560,2183440," and uh we'll see how it will go so um"
2183440,2191600," all right so uh let's go ahead and implement what i wanted to implement so i don't think we need"
2191600,2199200," uh a lock local memory right because we're gonna pre-allocate the all the local memories in the prep"
2199200,2204640," procedure right so pre-allocating everything that is needed is going to be a part of the uh preparation"
2204640,2209200," of the preambola i think i think the uh originally for this thing is a preambola or something"
2209200,2219760," i don't 100 remember uh so yeah uh let's go ahead and do that uh so we have this thing uh so a lock we"
2219760,2224480," don't even need that everything starts to make sense actually i really like that um everything"
2224480,2230480," starts to make sense so we push local memory and it's just gonna be offset from uh from the rsp and stuff"
2230480,2237440," like that i love that actually i really really like that though it's unclear how we're going to be doing"
2237440,2245680," that in the simulation so uh we'll see how it goes but for now we only need like 16 of this stuff uh so"
2245680,2254080," here is 17 and this one is going to be more of a 16 um so allocate local memory uh and maybe in here i"
2254080,2262560," want to prep uh procedure and i want to do assert uh false the question is where are we going to be"
2262560,2269920," storing all of that all right where are we going to store we might as well make uh the size that you're"
2269920,2276960," supposed to allocate part of the operand of the prep proc that is actually a very good idea so this is"
2276960,2287360," how we're going to do that so op operand um right is instance uh of the um of the integer right so this"
2287360,2294240," thing has to be the size of the local memory that you have to pre-allocate uh okay so and this thing"
2294240,2303360," already failed the assertion which is good uh so op type uh prep uh proc so let's find the place where"
2303360,2309200," we push this entire thing right we're preparing the procedure and once we are preparing the procedure"
2310560,2314000," oh oh fuck shit um so"
2314000,2323920," do we push anything on this tag though do we push anything in the stack"
2323920,2333760," i really don't think so right so we kind of need to push prep proc on the stack as well"
2335200,2341760," uh because then i want to go back to the prep proc and um just do something about it um"
2341760,2348160," so here is a skip procedure and then we append this entire thing and maybe here"
2348160,2355520," we can try to do that why not so let's actually just append this entire thing uh right so because"
2355520,2360960," we'll need to come back to both of these operations we'll need to come back to both of them"
2360960,2366800," and for the prep proc we'll have to set the uh memory that we have to pre-allocate like a local"
2366800,2374320," memory and for the skip proc we have to uh set the place where it have to go to skip the entire procedure"
2374320,2381200," right so that's what we have to do in here uh so let's try to recompile and uh we're already failing"
2381200,2389440," so and can only close uh procs uh okay so that that makes sense so let me find this place right let me"
2389440,2394240," find this place and uh that will uh"
2394240,2404080," okay cool so we have a skip procedure where is the skip proc okay that's cool so here is a skip proc"
2404800,2412480," and uh as you can see here we're setting everything up so i suppose what i have to do now is uh program ops"
2412480,2420880," uh block ip block ip type i need to check that it's a type uh prep procedure"
2420880,2429120," prep proc um so this is a prep proc and in here"
2431520,2439920," uh what i have to do what i have to do do we have oh boy um"
2439920,2451200," yeah so we have to append we don't really have to append anything yet but we have to go back to the"
2451200,2461680," the original thing and as a operand we have to set current proc uh local memory uh memory capacity"
2461680,2467040," there we go so the operand of the uh preparation becomes the local memory capacity"
2467040,2476640," that's what it becomes um so let me actually uh also put assert false in here um to do"
2478000,2484880," not finished uh because i want this thing to fail so this thing is not finished yet uh and i also want"
2484880,2494320," to go to the place where we handle the uh procedure preparation so this is a simulation so we'll probably"
2494320,2501360," have to also put a false in here because uh we'll have to pre-allocate some memory there we'll have to"
2501360,2506800," pre-allocate some memory so we'll need to allocate some memory for the local storage and whatnot so to do"
2508000,2516080," uh not implemented uh yet so we have to be super careful um so this is the type checking in case"
2516080,2521520," of a type checking i don't think i need to do anything in here and in here uh this thing is not"
2521520,2529920," finished yet right to do not finished yet it's really easy to forget to add something it's super"
2529920,2535040," easy to forget to add something that's why i put like as many asserts as possible so i don't forget to"
2535040,2542240," go to those places eventually and implement some things so yeah so sort of like i leave some sort"
2542240,2548160," of stoppers and markers uh for myself to not forget to add things there because we're dealing with a very"
2548160,2552960," complex system actually relatively complex things system i'm pretty sure there are way more complex"
2552960,2561280," systems but this thing is relatively complex um right and it's quite easy to forget to uh add something"
2561920,2569040," and then spend a lot of time like troubleshooting and whatnot okay so especially in such a dynamic"
2569040,2576800," language um okay so we have not finished and we are currently in parsing right so we have that um so"
2576800,2587120," that is very very paug that is very very paug uh the next thing i probably want to do the next thing i"
2587120,2594720," probably want to do i want to uh sort of like pop i want to pop yet another block and i know that after"
2594720,2604880," that uh that block ip must be skip procedure so i'm gonna even assert that so it must be skip procedure"
2604880,2610320," otherwise we made a mistake somewhere there uh and only then i might as well actually remove this entire stuff"
2610320,2616720," okay so uh i just sort of circumvented that so we have a preparation so for the preparation you put that"
2616720,2621760," thing in there then you pop another one expecting the skip proc and for the skip proc you just add"
2621760,2626480," another thing in here and just clean up the current procedure okay so that makes sense"
2626480,2634320," uh that makes sense so uh what else do we need in here and there we go we are in a generation"
2634320,2641920," so this is like i already anticipated that i will need to go in here all right so procedure preparation i"
2641920,2649840," get the rsp i get the rsp and i save it in there that's very very interesting"
2651840,2661920," but before i go and save rsp in there i think what i want to do is i wanna subtract"
2661920,2670800," holy it starts to feel like the code that is generated by compilers such as a gcc or clang"
2670800,2675520," right so because they usually quite often just subtract something for rsp pre-allocating some like a"
2675520,2680640," little bit of memory and the thing we're going to allocate there is located in the operand right so"
2680640,2685840," the operand contains the amount of memory we have to pre-allocate in there look at that that's beautiful"
2685840,2695920," so uh yeah that's perfect and then in the return we also kind of know how much we have to deallocate"
2699280,2706720," or not it depends so return doesn't know how much it needs to allocate so let's actually put a stopper"
2706720,2717600," here as well uh so this is going to assert uh false to do red does not know uh how much uh to deallocate"
2717600,2724080," yeah it doesn't know how much to deallocate and uh we're gonna probably pass the amount of uh it needs"
2724080,2730880," to deallocate why the operands so we'll have to do is instance uh op operands uh op operand integer"
2730880,2739600," no awesome comment for call and return i forgot to put them in there so to be fair these kind of"
2739600,2744560," comments are not particularly useful what i'm thinking is that maybe i'm going to actually do a very dumb"
2744560,2755280," thing uh out right one two three four uh right so something like s uh and just like um i don't know"
2755280,2763760," op type right or maybe just straight up op uh right because i keep forgetting these comments uh i'm not sure"
2763760,2771520," if they're that useful so uh yeah maybe i want to get rid of them completely uh so i don't think it's it's"
2771520,2793520," that important so um so another one uh huh uh well i mean yeah whatever uh so this is the end"
2795840,2823520," so i just recorded a macro for emacs to uh just find the next comment and remove it so i can just go and"
2823520,2827200," just delete them automatically like that uh i think that's pretty convenient uh i think that's pretty"
2827200,2836160," convenient so for things like this uh we might do something like if operand is in uh one of those"
2836160,2845040," things right cast uh like so and boolean uh we're gonna just just do pass right and then we're gonna"
2845040,2851920," continue so yeah macros and text editors are like a must to have in my opinion right because they allow you to"
2851920,2856800," just quickly do this kind of stuff and the comment that i just generated in here is probably gonna be"
2856800,2862960," horrendous i'm pretty sure about that because it's just gonna take the whole thing and just generate"
2862960,2869280," some crappy in there but i guess that's fine uh i guess it's fine for now so what do we have in here"
2869280,2877840," we have else in case of a while we're gonna just put a pass in there um right so and uh what do we have in"
2877840,2886400," here um so this one has to be something like this there we go so red does not know how much to deallocate"
2886400,2895200," that's a good point and as you can see um it doesn't have any operand setup so op type return so here is"
2895200,2906320," the op type return uh and uh we usually do that in the prep oh that is actually very fucking cool uh so"
2906320,2919360," essentially um yeah we can set operand uh as the same thing in here uh as the same thing there we go so now"
2920080,2927840," uh it does know how to do that oh we actually missed this thing okay so um here's the rsp"
2927840,2932000," uh we sort of recovered the rsp"
2934000,2945600," uh and i suppose what we have to do in here is out right uh add rsp d um op operand"
2945600,2953760," right so that's what we want to do here i think uh we might as well take a look at the uh assembly"
2953760,2961520," that got generated right now because i'm kind of curious uh right so yes that's what i was talking about"
2962480,2970640," um maybe it's fine i guess i mean just like assembly doesn't care right so it just doesn't really care"
2970640,2976240," but at least we have like a lot of information of what the is going on here uh and we even have like"
2976240,2983200," the text the location uh the actual values like we have literally everything uh so might as well"
2983200,2992080," actually keep it in here why not um so okay so i want to find something like return and i found the"
2992080,3000720," return so uh yeah everything looks okay uh add zero because we never actually located anything in there"
3000720,3008480," that that's fine look look you can optimize this thing you can actually optimize this thing uh dr poopy"
3008480,3014720," says yo yo thank you so much for seven months of uh twitch prompt subscription thank you thank you"
3014720,3022320," thank you and welcome to our epic fourth club uh okay so now we need to push a local memory how are we gonna"
3022320,3033520," push a local memory that's a good question so uh i wonder uh what i can do in here i'm gonna take uh out right"
3034640,3049280," and i'm gonna move um uh rex uh return stack rsp we can use return uh stack rsp as the beginning of the local"
3049280,3061040," memory that's what we can use so we move this pointer to rex then uh since we know the offset we're gonna add"
3061040,3071360," that offset to uh to the rex we're adding that offset to the rex op operand so here we need to also assert"
3071360,3081600," that uh this entire thing is op operand um is a memory address of course right and after that we should be"
3081600,3090960," able to be able to push rex onto the data stack giving the program the pointer to the return stack memory"
3090960,3094560," that is very fucking pokers"
3094560,3104320," that is in fact very fucking pokers isn't it i think it is so uh and it compiles"
3106080,3114000," these sheds by the way compiles we have no way to properly you know uh verify that or check that"
3114000,3124640," but yeah how can we do that so having local memory having local memory should allow us to implement"
3124640,3132640," something like to swap uh who knows what is it to swap uh to swap so to swap uh accepts"
3134400,3142960," four uh values and swaps the pairs of them right so uh essentially it's going to be something like this"
3142960,3151600," uh yeah and if you have a local memory you should be able to implement to swap not as an intrinsic but"
3151600,3157280," actually as a procedure and this is something that we can actually observe and uh"
3160080,3173040," see that okay i'm sorry uh so let's go ahead and implement that and see um so uh to swap uh ports"
3173040,3184080," a proc uh to swap so a b c d uh so how many things we want to allocate in here i'm not even sure"
3187360,3191440," so"
3191440,3199120," so we need to achieve c deb somehow um yeah maybe it would be easier to actually do something like this"
3199120,3206240," so we're gonna have a memory a uh size of uh u6 you might as well actually do something like this a b"
3207040,3219840," uh c uh c and d uh right and then i can do d uh 64 c um d c"
3219840,3230000," b a uh and after that i should be able to do the following thing so it's gonna be c"
3230000,3245840," uh 64 d uh 64 d 64 b 64 a 64 then just depends it's kind of a dumb way of implementing that but"
3245840,3253760," it's just to test things around right you see uh okay one two three four two swap print print print print"
3253760,3263920," print okay uh actually let's command it out and see the output of this entire thing uh like this"
3263920,3274000," so this is going to compile r uh to swap okay so four three two one if i do two swap"
3276560,3285280," one two four three we have local variables and the question is can i access those things like here"
3285280,3292960," i cannot they're truly local if i try to access a it will say unknown word right so you can only"
3292960,3300880," access those things within the procedure so you can have local variables uh that's pretty cool"
3300880,3309360," oh you can just allocate a bunch of memory on the return stack you can just allocate a bunch of memory"
3309360,3315280," on the return stack and use it as a local storage and when you go out of the scope of the procedure"
3315280,3319040," all that local storage is automatically deallocated you don't have to think about it"
3321680,3326880," um b and a are swapped"
3326880,3337840," maybe not sure so d c b b a then uh"
3337840,3344000," i guess it has to be like three four one two right"
3349360,3365200," one two one two it might be maybe it's something like that is that one has to be uh it's it's kind"
3365200,3373280," of confusing but you get the idea uh so it's just like i suppose if it's a mistake it's a mistake in my"
3373280,3378960," implementation not in the uh in the local storage right so if i understand correctly"
3379520,3388560," probably i don't know uh so what i would expect i would expect this thing to produce um one two three"
3388560,3401600," four uh one two so the result has to be uh two one uh four three that's what we expect right two one four"
3401600,3404720," three two one four three two one four three"
3404720,3416720," so probably oh it has to be like literally c dab like so right two one four three okay so we got it right"
3416720,3419040," two one four three"
3421680,3432880," we did it so we have a c dab how about that i'm actually super happy so that will make uh"
3432880,3438960," implementing procedures with a lot of arguments a little bit easier because then you'll be able to"
3438960,3444240," upload some of the arguments to the local memory right you're floating some of the arguments to the local"
3444240,3449680," memory and uh for the rest of the arguments you just work them on the stack or something like that"
3449680,3456480," um we can finally probably implement the recursive fibonacci number calculator"
3456480,3462000," um so let's actually give me a try so right now we have a little bit of a problem with type checking"
3462000,3471840," recursive functions so uh let me see let me see so this is going to be n right in case of the uh n um"
3471840,3481840," be in uh zero or one so it has to be uh less or equal to one right if this thing is less or equal than one"
3481840,3490640," that means we just return that if it's not less or equal than that right it's more of a like if it's greater"
3490640,3506160," than one uh what we'll have to do uh memory a uh which is going to be that and b so in here uh what i'm"
3506160,3516800," going to do i'm gonna duplicate uh and subtract one and call fibonacci with that and then i'm gonna save that"
3516800,3527520," result to a right i'm saving the result of that call to a then i'm duplicating this entire thing uh and"
3527520,3535520," subtracting actually one i'm calling and saving all of that to b so after that um"
3538720,3552000," yeah after that uh i want to drop this entire thing and just take a b plus and otherwise in here"
3552000,3563280," yeah that's that's actually fine so this is the fibonacci number calculator i think right because if n is"
3563280,3569840," less uh or equal than one and is the result of the fibonacci number process calculation see see what i"
3569840,3577760," mean uh otherwise we just store intermediate values into like local uh like stack so that way we can have"
3577760,3585120," like a proper recursion that can utilize the stack of the uh of the call stack right so now we can do"
3585120,3593680," something like this uh dupe uh less than 10. maybe maybe less than 10 right and here i can do dupe fib print"
3593680,3601200," let me go so in on each fib it will just recursively compute that so for zero it's gonna be zero one and"
3601200,3607600," so on and so forth um"
3607600,3615680," so let me see uh unknown word a okay so i'm sorry it has to be something like 64. i forgot that i haven't"
3615680,3621200," implemented that syntax yet unhandled data on the stack and this is because i forgot to drop that"
3621200,3626080," and there we go so here's the problem with the current type checking the current type checking"
3626080,3635520," doesn't know how to check the um the recursive functions so it basically hangs right so i'm"
3635520,3640480," going to fix that later it's not really that much of a priority uh but basically if you have something"
3640480,3647360," recursive just do that with unsafe and this entire thing actually also hangs because i forgot to increment"
3647360,3656640," the uh the counter right so there we go uh okay does it look like a fibonacci number sequence uh"
3656640,3659680," does it look like a fibonacci number sequence i think it does"
3659680,3667280," i think it does look like a fibonacci number sequence so the only problem here right now we have"
3667280,3674320," is uh the type checker not being able to properly type check the uh recursive procedures but if you do"
3674320,3679680," unsafe you can have like a proper recursion uh due to having local memory regions"
3679680,3686720," so uh yeah"
3686720,3697520," i think this is actually super cool this is actually super cool so um i have constants i have local memory"
3697520,3703120," storage and i think that should be enough to implement everything i want to implement though"
3703120,3713200," yeah i need to still somehow being able to type check the um uh the recursion so one way i can see"
3713200,3719520," we can implement the type checking is by implementing proper signatures for the procedures"
3719520,3726160," if you know what i mean right so basically we need somehow to annotate that this thing accepts"
3726800,3733360," uh one number and returns another number so the type checker doesn't have to go recursively into the"
3733360,3739760," calls to check everything right it can just go here and since it knows what accepted and what's returned"
3739760,3745200," it can just check that and stop the whole recursion so right now since we don't have such information"
3745200,3749840," the type checker actually goes inside of the functions and just type checks like literally everything"
3749840,3757600," it's just almost like evaluates the program uh making sure like there's no like stack under flow or you know"
3757600,3770480," um incompatible types or whatnot so yep that is actually very cool uh so i'm gonna use this thing as a test for"
3770480,3782800," for this stuff maybe um so does anyone have any questions maybe uh does anyone have any questions about today stream so"
3782800,3791440," we implemented uh local memory storage and now you would be able to actually allocate something on the local stack"
3793680,3801680," how do you return from procs what do you mean by that uh you mean yeah when the execution reaches the end you"
3801680,3814240," return from the procedure"
3824960,3829920," this resembles how you'd implement uh the actual intrinsic and i like it yeah it's kind of cool"
3829920,3835280," that it almost looks like a proper programming language which is disgusting"
3835280,3841440," should have actually just implementing an ability to push things on the return value"
3841440,3848800," like in fourth and just have the language look like this because obviously this is more elitist and cooler"
3848800,3854800," than this this is too fucking readable like seriously this is too fucking readable for normies"
3854800,3859360," it has to look like this but i'm a normie so what can you say"
3859360,3874240," would implementing type checking for recursion require a double pass no don't think so"
3880880,3887200," if you want to return two values oh you're talking about returning values you said how do you return"
3887200,3893760," from a function returning from a function you just reach the end and you return from the function if"
3893760,3898720," you want to return two values from a function it's a separate question that has nothing to do with the"
3898720,3906800," previous one uh if you want to return two values from a procedure you uh just return two values from the"
3906800,3920640," you go you can return four if you want to"
3920640,3927680," it all works it even type checks"
3930160,3936640," okay well almost"
3936640,3946800," not enough arguments uh so this has to be 16. yeah i don't know not enough arguments for the print you"
3946800,3956000," see the type checker went inside of the two swap it observed that it returns four arguments on the stack"
3956000,3962080," then it sees that you have four prints but it sees that you also have the fifth one but you don't have"
3962080,3967760," enough arguments for the fifth one and all of that happens before you actually evaluate things"
3967760,3972800," right so you can have something like include std ports right"
3972800,3981280," uh side effect so you put some sort of a side effect right and if you try to compile this and i think as you can"
3981280,3986960," see the side effect was not evaluated in any way so there's no side effect in here so there's no execution"
3986960,3993120," but then you do that and here is your side effect and then this entire thing our type checker actually"
3993120,4000800," checks this kind of stuff uh yep and in the future we don't have any type signatures because of that and"
4000800,4007040," because of that the type checker actually goes inside and like literally checks everything um but as we"
4007040,4012640," introduce like type signatures we'll be able to say that this thing just transforms the stack in a"
4012640,4018400," particular way right so maybe we'll be able to say something like i don't know to swap is supposed to"
4018400,4025040," be like thing that swaps swaps to uh like payers of the argument so it's going to be int int int int and"
4025040,4032640," returns int int int right and then the type checker will take this information it will know that this"
4032640,4038480," function consumes four elements four integers from the stack and returns four integers on the stack or"
4038480,4044000," something like that i mean whatever so uh we'll see how it goes i don't know i'm not sure about the"
4044000,4049840," specific syntax i don't care about specific syntax for some reason people care too much about language"
4049840,4058160," syntaxes a syntax is this and i really don't understand why because seeing syntax is literally the"
4058160,4063120," easiest thing to change in the language like you just like go to the parser and you just change it"
4063120,4069600," the thing that are difficult are the semantics right because slight change in the semantic may result in"
4069600,4075200," a huge change in implementation like you slightly change something and all of a sudden you need a"
4075200,4079520," second stack and then you need some pre-calculation before you go into the function and just like"
4079520,4086160," shit goes crazy so it's really difficult stuff and it actually affects how you can use uh your"
4086160,4092800," language and on what architectures you can use your language syntax is literally like nothing it affects"
4092800,4097920," almost nothing i don't know why people are so wind up about syntax like it's literally insane"
4097920,4105200," it's just really strange to me because syntax is the easiest thing to implement in a language and"
4105200,4112240," modify and change and experiment with it's like it's just a cover it's just like yeah you change you"
4112240,4121680," change it and the language stays the same um i don't know how sorting is getting function signatures the"
4121680,4129200," secret is i don't there is no function signatures that's the secret and that's why i was talking about"
4129200,4135520," implementing them because i wanted to have them but right now i don't have function signatures"
4135520,4147920," because syntax is the most obvious i suppose it's literally bike shading and after you're right it's"
4147920,4154800," literally bike shading so people just have an opinion on things that are easy to have opinion on it is"
4154800,4161440," difficult to have an opinion on implementation of uh it is hard to have an opinion on implementation of"
4161440,4166640," like local variables but it's easy to have an opinion on a specific keyword in your language right"
4167200,4169600," because it's whatever"
4169600,4185360," and people always look at superficial parts first yeah i guess"
4187760,4217520," um okay um so we need to do a committee committee i suppose and maybe even pushy pushy you know what i"
4217520,4226320," forgot by the way i forgot i forgot to uh check the simulation i forgot that we live in a simulation"
4226320,4237200," that's what i forgot uh all right so we have that and um okay so one two three four two swap uh print"
4237200,4243760," print print print okay so and we have something like this so now i should be able to use this stuff"
4244320,4250720," to use this stuff in uh tests right to swap and then just move this entire thing in there"
4250720,4260000," uh so and if i try to run tests to swap for the simulation right so this is that"
4260000,4268880," uh huh so we're gonna have 16 uh uh uh so push memory and we have to do push local memory op type"
4269120,4281760," push um a local memory right assert false uh not implemented right not implemented okay so this one"
4281760,4285360," is rather interesting how are we gonna even approach that"
4285360,4296080," we need a chunk for a local memory i mean it's actually kind of not that interesting so essentially i'll"
4296080,4303040," have to allocate some memory for the byte array in here and then just use that memory it's like it's"
4303040,4307840," pretty straightforward so i think i'm gonna leave it as a to do i think i'm gonna leave it as a to do for"
4307840,4318560," uh so push local uh so push local was it uh push yeah it was a push local mem oh this is the this is the type"
4318560,4328720," not implemented uh prep uh also not implemented aha so that makes sense and uh yeah this one is also not"
4328720,4337920," can be implemented rod intrinsic can also be proc now yeah a lot of things can be proc now actually"
4337920,4346080," if you think about it right so maybe this kind of thing will allow us to significantly reduce the amount"
4346080,4354560," of intrinsics actually if you think about it uh because you just need to implement the way to allocate"
4354560,4359760," local memory access the memory and deallocate local memory and the rest of the stuff is going to be"
4359760,4365280," just expressed in terms of that um yeah that's actually pretty cool idea"
4365280,4376640," all right so i guess that's it for today thanks everyone who's watching me right now i really appreciate"
4376640,4383360," that thank you for all of the uh subscriptions and beats and stuff like that really appreciate that too"
4383360,4392160," uh i'm gonna finish it off uh after the stream um have a good one and i see you next time um and next"
4392160,4398720," time i don't know what we're gonna do next time i think so far uh we have everything we need we have"
4398720,4405520," everything we need to continue implementing the self-hosted compiler uh but i don't know so"
4405520,4411680," basically uh when i said that i have everything we need uh to implement the self-hosted compiler i"
4411680,4416960," didn't know that i actually need local variables the more i implement the compiler the more i realize what"
4416960,4423120," kind of features i'm missing and uh if i'm missing a particular feature i'm gonna start a stream and"
4423120,4427600," implement that feature on the stream so i already uh you know described that process but i just want to"
4427600,4433600," reiterate right so i'm going to continue uh re-implementing ports in itself and if i encounter"
4433600,4440080," something else that i desperately need and it will make my life easier implementing that compiler then"
4440080,4443360," i will make another port stream we're going to implement that feature and i'm going to continue"
4443360,4449040," implementing the portion itself and once we are implemented in itself uh we're going to call it a"
4449040,4457520," victory right so i'm really looking forward to that because at that point i will be able to finally"
4457520,4467040," lift my curse and not be a python programmer anymore so yeah basically me programming python for several"
4467040,4474720," months already is a curse and i in to lift that curse i need to reimplement portion itself once i"
4474720,4480480," manage to implement it in itself that's it i'm not a python programmer anymore i'm free i can do whatever"
4480480,4486720," i want but until then i'm forced to program in python and there's nothing i can do about that yes"
4488240,4496080," anyway that's it for today thanks everyone and see you all next time love you"
