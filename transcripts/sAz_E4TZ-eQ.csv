start,end,text
0,11040," all right looks like we're alive hello everyone and welcome to yet another"
11040,18240," zozin session how about that how about that but you didn't expect let's make a little bit of"
18240,25320," announcement on our discord server so we're currently live on twitch if i'm not mistaken"
25320,34920," right live on twitch and what are we doing uh today we are programming in rust rust rust"
34920,40920," uh we're programming rust specifically we're implementing persistent stack which is rather"
40920,47720," interesting we get to what it is a little bit later so it should be switch.tv so starting and"
47720,53640," we're gonna ping everyone who wants to be pinged and there we go this stream has officially started"
54200,61560," hello everyone hello hello hello welcome welcome welcome chat tell me what do you think about rust"
61560,70680," anyway so what is a persistent data structure right so specifically we're implementing persistent stack"
70680,77000," but generally there is like a whole class of data structures called persistent data structures"
77000,83560," so let's actually google it up uh persistent data structure all right i'm going to prepare the"
83560,89320," description because i want to put the link about this thing in the description as well in computing"
89320,95560," a persistent data structure or not ephemeral data structure i never heard like the term ephemeral data"
95560,101400," structure to be fair i only heard persistent one it's a data structure that always preserves the previous"
101400,109240," version of itself when it's modified that is very interesting so uh so specifically quite often uh"
109240,116040," the like persistence is applied to trace and stuff like that but but we're going to apply it to uh to"
116040,121800," stacks specifically linked lists so i really want to give the link to this thing in the description but if"
121800,127720," i just copy paste this entire stuff it will contain some garbage that google put in there uh put in"
127720,132600," here um i don't know what's what's going on with my speech today so um i have to specifically remove all"
132600,137480," of that this kind of stuff it's so annoying i don't know why google keeps doing that and it's so difficult"
137480,143080," to get rid of that and it's just like they think it's helpful but it's not helpful at all it's just like"
143080,147480," puts a lot of garbage in your url and if you want to share something it's just like you have to do this"
147480,155800," extra work of removing all of that it's just so annoying i don't know anyway so um okay so why do"
155800,162040," we even need a persistent data structure so believe it or not this entire stream is actually related to"
162040,167160," port right so i've been developing uh my own programming language called port for like more"
167160,173480," than two months already i think uh right so i'm gonna give the link to uh to this language here in"
173480,178360," description if you're watching uh if you're watching live i'm going to put that in the chat so here it"
178360,185400," is you can find it in here uh so port programming language right here's the port programming language"
185400,192120," and it's a stack based programming language meaning that all of the operations like literally everything"
192120,198680," is done via the data stack right so we can take a look at some of the examples of this language"
199800,207000," soon uh chirurgical thank you so much for 29 months of tier 1 subscription uh thank you thank you thank"
207000,215320," you and welcome to our epic uh rust club um okay so let's take a look at some example uh brainless"
215320,220520," brainless jellyfish thank you so much for two months of twitch prime subscription thank you and welcome to"
220520,226760," our epic rust club it's not a rust club yet it's still a port club but after we're done with port uh we're"
226760,234280," gonna do some rust uh buying bar 18 thank you so much for two months of three prime to the twitch prime"
234280,241240," subscription and welcome to our epic port club um okay so let's take a look at hello world right so hello"
242040,252760," uh ports okay emacs emacs what is going on uh hello fourth there we go so i need to include the standard"
252760,260280," library right and then i don't think hello world is actually pretty good example of this you know stack"
260280,267160," orientedness of the language so let's actually do something like a thing that sums up two numbers uh so if you type"
267160,275640," 34 that is a command within the language to put that number onto the stack right if you uh type another"
275640,281960," number it will put another number onto the stack uh right and then you have operations that operate on"
281960,288120," the top elements on the stack like plus right so this thing takes top two elements on the stack sums them"
288120,294200," up and puts the result back on the stack and uh here uh the top of the stack after this plus separation"
294200,300760," you're going to have uh the sum uh on the stack and then you can do print and that the thing will print"
300760,307880," the um the result of the sum onto the screen right so uh i think we don't need this standard library for"
307880,312840," that so this is a very simple program and if i try to compile and execute that program"
314360,320840," uh it is going to print 69 right as you can see uh it compiled this entire thing and printed the result"
320840,326040," okay that's pretty cool so this entire this is what it means for a language to be stack oriented right"
326040,330760," if you want to learn more about stack oriented languages i really recommend to just google up that"
330760,336680," term or specifically google up fourth i think this is the most prominent uh stack oriented language"
336680,343560," right a lot of people get into the stack oriented paradigm um by looking into fourth so i really"
343560,351560," recommend to check it out uh so i'm gonna put uh the link to the uh fourth uh wikipedia article in"
351560,358040," the description as well just for anyone who's interested okay uh one interesting thing about port is that"
358040,366280," it is uh statically typed right it is statically typed um so essentially uh during the compilation the"
366680,371480," compiler actually checks that you're not trying to do things that you're not supposed to do for"
371480,378200," instance here for a plus separation to actually work properly you need to have at least two elements"
378200,383080," on the stack and this is ensured by the compiler for instance if you remove one of the elements"
383080,388680," this is not going to compile because the compiler cannot prove that should have enough elements on"
388680,395080," the stack so it will tell you not enough uh arguments for the plus separation uh so if you try to compile"
395080,399880," this entire thing uh basically it will tell you that so it tells a lot of things in here and this is"
399880,407080," because the plus separation is overloaded right it uh can sum up integers it can sum up pointers and"
407080,411880," integer and pointers and stuff like that and basically for each uh overloaded plus separation it tells you"
411880,418120," that you you've got an error so so the the entire air reporting is not really well you know polished"
418120,423240," uh so i just hacked together something just for the compiler to report so it's not really that important"
423240,429960," but in any case it just tells you that there is not enough arguments for the plus right and uh yeah so"
429960,437000," that's basically it and uh interestingly enough this uh static type checking actually works for if"
437000,443480," conditions right uh so for instance uh what we can do in here for instance we uh summed up these two"
443480,451880," numbers and then put 69 onto the stack and we compared and this entire thing will give us boolean and we can"
451880,457880," dispatch we can basically do a conditional check on uh upon that boolean right so um"
457880,466840," uh the execution will go here if this condition is true and it will go here if this condition is false"
466840,472840," right so you can even do something like uh true and you can print this uh thing onto the screen"
472840,476280," and then you can do false uh and you can also print that onto the screen"
477400,484360," so uh just a second i think i forgot about a very important thing in here uh i forgot to put something"
484360,491560," behind my camera right so i usually just put some sort of a window behind my camera just in case i"
491560,498520," actually start typing somewhere where you can't see uh right so it just makes it easier for me to know"
498520,505800," whether you can see what i'm typing or not so it's pretty convenient uh okay so and uh what's interesting is"
505800,513880," that our type checker is capable of even checking this kind of stuff uh right so yeah so we can even"
513880,520680," remove puts and we can put puts in here uh right and the compiler will check that both of the branches"
520680,527640," put enough arguments for the puts to consume right so here's the very important so if one of the branches"
527640,534600," don't have enough arguments for puts to consume uh right so the program may work only when this condition"
534600,541160," is true but when this condition is false there will be no arguments for this thing so it will crash or you"
541160,547400," know yeah it will basically crash in sick fault so our compiler will ensure that in both of all in both of"
547400,553400," the branches you have enough of the arguments for this operation uh right so if i try to do something like"
553400,560120," this um it's oh it doesn't have puts because it's located in the standard library right it is located"
560120,567080," in the standard library so as you can see it just says true if i compare it with 70 it will say false"
567080,572360," right but if in one of the branches you don't have enough arguments for the puts to consume this will"
572360,578280," not compile and it will explicitly say not enough arguments provided for puts right uh so and then you'll"
578280,583160," have to go and fix one of these things so the question is how does it do that uh membrilla"
583160,587480," i'm a really thank you so much for 10 months of uh twitch prime solution thank you thank you thank you"
587480,595080," and welcome to epic port club so the way it does that right so the the way it uh type checks the program"
595080,602040," generally during the compilation it maintains the type stack right during the execution we have the data"
602040,607880," stack where you put the data that you operate on but during the compilation we have a type stack"
607880,614440," and what the program does it just goes through each individual operation and just puts the data type"
614440,622200," of this uh thing onto the type stack right and then checks if the you know types you know match together"
622200,628520," right so when it encounters 35 it will put integer onto the stack then another integer onto the stack then"
628520,633880," it will encounter plus and it knows that plus consumes two integers so it will look at the type stack"
633880,639640," see two integers and say okay that's type checks that actually type checks so everything's fine"
639640,648760," so and when it encounters if something interesting is happening it splits the stack in two right so"
648760,654200," essentially it has an execution context uh which has its stack of the types and stuff like that"
654200,661240," and if it encounters if it splits the entire context and continues the type checking uh in two contexts"
661240,665960," simultaneously so basically it will type check the execution if it goes here and then it will type"
665960,671800," check if the execution goes here and then both of the executions will merge together in here right"
671800,679400," so basically what we do we do like a small bfs on the control flow of the entire program right we bfs the"
679400,687560," entire control flow of the program so for this what there's no bfs it's a algorithm on graphs so uh yeah"
687560,693560," essentially you have a graph or like in our case it's a tree i think yeah it's actually graph it's a directed"
693560,701240," graph and you're basically sending a wave um through that graph like this here is the wave going on"
701240,708280," and that's basically what we're doing we're just basically sending and type checking wave uh through the entire program right"
708280,720280," uh and uh that requires again as i already said copying the stack copying the execution stack"
720280,725560," and uh we can even take a look at how it's done in the python program"
727000,731560," so type check i think it's somewhere here type check program"
731560,738200," type check program uh so here is the execution context right"
738200,746600," uh i think it's here yeah there we go so we have a variable called context which is a list of contexts"
746600,752840," right and we start with a single context which starts at the instruction zero and as we go further and"
752840,759080," further uh when we encounter ifs and maybe if stars and maybe while and stuff like that well while doesn't"
759080,766760," split anything do splits uh we actually copy the entire context we create a new one which copies the stack"
766760,772600," uh copies some other like expected outputs of the execution so this is just details but you see there is like"
772600,777400," a the uh situation of splitting um the stack and stuff like that"
777400,784040," so in in python it's relatively easy to implement because"
784040,789640," the python is a dynamic garbage collected and so on and so forth but we are currently"
789640,795480," re-implementing a port in itself right and port is closer to assembly"
795480,802280," than to um than to scripting language right so essentially we don't really have"
802280,809080," any uh automatic memory management and just copying stacks around is kind of tedious and kind of like"
809080,815960," error prone so what i was thinking is that we need to develop a data structure and approach"
815960,822920," where doing this kind of stuff in such a low level language would be easier right you see what i'm"
822920,829320," talking about so essentially like type checking requires like you know sophisticated algorithms and"
829320,834200," data structure they're not that sophisticated but you have to implement them in a low level language right"
834200,840440," um so and we need to come up with something that is easier to manage right we need to come up with"
840440,848760," something that is easier to manage right um and um the idea that i have in my mind is some sort of like a"
848760,855640," persistent data stack right persistent type stack right because we are operating on the on the level of of types"
856680,864840," so and that could be achieved by implementing the stack using linked lists right so which is rather"
864840,870440," interesting so i'm going to show you let's actually open up my paint and in my paint i'm going to show you"
870440,884600," let me let me let me let me let me try to do this thing so essentially how do you implement a stack"
884600,892520," uh using linked lists right so essentially you um create a bunch of nodes right so when you push a one"
892520,900120," you create a node uh that puts uh one like so i think i need to switch this entire thing right so"
900120,905960," here's the first element on the stack then you want to push two onto the stack right you create a new node"
905960,914840," you link the previous thing to one um the previous thing for one would be null probably right uh and the"
914840,920040," top of the stack is going to be here so here is the top of the stack so you have two elements on the stack"
920040,925080," and then if you want to put three on the stack uh you create a new node and you link it with the"
925080,931400," previous one here is your new top and this is how you implement stack uh with linked lists if you want"
931400,938920," to pop an element from the stack you essentially look at the top you follow its previous uh element and"
938920,944200," you set the new top in here and you do something with this note you forget it if you're working in a"
944200,950680," garbage collecting language you remove it manually if you work in the menu you know had manually managed"
950680,956120," language uh and so on and so forth so this is basically how you do that so what's interesting"
956120,963320," is that this kind of approach makes it super easy to copy and split the stack in two so let's actually"
963320,969240," reorient the stack a little bit uh let's actually orient it like vertically i also want to just make it a"
969240,975800," little bit more saturated if you know what i mean uh so i'm just trying to find a good color for this"
975800,980360," and i think i think this is a good color okay so imagine that you're pushing some stuff onto the stack"
980360,986760," right so we have one so this is basically the first element in the stack this is null then you have two"
987480,995960," uh right and then you have three and then at this point you decided you want to split this stack right"
995960,1002440," so your top is currently pointing here and at this point you want to copy the stack and just split it"
1002440,1009640," right so what you do uh you keep this top as a separate pointer and then you create a new pointer"
1009640,1015000," right and you put something like four uh right so maybe i want to choose a different color let's actually"
1015000,1021960," choose like a red one look a pink one so this is a four and uh you have two stacks in here so one stack"
1021960,1027720," pointing here and another one pointing in here right and then you decide that you want to put an element"
1027720,1035640," into the green stack right in that case um you will do something like uh this so this is going to be five"
1035640,1043800," and uh basically um you're going to have uh this node that is shared between two stacks right so the"
1043800,1051160," first stack is here right if you follow down here is the stack and uh if uh on the second stack you have"
1051160,1058920," this stack but in this sort of share like a part this sort of share a part so when the elements of these"
1058920,1065560," stacks are shared uh it's kind of dangerous to just like blindly remove them right so if you start popping"
1065560,1071960," elements out of the stack you can't really remove elements that are shared so in our case we probably"
1071960,1078280," want to forget them right so imagine that you want to pop an element from this thing so you basically go"
1078280,1085000," to follow uh and uh make this uh think your new top and you're basically gonna forget this thing"
1085000,1090360," uh right then you decide okay let's actually pop uh another element out of this thing and this is going"
1090360,1096920," to be our new top and then you decide okay i want to push a new element in here right i want to push a new"
1096920,1103000," element in here so i'm going to put it here so this is going to be something like six and this is my new top"
1103000,1107960," right so you have two stacks in here the first stack starts somewhere here and the second stack"
1107960,1113640," starts somewhere here so here is the first stack and here is the second stack and this basically"
1113640,1121240," becomes unreachable node right this becomes an unreachable node uh but you quite easily"
1121240,1128600," uh can copy this entire thing so it's super easy to implement something like that in a low level language"
1128600,1135320," where you just like create and leak the nodes and you don't have to copy like chunks of like memories"
1135320,1141560," and stuff like that you just like pile things on top and it makes it super easy so the question is um"
1141560,1147720," what do we do with sort of like a leaked nose is it is everything clear so far by the way because"
1147720,1151640," i'm not sure if i make any sense right is everything clear what i'm trying to say"
1156440,1162040," so is there something like yeah so you have this approach where you can just pile and leak the notes"
1162040,1169800," and don't get scared of the idea of leaking notes right i know that uh like we i have a lot of cs"
1169800,1175960," grads in the chat who are super scared about leaking anything right because it's super dangerous because"
1175960,1181960," their professor is gonna like punish them for for that right but uh here there's no your professor in here"
1181960,1189080," uh trust me it is okay to leak a little bit of memory it is totally okay to leak a little bit"
1189080,1195720," as long as it is as it doesn't consume your entire memory it's okay to do that uh so"
1195720,1200520," uh anyway"
1204680,1211880," it's 2021 just buy more ram exactly that's exactly what i'm talking about uh so here's an interesting"
1211880,1222120," thing um we can basically pre-allocate a fixed amount of nodes so usually when i uh work with"
1222120,1229480," like trees or linked lists and stuff like that uh the things that have fixed uh size nodes right they have"
1229480,1237560," fixed uh sick sick um i'm reading your nickname and i'm trying to say thick or fixed uh thick size nodes"
1237560,1243320," yes uh thick auger thank you so much for twitch prime subscription uh really appreciate it okay so"
1249000,1256360," usually when i'm working with a data structure with a fixed size nodes i like to pre-allocate uh fixed"
1256360,1263320," amount of uh such nodes right so i like to pre-allocate like an array somewhere in the in the static memory"
1263320,1271080," right somewhere in the static memory thank you so much damis ve for twitch prime subscription um"
1273560,1277640," so maybe i want to actually make this entire thing a little bit thicker so you can see"
1277640,1285880," so here's what we have and each of these elements of that array is going to become a node uh that you"
1285880,1293320," can use for building this data structure right so and essentially i would uh implement a simple like"
1293320,1300200," bump allocator on top of that array uh every time i need to allocate a new node i will just grab this node"
1300200,1306760," and move uh the pointer to uh to the next thing right so i move it in here and then allocate another one"
1306760,1312280," and then move it in here and so on and so forth so that way i just like linearly like um you know"
1312280,1318360," allocating these nodes and within these nodes you can refer to other nodes via the pointers and stuff"
1318360,1323640," like that so basically this entire data structure can be linearly stored in some sort of like a global"
1323640,1331160," array with fixed pre-allocated uh nodes right and that way i'm basically allocating the um the nodes"
1331160,1337960," myself right and here's an interesting thing as i already said this entire approach is leaking the"
1337960,1345480," nodes right it is leaking the nodes but maybe for our type checking process it is okay to dig them"
1345480,1352520," right maybe our type checking process is not going to produce that much of a waste right uh it doesn't"
1352520,1357560," produce that much of a waste that it will be okay if some of these nodes are leaked right and if there"
1357560,1364120," is not enough nodes we for the time being we can just basically allocate bigger buffer and as we uh"
1364120,1370760," get to some you know stable point we can implement like a dynamic uh dynamic growing thing in here uh that"
1370760,1375960," basically like grows as you need more and more nodes and you don't have to uh deal with the fixed ones"
1376520,1382040," uh but maybe it's not going to be okay so we'll have to somehow estimate how much uh waste our type"
1382040,1388200," checking process produces and if it does produce uh waste that we want to clean up how we're going to"
1388200,1394280," clean up uh sort of like this um leaked nodes right how we're going to clean up this uh you know"
1394280,1402120," leaked nodes so i think we're gonna uh we can implement a more sophisticated allocator in here right we're not"
1402120,1409240," gonna only uh like bump allocate things right uh we want to be able to free the nodes right we need an"
1409240,1417240," ability to free the nodes uh since we don't need them um and um how we usually do that usually i create a"
1417240,1425160," second array where i keep track of the freed nodes right so essentially i allocated a bunch of nodes in here"
1425160,1433960," here and then i want to free this one before freeing this one i will grab its index i'm gonna put it in"
1433960,1441880," the array of free uh nodes right so i know that this thing is free and this is in my list and the next"
1441880,1448200," time i need to allocate a node again instead of like bumping these nodes all right allocated nodes i will"
1448200,1456120," just look at the array of free uh free nodes and grab the one by index 2 and reuse it right so basically"
1456120,1462920," by adding another array we have an ability not only allocate nodes but also free them right and then"
1462920,1468680," later we use them so it's a very simple allocator right implementing an allocator for fixed sized objects"
1468680,1474840," is actually super easy it is difficult to implement an allocator for objects of variant uh size right as a"
1474840,1479800," a matter of fact i think i made like a series of videos on that on my uh on my youtube channel i'm"
1479800,1484920," i'm pretty sure i did it's something about writing your own malloc and free and also writing your own"
1484920,1489720," garbage collector and stuff like that so i really recommend to check it out um so let me see"
1489720,1500040," so ding um malloc uh let me let me see so write in your own malloc and see uh right i really recommend"
1500040,1504680," to check this out i think i think that stream was actually very interesting i really enjoyed doing it"
1504840,1512840," uh okay so i'm gonna put that thing in the description i'm gonna put that thing in the"
1512840,1521880," description so writing my own malloc in c right but here we were trying to implement an allocator for"
1521880,1528200," like a variable size objects which is rather difficult to do fast uh here we have an allocator for a fixed"
1528200,1533720," sized object which is super easy you just have to erase the first array is pre-allocated objects and the"
1533720,1538760," second array is the index of you know free objects that you can reuse in the future it makes it super"
1538760,1546040," easy okay so we have an ability to allocate nodes for our weird data structure and we have an ability to"
1546040,1553240," de-allocate them but the question is how do we even detect that some of these nodes are leaked right"
1553240,1560120," because we cannot just de-allocate nodes as you pop them right because if you if you have a stack in here"
1560120,1565560," you pop this thing you de-allocate it okay but now you're pointing in here and now you pop again and"
1565560,1572120," you de-allocate this thing but this thing is pointed by uh this stack right so uh you have to be careful"
1572120,1579000," you cannot just like blindly de-allocate nodes right which can be like reused by other things so we could"
1579000,1586040," take an approach of um you know reference counting as you can see we can clearly see that that node is"
1586040,1595000," actually pointed by uh two things but here is an interesting thing um okay so this thing is pointed"
1595000,1605800," by um maybe we can actually use that can we um maybe we can use a reference counter this is actually"
1605800,1612840," rather interesting so uh yeah we can try to use a reference counter another interesting approach like"
1612840,1620360," instead of reference counting would be to do a simple mark and sweep garbage collector uh as well"
1620360,1625640," um i'm not sure if reference counter is going to actually work properly we'll see we'll see uh but uh"
1625640,1632200," then the second option is going to be um basically mark and sweep because we know where uh the stacks"
1632200,1639800," start right so we can take this roots and we can bfs this entire thing marking what's uh reachable and"
1639800,1644600," then since we have an array of all of the nodes we can quite easily see what's unreachable and just"
1644600,1651400," deallocate it like that so this could be another way of doing this kind of stuff um so but if we implement"
1651400,1656920," this simple mark and sweep that means we'll need to decide at which point to call that mark and sweep"
1657480,1669000," um this could be interesting actually um uh so we could call it when there's no more nodes right so"
1669000,1673720," it's actually rather interesting so if you're trying to allocate a new note you see there's no more nodes"
1673720,1678840," uh right you can try to do mark and sweep and just like uh delegate some memory but if you can find"
1678840,1685080," anything it's basically overflow um okay so and the question is which one is going to be easier to"
1685080,1690360," implement we can actually explore uh different approaches in here right so we can try to implement"
1690360,1698440," reference counter and then maybe mark and sweep uh if we have enough time right is everything clear so"
1698440,1704840," far what we're trying to achieve is everything clear the cool thing about this approach is that it doesn't"
1704840,1709560," require like garbage collection or anything like that because effectively we're implementing our"
1709560,1716600," own allocator and our own garbage collector but since we're implementing a very specialized garbage"
1716600,1722360," collector and very specialized allocator it is actually easier than implement like a general"
1722360,1727560," purpose malloc and free and general purpose garbage collector that has to work across several threads and"
1727560,1733400," stuff like that right we're not trying to implement our own garbage collector that is like in python or like"
1733400,1738520," in go because these garbage collectors are very very very generic they have to work for all of the"
1738520,1743640," possible sizes of the objects all of the possible use cases they're very sophisticated a lot of computer"
1743640,1749000," scientists like uh defended like a lot of phd thesises on that and stuff like that we're not doing that"
1749000,1754680," we're implementing like a very speed uh like a garbage collector for a very very small specific case"
1754680,1761880," which is uh hundreds times easier hundreds times easier so and this is kind of like kind of reminds me about"
1761880,1770280," uh the situation with like um game engines right so i used to implement like games on this channel i'm"
1770280,1776200," gonna do game development uh at some point again so and people were constantly asking me like why do you"
1776200,1786200," implement your own engine uh drake siren thank you so much for 11 months thank you thank you thank you"
1786200,1792200," thank you so people were asking why do you implement an engine and this is because when people hear a game"
1792200,1799560," engine they instantly in in their head imagine something like unity or unreal engine and something"
1799560,1807320," like that but the reality is i was not trying to implement unity or unreal engine because they are very"
1807320,1815320," generic very generic very big engines what i was trying to implement is a very small uh engine in"
1815320,1821800," which i can implement my very small game right to implement a very simple small game you don't need"
1821800,1828120," whole unreal you don't need whole unity you like actually need like a small very small fraction of"
1828120,1834440," the functionality of these engines and implementing that fraction is way easier than implementing the like"
1834440,1839800," unreal engine or unity or whatever godot how many engines we have these days i don't know i never used"
1839800,1845960," any of them so uh and this is kind of a similar situation right so uh why would you implement your"
1845960,1851240," own garbage collector well i'm not trying to implement the garbage collector like in java or like in python"
1851240,1856440," or like in go like i'm not doing that i'm implementing garbage collector that works in very"
1856440,1863080," very specific narrow situation very very specific narrow situation which is 100 times easier than"
1863080,1868200," implementing something like in java right here we have to just like you know garbage collect like"
1868200,1871080," fixed size nose for a very specific data structure"
1871080,1880200," you see what i'm talking about it's kind of like similar this entire idea of like implementing like small"
1880200,1887560," all portion of functionality um that does your job like works not only in game development it like works"
1887560,1902120," across the like software development generally um"
1902120,1914200," okay so i'm not really sure um it looks like we can use counter f because counter f will probably make it"
1914200,1921080," super easy uh but i also kind of want to have an excuse to implement markets we mark and sweep garbage"
1921080,1927160," collector so we'll see anyway let's actually start uh prototyping this entire thing i decided to um"
1927160,1935000," try to prototype this thing in rust uh because why not um so because prototyping this kind of stuff in"
1935000,1939960," port is kind of difficult because port is really low level language and it's kind of difficult to follow"
1939960,1945560," right now because it doesn't have like a lot of good semantical and syntactical um sugar and stuff like"
1945560,1951640," that so i decided let's just prototype this idea in rust see how it works in rust and then i'm gonna just"
1951640,1958920," pour the port port port this entire thing to port right uh and then re-implement the type checking of"
1958920,1965080," port in port uh anyway i hope everything is clear i'm not gonna close this thing yet and uh let's go ahead and"
1965080,1975560," implement this entire thing port port so uh how should i call this thing uh persistent stack right"
1975560,1985480," so here's the folder and i'm gonna do main dot rs more like my ass haha got him anyway so let's write"
1985480,1990920," a simple hello world right so here's hello world because i haven't programmed in rust for quite some time"
1990920,1995480," so i don't remember a lot of things so let me see if i still remember how to write"
1995480,2001000," uh a simple hello world if i remember correctly you have to do rust c uh right so"
2001000,2005880," it will take some time you need to recompile everything"
2005880,2016200," okay and it compiled uh so and then uh if we take a look at what we've got we've got a single executable"
2016200,2023880," 3.3 megabytes executable uh so what's the size of the entire port compiler"
2023880,2033080," uh okay so the size of the entire port compiler is actually for 428 kilobytes uh but the size of a"
2033080,2040600," single hello world is 3.3 megabytes so uh yeah i mean it probably has like debug information or something"
2040600,2046760," that uh anyway so here's hello world um so i wonder how big is it going to be if we like strip it"
2046760,2052600," is it going to be smaller no it's actually small it's actually smaller than the entire port how about"
2052600,2060760," that uh anyway so it was primarily some debug information um okay cool so we need to implement"
2060760,2066840," uh the type stack right we need to implement the type stack and to implement the type stack we need"
2066840,2073640," uh the data type right so let's actually introduce it so i think i'm gonna since port has like three"
2073640,2080840," types right it has uh integers pointers and booleans uh let's actually encode them as enumeration right"
2080840,2086200," so we're going to say data type uh and the first data type is going to be an integer so here's an integer"
2086200,2091720," then we're going to have a pointer and then we're going to have a boolean right so this is primarily for"
2091720,2096600," the demo purposes right so it's not going to have any meaning it's just something that we want to put"
2096600,2101160," into the stack right so and on top of that we probably want to actually derive something like"
2101160,2106680," debug so we can um you know read that and so on and so forth so maybe this entire thing is going to"
2106680,2114520," be clonable and copyable right uh int 82. thank you so much for two months of tier one subscription"
2114520,2119400," thank you thank you thank you and welcome to our epic rust club finally we're doing rust we've been"
2119400,2124200," talking for like half of an hour about ports and stuff like that but finally we're programming in"
2124200,2132440," rust uh anyway so let's actually implement uh like a single node that is going to hold our data type"
2132440,2139960," uh right so let me let me think so it's going to be basically a structure and i want to call it a frame"
2139960,2145960," right because since we're doing a stack uh the elements of the stack are usually called frames i think"
2145960,2151880," right usually right i don't know maybe it's it's specifically for call stacks all right so this is"
2151880,2158440," going to be uh a frame and uh we're going to have uh something like type type is already taken so let's"
2158440,2163400," call it data type right and this is going to be just a data type and we need to keep track of the"
2163400,2167960," previous frame right we need to keep track of the previous frame so i'm going to do previous uh which"
2167960,2175800," is going to be basically a box to a frame uh but i suppose it has to be optional right so uh something"
2175800,2185560," like this but here's an interesting thing since i want um since i want to pre-allocate a lot of frames"
2185560,2193960," right i want to pre-allocate a lot of frames um maybe it would be easier to actually refer to those frames as"
2193960,2201000," as why the indices in the pre-allocated array if you know what i'm talking about right so essentially"
2201000,2207400," we can have something like struct uh frame alloc right frame allocator uh let's call it a frame"
2207400,2216040," ator right so basically ator stands for allocator the same way ctor in c plus plus stands for constructor"
2216040,2224360," constructor constructor detour stands for destructor destructor uh in our case ator is going to uh stand"
2224360,2232440," for allocator allocator right so so we're going to call it frame ator sounds good sounds good sounds"
2232440,2238440," to my Gucci okay so and uh basically what we can have in here we can have frames right so it's going to be a"
2238440,2247320," vector of frames uh and frames essentially are going to refer to a specific index within that array of"
2247320,2253080," frames right it's going to be something like you size and by doing that by the way we will make the borrow"
2253080,2262520," checker shut up right so essentially here is the trick if you don't want to deal with the borrow checker"
2262520,2268680," and all of this nasty stuff uh lifetimes and whatnot just switch from pointers and reference and stuff"
2268680,2274120," like that to indices within array and that way you disable borrow checker this is like a small trick"
2274120,2280680," for all of you rust developers out there who got tired of borrow checker this is how we do that and so"
2280680,2288760," yeah so not everybody knows that but in rust there is a way to disable borrow checker without"
2288760,2293720," unsafe block you don't even need unsafe block you just like use indices instead of pointers and there"
2293720,2302600," you go you you have no borrow checker uh so uh indices instead of pointers is actually more common"
2302600,2307160," pattern for more complex data structure of course because for more complex data structures you need"
2307160,2315080," to disable borrow checker of course it is a common power for that so obviously if you're doing anything"
2315080,2320120," complicated you want to make the borrow checker to shut the up uh so that's why you're going to start"
2320120,2331960," using indices anyway so here are the frames and um so we also need to um keep a list of the free frames"
2331960,2336440," right so let's actually do something like this free uh vector use size"
2339880,2348120," okay so uh to do two i have a couple of interesting ideas so uh let me see let's make an implementer"
2348120,2354040," an implementation for frame 8r it's a little bit cold in here to be fair it's a little bit cold in here"
2354040,2363560," maybe i should put on my uh my sweater anyway uh okay so what do we need in here uh we need to be able to"
2363560,2373160," allocate a frame right uh so so let's implement some stuff in here i'm going to derive the default for"
2373160,2379640," this one and also the default for this one uh and we need two operations we need to an operation that"
2379640,2385800," allocates a frame right so this thing will take a mutable self and will return the actually it will"
2385800,2394680," return use size uh and then we need a way to free uh free a specific node so it's going to take a mutable"
2394680,2403400," self and then uh to let's call it an index right use size and stuff like that so i'm going to mark this"
2403400,2413560," as to do uh here's a very annoying thing um it's unclear like use size it is unclear that by use size we"
2413560,2421000," mean an index within this allocator so i think it would be nice to have an a type ls called something"
2421000,2426840," like frame uh frame index right so it's going to frame index it's going to be basically use size"
2426840,2432600," uh i don't remember if you have to put semicolon here maybe maybe you have to so and uh now instead"
2432600,2438840," of use size if we mean uh like an index we're gonna actually use a frame index in here frame index"
2441960,2449560," so uh alrighty cool uh another interesting thing i want to have in here i want to be able to dereference"
2449560,2455160," the index if you know what i'm talking about right so you have an index and uh you want to take the"
2455160,2461800," reference to the frame by that index so let's actually implement something like uh deref uh right deref is"
2461800,2467880," deref like a special method in one of the traits it feels like it is but i'm not a rust developer so i'm"
2467880,2473960," going to stay ignorant and just like use this word uh right so this thing uh if deref is going to be"
2473960,2479160," actually immutable so i think we're going to grab it as immutable uh we're going to accept the index"
2479160,2486360," and i want this thing to return um immutable reference to the frame right so and of course"
2486360,2491560," uh we have to have immutable variant of this method as well so we're going to have derived from mute"
2491560,2495560," uh and this thing is going to just return the mutable reference so this thing i think this is"
2495560,2502280," all of the operations that we want to have for this specific allocator right uh let's go ahead and"
2502280,2507880," implement them all so first i want to check if this thing even compiles so it's going to be a rust c main rs"
2510680,2518440," so data type there is no default for the data type which is rather interesting uh so maybe we don't wanna"
2518440,2522680," it's interesting so"
2522680,2531880," i think we don't need that okay so everything's fine everything's fine we have a bunch of uh a bunch of"
2531880,2538920," warnings but they don't matter they don't matter at all uh okay so when we are allocating think uh first"
2538920,2545000," thing i want to do uh so imagine that you have a frames right so we have a bunch of frames in here"
2545000,2554440," so frames is equal to like uh something um a b c and d so what's interesting is that if you take a length"
2554440,2564120," of the frames right if you do length uh it will point to the element after the last one right so length is"
2564120,2572760," equal four the elements are numbered from zero zero one two three and four is pointing here so that means"
2572760,2579880," this is basically what you need to return uh to the user who calls a lock right so we're going to do"
2579880,2589640," something like a result right here's the result uh and then uh we need to basically push a new frame"
2589640,2594600," which essentially means that we need to have maybe a default implementation for the frame"
2594600,2601080," or maybe we're going to accept initial value uh through that method which we're going to move"
2601080,2605880," inside in here so we're going to actually accept it by value which essentially moves if i remember"
2605880,2610680," correctly rust moves the elements by default into this thing and we're going to just move it into the"
2610680,2615400," uh into the vector right and after that we're going to just return the result there we go so we"
2615400,2620600," implemented a simple allocator but it doesn't take into account the free right so um we're going to"
2620600,2624360," implement that a little bit later we're going to implement that a little bit later or maybe"
2624360,2630920," we're going to implement that way later when we actually try to implement the you know memory"
2630920,2636280," re-usage strategies maybe for now i'm going to just leave it as it is uh we won't be able to free"
2636280,2643320," anything uh and i'm going to go ahead and try to derive this thing right so uh what we're going"
2643320,2650280," to do in here we're going to take the frames uh right and i'm going to try to get though we can"
2650280,2656760," actually try to be a little bit more safe in that regard right because if i remember correctly"
2658440,2665720," if i remember correctly rest up docs api so let's take a look at the vector"
2665720,2673240," where is the vector so here is get could have actually searched specifically for vector get"
2673240,2680280," right can you do something like that in in here uh it does not return me it's very very weird because"
2680280,2686440," is that because vector doesn't have a get or is that because this uh website is just like not working"
2686440,2693640," correctly correctly because i remember vector i had get uh or am i no it doesn't have get huh"
2693640,2697080," it's really strange okay"
2697080,2703800," does it have get or not i don't remember"
2703800,2715800," um get to get get get there is get okay there is gets oh all right that makes sense uh anyway so"
2715800,2721640," essentially the reference is going to mean that uh we just do get right so we just get by that index"
2721640,2728680," um and index could be incorrect by the way"
2728680,2734280," uh so and we're also going to do a similar thing for a mutable one right"
2734280,2741400," i'm going to do a similar thing for a mutable one so if i try to build this entire thing so it fails"
2741400,2747080," is because this thing is supposed to return option uh right so is it going to compile now uh what do"
2747080,2753320," we have in here uh consider to change this to mutable yeah this one has to be immutable oh sure"
2753320,2759160," and there we go so everything seems to be working okay so we have uh frames we have data types we have"
2759160,2765800," allocators and stuff like that i think the time has come to implement a stack on top of that allocator"
2766360,2771480," right the time has come to implement a stack on top of that allocator so let's actually create a structure"
2771480,2777960," and um so how we're going to call that i'm going to call it type stack right so this is going to be type stack"
2779720,2785960," and that type stack is going to have just a pointer to the top right so this is going to be just that"
2785960,2794520," uh option um frame index there we go so this is basically what we have in here uh type stack"
2794520,2801800," and in here uh what we're gonna have we're gonna have an operation that pushes uh a specific data type"
2801800,2808360," right so we're going to have data type of course we're going to take a mutable self then we're going"
2808360,2814600," to take data type and another important thing is we're also going to take an allocator right we're"
2814600,2819640," going to take an allocator maybe i'm going to take it as the second uh parameter in here because this"
2819640,2826040," operation will allocate a node and it will allocate it into this uh allocator right so we're going to take"
2826040,2834280," it as mutable one uh so this is going to be called frame eta uh and there we go uh so this is what we"
2834280,2843880," need in here and uh when we pop something uh since popping does not really does not really free anything"
2843880,2849240," because we're not implementing any memory preserving strategy uh we're not going to take an allocator"
2849240,2854360," right so if we're going to do pop we're going to just pop that thing uh there we go cool"
2855960,2863400," so uh let's actually you know create the allocator somewhere uh so this is going to be immutable eta"
2863400,2869480," uh and we're going to do frame eta default all right so we're going to create a default frame"
2869480,2877560," allocator then we're going to create uh the stack uh type stack uh default and we're going to try to push"
2877560,2885880," a bunch of things onto that stack right so i'm going to do stack push um so we're going to do a mutable"
2885880,2894200," parameter data type uh pointer data type pointer uh then integer and then the boolean and then i"
2894200,2900280," want to be able to basically dump the content of that stack just to see if it even works or not so"
2900280,2906280," we're going to do something like stack uh dump uh right and it will just dump it to the standard output"
2906280,2910760," so we'll have to implement this entire thing is everything clear so far what we're trying to do in"
2910760,2916280," here right so we implemented like a simple frame uh we implemented allocator that pre-allocated a bunch"
2916280,2923160," of frames and now we're implementing stack that allocates all of its nodes into into that allocator"
2923160,2928520," right so we're not doing anything special so far right so we're only preparing so it's just like a"
2928520,2934440," setup and the punchline is going to be a little bit later hopefully if there will be one i'm not even"
2934440,2943960," sure if there will be a proper punchline we're just exploring things um okay so we're going to take um"
2943960,2952760," a mutable self yeah immutable one so let's see if this thing even compiles still so we don't have a"
2952760,2962360," uh uh default thing so let's create it like that derive default uh let me see okay so everything seems"
2962360,2969080," to be fine and if i try to just call this entire i think it should fail with not implemented right so"
2969080,2976600," it panicked at 48 and it couldn't push anything in here okay cool so uh what we're gonna do um we"
2976600,2985160," want to create a frame right so in allocator fn alloc uh so we have to provide the frame"
2985160,2991640," so and inside of the frame uh right inside of the frame we have to provide the data type so i can just"
2991640,2999400," do data type uh right so they have the same name so i can just use it like that and now i can do a"
2999400,3006280," very interesting thing i can set the previous to the top of the stack so i can just do self top and"
3006280,3013080," so this is the previous right there we go uh so and previous if i remember is optional yeah it is"
3013080,3019480," optional so and then i'm basically allocating this frame and i'm moving it inside of the allocator and"
3019480,3027320," this thing returns me a new index that i want to uh assign to the top i wonder if the borrow checker is"
3027320,3031880," going to be okay with that uh so and also this thing has to be wrapped in some and i think this is"
3031880,3037320," basically the entire push i think am i missing anything i don't think i'm missing anything right"
3037320,3044040," so the only problem is that this kind of stuff could be you know like maybe borrow checker is not going to"
3044040,3054280," be okay with that we'll see um we'll see we'll see uh why are you not trusted i live i'm really sorry so"
3054280,3061720," let me actually trust you so the bot is not going to ban you anymore really sorry uh self top uh needs"
3061720,3069880," some uh well we'll see the compiler will tell us okay uh wasn't even linked well self top wasn't so"
3069880,3076760," is there even a top domain right there should be like a pair of domain top and bottom domain right"
3077720,3085960," uh all right so there we go so it's not really compiling so it's 56. uh okay so that actually"
3085960,3093000," worked uh that actually worked uh cool the borrower checker has improved over the years so we can even"
3093000,3098360," now write one liners like that i don't know why i feel like the borrower checker would be not okay with"
3098360,3104040," that but it's still be fine uh okay so now if we want to dump something how are we going to dump that"
3104040,3109880," um we can just basically iterate through the through this thing right so we can do something like a"
3109880,3122280," mutable uh top and then i can just copy the top and basically while let some index uh equal top we're"
3122280,3129400," going to oh we need an allocator to de-reference the index that's very interesting actually"
3129400,3133960," right so you have an index but you can't access the frame without the allocator so we'll have"
3133960,3140120," to actually uh grab this thing like so eta uh actually we don't need to be uh we don't need"
3140120,3145960," the uh iter to be mutable so we're going to grab it as a mutable one uh right then i do de-ref right i"
3145960,3152600," derived the index and that gives me the frame which i can now print uh so let me quickly try to do that"
3152600,3159960," so this is going to be something like this uh right uh so i de-reference this thing and i just grab"
3159960,3166040," the data type uh within that stuff so it will just you know dump all the elements of that stack and"
3166040,3173560," then here uh top is going to be equal to you know what i think we need to save that pointer right so"
3173560,3181560," this is going to be frame uh right then i use the frame like this and then the top frame uh previous so"
3181560,3185720," it's going to be it's going to print that in like a reversed order but that's fine i guess it because it's"
3185720,3191320," like a debug information anyway uh right so let's actually try to compile this entire thing and"
3191320,3197640," something didn't really work well because this thing has to be debug right it has to be debug output"
3198200,3209080," uh are you going to be fine now let me see so data type uh no field the oh this one is optional one okay"
3209080,3216600," so we know for a fact that index is a valid index right so and if it's invalid index that means uh we"
3216600,3224440," made a mistake somewhere so we're gonna unwrap it in here by the way this is an equivalent of the uh of"
3224440,3230520," sec folds right if you have an invalid index and you try to put an invalid index in here and you unwrap"
3230520,3235800," like that this is essentially trying to touch the memory that you're not supposed to touch this is"
3235800,3243320," literally a sec fold right we do we disable the borrow checker to the point that we can now have"
3243320,3249720," sec folds or something that's you know simulates sec fold like imitates the sec folds you know what i'm"
3249720,3256760," talking about isn't that interesting actually uh when you start using indices instead of pointers"
3256760,3261480," you're actually getting back to all these problems that borrow checker is supposed to solve so you have"
3261480,3268520," to be constantly aware of that while you program programming in in rust right so you have a way to"
3268520,3273640," disabling borrow checker but once you do disable borrow checker you have to be aware that you're bringing"
3273640,3278520," back all of these problems that borrow checker is solving right so and this is basically where you"
3278520,3291400," can suck fault if you have like incorrect index um so anonymous user gifted a tier one sub to olive"
3291400,3298680," is a word thank you so much anonymous user for uh a gifted sub and olive is a word welcome to epic rust club"
3298680,3310760," cheers by the way um okay so uh let me let me see so that's fine let's see if it's gonna work"
3310760,3321720," okay so uh we have to supply the allocator uh and it worked look it printed boolean integer and pointer"
3321720,3327480," and we push them in a different order in a reversed order right pointer integer and boolean uh so the"
3327480,3335240," stack actually works uh so then we can try to do some other things so we can try to pop uh pop the stack"
3335240,3341560," and as we pop it uh i think we don't really need anything right so let's give it a try"
3342360,3350280," uh because pop in the stack is essentially well yeah we we need to take the allocator but we need to take"
3350280,3355800," the allocator as immutable one right because we don't need to allocate anything within that allocator"
3355800,3362040," so this is going to be frame eta uh let me go and then what i have to do i have to do frame"
3362600,3374200," eight uh the ref uh the ref um to do to ah this one is interesting so right if you try to pop the empty"
3374200,3380680," stack right so the empty stack we will have nothing should we allow popping from the empty stack let's"
3380680,3389720," actually allow that so if let some index equal self top right uh we're gonna do reference that index and"
3389720,3398520," we're gonna unwrap it right uh and then i'm gonna do self top frame uh previous right there we go"
3398520,3405080," so that's basically what we want to have in here so then i'm popping this entire thing uh okay okay"
3405080,3413160," so i have to provide the immutable data uh okay still doesn't work types differ in mutability are"
3413160,3419640," you sure about that because yeah i didn't think we need that there we go so as you can see"
3419640,3426520," see we pushed uh pointer integer and boolean then we popped one element right now we have integer and"
3426520,3434200," pointer uh and then i can do push right i can push this thing back uh let's actually push uh another"
3434200,3440600," pointer right so what we should see we should be able to see pointer integer point without any boolean"
3440600,3447400," uh and as you can see everything works but there is an interesting thing in here uh this pop leaked a node"
3447960,3454840," right there's only three elements there's only three elements on the stack but we allocated um"
3454840,3465880," basically there's four nodes taking we can even see that um okay we can do something like uh to the two"
3469000,3478840," allocated uh nodes and we can just go into the allocator uh it's actually frames uh frames and"
3478840,3485560," take the lengths of the frames right so this is basically what we can do uh to the two print ln has"
3485560,3492040," to be a macro there we go so as you can see uh there is three elements on the stack but we allocated four"
3492040,3498120," frames so some of them so some of them are um you know actually wasted so which is rather interesting"
3498120,3507640," which is rather interesting so uh the most important thing here is um being able to copy the stack"
3507640,3519880," right we want to be able to clone the stack um and to be fair i think we don't really need to do anything"
3519880,3527640," special to do that right so if we just enable clone and copy just copying a single number is already"
3527640,3533320," copying the whole stack so this is the beauty of this approach you need to split the stack you don't have to"
3533320,3537880," copy anything you just have to copy a single number and there you go now you have two stacks"
3537880,3547640," pretty cool uh azura akumori thank you so much for two uh thank you so much for two months of uh twitch"
3547640,3553640," prime subscription thank you thank you thank you and welcome to our epic rust club uh okay so that's"
3553640,3559560," pretty pogue so if we just allow leaking the memory so it's already working so you can actually split"
3559560,3566680," the stacks and you know do this stuff quite easily so uh thomas uh thomas 1992 thank you so much for"
3566680,3570840," twitch prime subscription thank you thank you thank you and welcome to epic uh rust club"
3570840,3581960," okay so let's actually test how this thing is going to work so here is the stack so let's call it"
3581960,3591000," something like stack one right so uh we allocated we basically pushed a bunch of stuff onto the stack"
3591000,3597880," right then uh i want to create a copy of that stack so i'm going to do stack one uh stack two and i'm"
3597880,3603480," going to assign stack one to that basically copying it hopefully am i copying it i think i think i have to"
3603480,3610040," explicitly say clone uh well i mean i don't have to explicitly say clone because i said copy but let's"
3610040,3615640," actually remove copy so we have to explicitly do the clone uh so we can see that we actually cloned the"
3615640,3624440," stack okay so we created the stack we cloned it and uh now we can try to modify the stack one right"
3626040,3632600," so stack one uh i'm going to pop the elements from the stack so it's going to be eta and uh then i'm"
3632600,3642120," going to push uh eight data type uh pointer right so and what i want to do in here is uh i want to print"
3642120,3649880," both of the stacks and just see that the um the copied stack still retains uh its original structure"
3649880,3654600," right i want to just confirm that copying the stacks actually works and no matter what you do with other"
3654600,3659960," stack with other copy of the stack the copy of the other copy of the stack is actually stays retained"
3659960,3668040," right if you know what i'm talking about um okay so let me see so we want to print something like print ln"
3668040,3677160," uh stack uh one right so here's a stack one and then we want to do this thing and this is going to be"
3677160,3686840," stack two so let me see all right so maybe i should have actually put a little bit more spaces in here"
3686840,3692600," right so we're gonna just do something like print ln just to add more spaces is it going to be sufficient"
3692600,3698360," yeah it is seems to be sufficient okay stack one uh as you can see it contains pointer integer pointer"
3698360,3704680," because we pushed pointer integer boolean then after cloning it we popped the boolean and we pushed the"
3704680,3711000," pointer so that's why in stack one you have pointer integer pointer but stack two still retained its"
3711000,3719000," original structure boolean integer pointer the one that we had before cloning it um right so yeah the one"
3719000,3724440," that we had before cloning it so it still retained it uh even though we popped uh this stuff and uh you"
3724440,3731000," know the other stuff and it still allocated four frames so essentially instead of like linked list"
3731000,3738520," in reality we have a tree right so it kind of resembles the git history if you think about it"
3740760,3748200," yeah it actually kind of does this is basically a git history right we can even try to maybe dump this"
3748200,3759560," structure of the let's actually dump graph with how about that because we can do that right uh allocator"
3759560,3765240," has an access to all of the frames right so and in the frames we have the uh the pointers to the previous"
3765240,3770600," one so we can quite easily dump the graph with data and just look at this entire thing uh"
3770600,3777400," so let me quickly do that uh frame 8 error we're gonna do dump dot uh right so we're gonna take it"
3777400,3790600," as mutable um it's actually pretty cool i love how every stream turns into graphic stream only the ones"
3790600,3796040," where we have to work with the uh tree data structures right because every time you work with the tree data"
3796040,3800440," structure you want to kind of visualize the the tree and the easiest way to do that"
3800440,3809560," is uh is graphics so why not um all right so let's do print ln and this is going to be d graph and"
3809560,3816120," we're going to call it frame um i don't know stacks something like that right so this is going to be"
3816120,3823400," stacks uh print ln and we'll just do something like this so in here uh by the way visualizing this entire"
3823400,3828360," thing is going to be super easy because we don't even need any recursive algorithms so we can just iterate"
3828360,3836040," through all the frames uh right and just dump them as edges so that should be sufficient i think i think"
3836040,3846040," that should be sufficient so uh let me do it like so frame in self frames right there we go here we have a frame"
3847320,3855640," and um let's do it like this print ln uh one two three four uh it's going to be"
3855640,3866520," node and then id of the node and then we can have a label uh like so and this has to be like a debug one"
3867400,3874280," uh and then i can say okay i probably need to enumerate this entire thing right so i want to"
3874280,3879960," enumerate it so i have an index and the frame right so this is what i want to have in here so here's the"
3879960,3887080," index and uh then for the frame i have to take its data type uh and that should be sufficient enough and the"
3887080,3895080," thing the second thing i want to do in here well it only makes sense if you have the previous one right so"
3895080,3906760," we have to do something like if uh let some uh prev index uh equal frame previous uh we need to"
3906760,3916360," basically connect together these two nodes uh node that to node that so the first one is going to be just"
3916360,3921400," the index and uh this one is going to be the previous index and it only makes sense if you do have that"
3921400,3927640," previous right that's why we have a condition here and that should be enough uh so let's actually try to"
3927640,3934200," compile this entire thing so uh to two to two you have to do it like that thank you compiler very cool"
3934200,3942360," uh oh do i have to like escape this entire thing i don't really know how do you type it do i have to do"
3942360,3947320," double of this thing uh i think i think you have to do double i actually like you guessed it i think"
3947320,3953000," um enumerate uh exists only for but its trait is not satisfied"
3953000,3961400," so do you want me to do eater do you want me to do eater or something yeah i wanted me to do easier okay"
3961400,3968120," cool uh so let me see now instead of doing that we can do something like a third dump dot right so let's just"
3968120,3978600," dump the dot uh and uh here is the basically graph with data structure of these nodes uh it would be"
3978600,3985160," nice to actually save that to some sort of a file right um so to save it as some sort of a file i think"
3985160,3993320," dump dot should accept uh you know the sync into which you want to save all of that right so and sync is"
3993320,3999800," basically going to be anything that implements um you know writeable interface right so we want to have"
3999800,4004360," something like this if i remember correctly to write into this writable interface you have to do something"
4004360,4013720," like write alone right and then you just use sync uh and i feel like we have to get it by a mutable"
4013720,4021640," reference right so i don't quite remember how to do that so the compiler will tell me hopefully"
4021640,4027960," and hopefully the compiler will tell me but anyway uh write is not found okay so let's actually"
4027960,4036280," try to see where write is located where write is located so it's located in somewhere in ier"
4036280,4047640," right so we have to do something like use std are you right okay so uh okay this entire thing"
4048120,4054600," we can do something like um expected nothing um expected results so we have to what would be easier"
4054600,4061560," i think the easiest thing to do in here would be to like dump dot to return are your result nothing"
4061560,4071400," right like this and for each individual right we could like put a question mark in here so in case of"
4071400,4077880," like error uh it will just fail and then at the end in here we can just do okay is that how we do that in"
4077880,4084440," uh in rust i think i think this is how we do that in rust right the usual thing so and let's use stdio"
4084440,4092120," right so and then here i i guess at the end in here we want to like unwrap this entire thing but it"
4092120,4099000," complains about not being able to find the you know instance of writable interface so we'll have to open"
4099000,4105560," the file so if i remember correctly you have to like use file and you can basically create it right"
4105560,4112760," you can do file create in here yeah there we go so this is what we can do uh so let me try to do that i'm"
4112760,4123400," going to use stdfs file uh right and i can just can you just like you know file create file create uh"
4123400,4134600," output dot right uh output dot uh it didn't really well uh we have to unwrap it i suppose right so well"
4135720,4144200," so create uh should return option right a result rather should return a result and"
4144200,4152360," we accept by immutable so we can just do unwrap and then just do something like this this should work"
4152360,4158360," right so it seems to be working uh okay so and now if you take a look at output dot there we go here is"
4158360,4170920," our output dot isn't that cool i think that's pretty cool so um now what we can do we can just do dot t svg"
4170920,4181080," o output dot and it generated an svg file which we can finally open in chromium and there we go so here are"
4181080,4188200," the two stacks the first stack uh has pointer integer pointer and the second stack has boolean integer"
4188200,4196360," pointer right so we have two stacks and they share two elements uh they share two elements and we derive"
4196360,4202200," that information from the allocator right we derive that allocate the information from the allocator"
4202200,4208520," that's actually pretty cool so we have a very simple debug tool um cool"
4211080,4224360," uh to do but again uh i want to do the same thing as i did for the tree stream i want the program"
4224360,4229720," itself to actually you know call graphies and stuff like that but uh luckily in rust it's a little bit"
4229720,4237960," easier um right in rust it's a little bit easier to do because it has like command uh interface or"
4237960,4243400," something like that i don't quite remember um anyway so let's actually do it like this uh let"
4243400,4254360," output file path uh i'm gonna say this thing i'll put file path put it in here and we want to do a"
4254360,4263560," logging we're going to say info uh generating uh this thing uh output file path right file pass there we go"
4264280,4271240," so then we're generating this entire thing and then i want to call an external command but i don't quite"
4271240,4277880," remember how to do that so commands uh i do remember there was a command there we go so there's a process"
4277880,4285320," command and that's pretty straightforward i'm not gonna lie so you just create the command you provide the"
4285320,4295400," arguments and you take the output uh and then you expect that it didn't fail so okay so let's actually"
4295400,4307160," use that can your c do that by the way no it cannot do that uh process uh command in your stupid c you have"
4307160,4313640," you have to do fork exec and stuff like that you have to first fork a child then you have to execute the child"
4313640,4314840," you know the usual stuff"
4314840,4318840," anyway so um"
4318840,4322920," sorry um"
4322920,4331160," new dot uh and then we have to provide the arguments so this is going to be arcs and what can it be the arguments"
4331800,4340440," uh the first argument is going to be t svg then o uh and then we have to use output file path"
4340440,4347080," right and then we have to call the output and do we have to do the output because i don't really care"
4347080,4359560," about the output uh right but it feels like that you have to uh so fn output so execute the command"
4359560,4364440," as a child process waiting for the finished well you you have to do that apparently okay so but"
4364440,4372600," maybe i can just throw it away um so it's going to be arcs then the output then expect"
4373560,4388680," um expect dot uh command should have executed successfully but it didn't right uh to do to"
4388680,4395720," okay so if i try to now run this entire thing uh it didn't freaking work because this thing is not a"
4395720,4403000," macro yet again uh okay so what do we have in here consider using uh okay so we have to put the semicolon in"
4403000,4408600," here and uh cool it generated this thing but it didn't log the command that it was executing"
4408600,4413320," is there any way for the command to actually log what it's executing because it's not particularly convenient"
4413320,4415560," i think uh"
4415560,4420200," so there's a status"
4420200,4426760," uh i didn't think so is there something like echo"
4429880,4440440," no no no no status so you can use status instead of output is it is it going to echo the command uh"
4440440,4444600," is it going to echo executes command the chat process waiting for the finish by default the ceiling"
4444600,4450280," it doesn't echo so i need like echo the command because i want to see what's currently the command"
4450280,4458600," executing okay whatever so uh let's continue let's continue what's going to be the next thing"
4458600,4468760," uh the next thing that we wanted to explore is basically um some sort of a reference counting right um"
4468760,4471160," some sort of a reference counting"
4471160,4479320," but for a reference counting we need to be able to free the nodes right we need to be able to free the"
4479320,4486600," nodes um i think the easiest way to free a node is just straight up add"
4487400,4493480," that node to uh i mean yeah node to the list of free ones right there we go"
4493480,4500920," so uh right so we're trying to free a specific index and it goes into the listing here and when we're"
4500920,4507080," trying to allocate a new node uh instead of grabbing it uh from the uh from the vector first we have to"
4507080,4516280," check uh whether we have anything in the free right so this is what we can do in here so if uh self free len"
4516280,4524200," is greater than zero uh we have to basically reuse a single node from here otherwise we have to like"
4524200,4525320," allocate a new one"
4525320,4536600," so oh and here is an interesting thing here is an interesting thing you get back to all of these"
4536600,4541800," problems that borrow checker is supposed to solve what if you double free a node accidentally"
4544120,4551320," you're gonna add this node twice to the list so the next alloc is gonna you reuse already allocated node"
4551320,4559080," so you will have to add some sort of a check that checks that you're not trying to free already free"
4559080,4565720," node or that the node that you're trying to free is even correct so you're getting back you're getting"
4565720,4571240," back to all of these problems this is actually pretty amazing i think uh you're starting to have sec folds you're"
4571240,4574920," starting to have like double threes and stuff like that"
4574920,4586920," you should use static size arrays vec is kind of cheating uh i feel like you don't fully understand the"
4586920,4594040," meaning of word cheating cheating is going against the rules right at least this is the definition i know"
4595080,4601480," there's no rules what rules are you talking about so"
4601480,4606040," oh my god uh anyway"
4606040,4614760," imagine like accusing me of cheating in the environment where there is no rules like you"
4614760,4620600," by definition in that environment you can't cheat like it's just like you made up in your head your own"
4620600,4626120," rules and you're accusing me of breaking rules that you made up in your head well cool"
4626120,4634040," i'm happy for you uh anyway so i think i want to make a small break because i need to make a cup of tea"
4634040,4640200," uh so and after the break we're gonna uh we're gonna implement the you know allocation from a list of free"
4640200,4651560," notes anyway um okay so let's continue so how we're gonna actually get uh the free node i think we have"
4651560,4659000," to do a pop if i remember correctly in vec there is a very convenient uh method called uh"
4661000,4668760," let me see so where is here is the and what's interesting about is that it returns an option"
4668760,4675880," right uh which means that if this thing is empty it will return nothing so we don't really have to check"
4675880,4682680," uh the length uh what we can do is just like instead of flying we can do and uh here we can have some"
4683640,4691480," index uh rather some results right uh which we can just reuse in here so here is some result uh and"
4691480,4701320," essentially i need to do self uh frames result and i need to move the initialized thingy in here"
4701320,4705960," right so this is going to be in it and then i just return the result how about that"
4707320,4716600," how about that how about that looks cool yeah so that's basically what we're doing here i think"
4716600,4725960," uh to to the two so here's the result and then neat result result blah blah blah blah blah blah i'm just"
4725960,4732920," thinking like my brain sees a result in both of the branches and i keep thinking can i compress that"
4733800,4738520," if you know what i'm talking about uh and it feels like i can't really compress that and maybe i"
4738520,4745480," shouldn't bother trying to compress that so maybe that's fine that looks fine because the most logical"
4745480,4750120," thing in here is just like move it away like this but you can't do that because the result in one"
4750120,4754920," branch and result in another one are two different things um right"
4754920,4762680," yeah it's kind of difficult to compress this code i don't see a good way to do that and"
4762680,4771000," anyway it's going to be just like math okay go uh so we implemented free"
4771000,4778520," and every time we pop something we can now um we can have three things"
4778520,4788360," how can we test this entire stuff uh let's go ahead and just remove uh the stack two and let's just"
4788360,4795960," work with the stack uh stack one right so we're going to only have stack one and every time i pop something"
4795960,4802760," from the stack right so we are essentially referencing this thing uh right i can try to"
4802760,4813160," do aiter free and free in the index right i'm free in the index uh so after that uh i can do stack"
4813160,4816920," one pop and i can pop it three times and"
4816920,4828280," what i want to see at the end of the day is how many nodes we have located allocated uh these frames and i can do"
4828280,4837800," aiter frames oh this one is actually kind of difficult to tell because we're reusing the frames"
4837800,4847400," so the length of the frames is going to be uh equal to three no matter what right right allocated these"
4847400,4853320," frames um okay let me let me see what's going on so here's the pop uh so we've got some sort of a"
4853320,4865960," donation uh just a second i need for for my stream labs too uh thank you anonymous for 50"
4865960,4870600," dollars donations are you mr beast you're donating so much money thank you so much thank you for the"
4870600,4875160," streaming i always learn something you're welcome you're welcome thank you for for the support i really"
4875160,4887160," appreciate the support thank you mr beast cheers um all right so uh thank you thank you so much really"
4887160,4894760," really appreciate it you didn't have to i didn't think i deserve this much to be fair right uh i'm just"
4894760,4901480," like shitposting on the internet come on um not as much as the previous guy but thanks for the content"
4901480,4907560," from ms uh thank you so much bender shell for 14 months of 21 subscription thank you thank you thank you"
4907560,4909000," really appreciate it"
4909000,4917960," if let is basically a match statement with just one pattern match yeah and this this is something that kind of"
4917960,4927000," annoys me to be fair uh because it makes it difficult difficult syntactically to evolve into a match"
4927000,4934840," statement you see quite often um you start with if let because you want to handle only one case but then"
4934840,4940520," you want to start handing more cases and that means you have to rewrite the entire structure to just"
4940520,4949240," migrate to match it would be kind of cool if this if let construction was was designed so it's super easy"
4949240,4953880," to turn it into match because that's quite often what you want to do you know what i'm talking about"
4953880,4959720," there's just like something really like there's some friction between if let and match that always annoyed"
4959720,4974120," me for some reason um sorry for being rude in apr before i tried to refactor your code once again"
4974120,4978920," using generators but eventually i got into heterogeneous data structures which i could not"
4978920,4985080," implement using rust type system don't worry about being rude in pull requests at all this is totally"
4985080,4989640," fine i do not read pull requests so i didn't even see that i have no idea what you're talking about"
4989640,4997720," about so don't even worry about that so um yeah don't worry about it that's totally fine um so let's"
4997720,5009640," continue um um so i want to do a pop i just want to see yeah i want to see that we allocated like"
5009640,5017640," three frames uh right so this is what i was talking about uh let me let me see um pop so we have to provide"
5017640,5027160," eight a time i think i can use a little bit of emacs magic right uh okay so here's the eight or three"
5027160,5034920," uh consider changing this mutable reference okay oh yeah you see pop before never deallocated anything"
5034920,5041960," so it never modified the state of the allocator so now uh it frees things and now it needs to modify the"
5041960,5048040," state of the allocator so let's go ahead and do that uh okay so we've got this thing"
5048040,5059400," uh and this thing has to be immutable now man i love busy work the rust actually forces i really love that"
5059400,5066440," uh looking like you know you're programming the rust and it forces you to constantly change like mutable"
5066440,5072440," weapons to immutable ones like change that and that and that and it feels so productive it feels like"
5072440,5077640," you're doing a lot of things you know what i'm talking about uh okay cannot borrow as mutable because"
5077640,5078840," it's also borrowed"
5078840,5090600," oh i see what you're talking about i do in fact see what you're talking about the person of fun"
5090600,5095640," subscribe with twitch prime thank you so much uh the person of fun uh for subscribing which one"
5095640,5105240," welcome to epic roster so essentially the only reason we need this frame is because we want to get it like"
5105240,5112040," the previous value so what we can do here is we can grab this thing and just literally inline it like so"
5112040,5120040," and put it here that way we briefly uh basically borrowing the ether and then we release it so we"
5120040,5126920," can borrow it again hey way way thank you einstein for uh four months of twitch prime solution thank you"
5126920,5131560," thank you thank you and welcome to epic roast clock so that way the borrower checker is not going to"
5131560,5137960," complain we have so many subs today polish yeah thank you thank you j rizal for twitch prime subscription"
5137960,5141640," thank you thank you thank you welcome to our epic right one uh"
5141640,5150840," rust compiler is so helpful to be honest such pretty error message speaking of a pretty error messages like"
5150840,5158440," vim compilation mode or whatever the it's called you know the thing that handles the make command it has a"
5158440,5163880," hard time parsing this thing without custom regular expressions vimers do you know what i'm talking"
5163880,5169960," about i think majority of the vimers just use the like a specialized plugin or extension for us which"
5169960,5176120," kind of handles that but by default vim has a hard time actually processing this thing it's kind of funny"
5176120,5183080," uh i can actually show you because i was planning to use vim uh for today's stream and then i encountered that"
5183080,5190440," problem and then i thought like i don't want to deal with that so uh let me let me see so persistent data"
5190440,5198120," stack right so if you go to here and if you try to first you have to say to make prg program right so"
5198120,5206440," let's set it to rustc main.rs right and if you do make uh right so here's the interesting thing it calls the"
5206440,5213800," compiler and then it will parse the first error right it will parse the first error and then it will jump"
5213800,5221080," to that error but here's an interesting thing it will parse this as a file name to which it has to jump"
5221080,5228040," right so and if you press enter your entire screen is going to be empty and you're going to be wondering"
5228040,5235800," why until you try to save your file and it will say it say it saved it to dash dash greater space main dot rs"
5235800,5242440," right so then you can quit vim and you will find that you have this file"
5242440,5254040," which you can't even like delete properly right because it looks like it's a flag"
5254040,5257960," to rm so to delete it you have to put like dot slash"
5257960,5268440," well i googled a little bit like around the internet so the usual solutions are to mess with"
5268440,5276440," error format right in vim there's a thing called uh error um i think it's error fmt um help"
5276440,5282680," error format yeah it's error format so basically it's a list of regular expressions that are responsible"
5282680,5290920," for parsing this thing and the other solution is to use specialized extensions for rust which parse these"
5290920,5297400," kind of things themselves and they don't have that problem uh so since every beamer uses these"
5297400,5302600," specialized extensions i'm the only one who's encountered that problem so i just thought that"
5302600,5309080," i don't want to deal with that so yeah there we go just wanted to share that information with you"
5310680,5314840," uh emacs has no problems parsing all of that so it's just like it's just that that"
5314840,5324360," it's kind of funny uh choose by the way can your emacs do that by the way can you do that i don't think so"
5324360,5336840," you know about error format i think it's like an archaic thing that nobody uses um almost like the make"
5336840,5345960," command the kate has the same problem with those errors well the problem with the error format is that"
5345960,5352760," it's very annoying to modify uh so if you want to fix that problem you have to go through a lot of pain"
5352760,5360040," to put regular expressions in an error format in a particular order so it's kind of like something that"
5360040,5369160," that you don't want to mess with uh anyways so uh i think we should fix the problem now there we go so"
5369160,5374600," the problem has been fixed and now as you pop uh things around uh it will de-allocate this thing but"
5374600,5382280," it still says that it has allocated three frames you see it still says that it has allocated three frames and"
5382280,5391720," this is because uh the de-allocated frames are located in the free list right so and if we do something like"
5391720,5400440," um println right if you do something like println uh freed uh this amount of frames so it's going to be"
5400440,5411720," either free len so it will say how many frames it's allocated and then free three frames so yeah uh and"
5411720,5421640," if you try to allocate um some stuff afterwards right if you try to maybe push integer one time uh you're"
5421640,5427400," gonna have still allocated three frames but freed two uh two frames because one is already taken"
5428120,5435320," right so that's actually pretty pretty interesting uh so we have a thing that can free the frames now"
5435320,5441480," the next thing is to free the frames automatically right so one of the solutions that we wanted to"
5441480,5447720," explore is the reference counting right we wanted to explore the reference counting and um"
5447720,5455800," where are we going to do a reference counting the the most logical thing to do uh the reference counting in"
5455800,5462520," is in the frame itself uh right so let's actually put uh like some sort of a field in here ref count uh"
5462520,5469880," which is going to be your size uh is that a good idea to do it like that i think so i think so"
5478120,5482680," and who's going to be responsible for the ref count"
5482680,5490120," i think the allocator should not be responsible for the ref count i think i think it should not be"
5490120,5497080," responsible for that uh it should be responsible the stack itself should be responsible for that right"
5497080,5505240," as you pop an element uh right you decrement the ref count for for the new top um and then as you know the"
5505240,5511720," the the ref count reaches zero right uh you essentially"
5511720,5518440," you essentially delete this entire thing all right so that's pretty cool"
5518440,5531400," uh so that also means that we cannot uh we cannot clone this stack like this anymore you can't clone it"
5531400,5539080," anymore like that so essentially what we have to do is to implement our own colon method that also increments"
5539080,5544840," the ref count for the current thing in here yes that's what we need to do so i'm going to remove the clone"
5544840,5551080," from here right so i'm removing the clone and i'm going to implement my own clone in here"
5552440,5559720," there we go so and this thing is going to take oh this one is interesting by the way i do need my own"
5559720,5567800," clone by the way right because i will be de-referencing the um the pointer and to de-reference the"
5567800,5574120," pointer i need allocator so this is going to be like a special clone that on top of taking um i think it"
5574120,5581400," will take immutable self it will also take immutable allocator frame eta like this and it will return"
5581400,5588120," i suppose self self right it will return self um cool"
5588120,5596680," all righty so here's the frame so here's the data type the previous one is going to be that and uh what's"
5596680,5603480," interesting is when you create a new frame right so we're pushing a new frame onto the stack uh ref"
5603480,5609960," count is going to be one because the only thing that is uh pointing at that frame is the type stack itself"
5609960,5617880," right so it's going to be just one uh when we're popping the uh the thing right when we pop in the thing"
5617880,5623000," i need to de-reference this entire thing take the previous but on top of that i also have to"
5624200,5629960," decrement the ref counter decrement the ref counter"
5629960,5637960," so let me see how we can we're gonna do that um"
5637960,5647400," so here's the frame uh i think it has to be mutable i think i need a mutable frame so this thing is going"
5647400,5656680," going to be basically mutable uh then within that thing i'll have to take the ref count"
5656680,5663160," and decrement it right i'm decrementing this thing uh and then um"
5663160,5673160," this one is going to be rather interesting actually uh so i assign frame to the previous one"
5673720,5685560," and the only time i need to free it is when frame ref count uh becomes zero right it reaches the zero"
5685560,5690760," and then i want to free it but that creates a lot of like weird stuff"
5690760,5700840," uh because we borrow ater in here and we keep it borrowed up until in here so we cannot borrow it for"
5700840,5708600," mutable again so that means we have to do all of this stuff like in a very confined um scope"
5708600,5713960," right we have to do that in a very confined scope and the question is how can we even do all of that"
5713960,5722520," so we can actually wrap this entire stuff in its own scope so the aether is gonna stay the aether is gonna"
5722520,5732920," stay uh borrowed only within that scope right and um here we're going to move this condition"
5732920,5739080," at the end of that scope right we're moving it at the end of that scope and we're gonna assign it to"
5739080,5746440," some sort of a variable um something like delete right uh and then if delete"
5748040,5756520," you go and free it so you see uh we only keep aether borrowed here and then we unborrow it"
5756520,5760840," and then if we need to delete it you borrow it back so basically we're moving that condition from here to"
5760840,5768200," here so and borrow checker forces us to do that so the only reason we do it like that is because borrow"
5768200,5774840," checker wants us to do uh things like that uh it would be kind of cool if i could have a block"
5774840,5782040," as a condition like that if you know what i'm talking about rust developers do you know what i'm"
5782040,5789240," talking about right so i could just have a block that is like an expression is that even possible can"
5789240,5796280," i just take this can you do i have no idea can i so that's my question uh that would be actually kind"
5796280,5801240," of cool so basically i say borrow it for the duration of calculating the condition"
5801240,5805640," and then and borrow it and then borrow it back to do the separation"
5805640,5811720," so okay first first of all i want to check if this entire thing compiles right uh because maybe"
5811720,5818600," maybe i did a fucky wacky and oopsie doopsie okay i didn't uh so now let's give it a try uh"
5818600,5820520," all right so i'm gonna put it like that"
5820520,5835000," this is the wackiest code i've ever written and it works what the"
5835000,5845960," this shit will confuse anyone so essentially you can have sequence of like statements"
5845960,5855720," that lead to a condition this is so cool you can do that you can do that uh so and the reason why i"
5855720,5863320," even thought about that is because you can do this kind of stuff uh in in port right in port there is"
5863320,5869400," like a whole paradigm that i discovered right i discovered the whole paradigm in port uh where"
5869400,5877160," like you have a while do right and you have a condition in here uh condition uh but since port is"
5877160,5885800," like it doesn't have any blocks in here you can actually use the space between while and do as the"
5885800,5893240," body of the condition right so and in fact it's it's used quite often in uh in parsing to break"
5893240,5899640," out earlier and this is basically what gave me the idea of using like a block of code as the"
5899640,5905480," condition for if so and i'm surprised it works so maybe gonna do it like that that's actually pretty"
5905480,5910360," interesting it's really wacky do people live in the right rust like that"
5910360,5923240," yeah"
5923240,5929560," yeah so this thing does in fact feel so ill like somebody's gonna look at that code and then they're"
5929560,5935000," gonna go like what the like what what the does it even mean mean like holy"
5935000,5940200," yeah yeah lots of people do okay that's actually pretty cool uh because it's kind of convenient to"
5940200,5947880," define right it is it is kind of convenient uh okay so we take uh we borrow this ater we the"
5947880,5953320," reference we remove its reference right then we set it to the previous and if a reference actually"
5953320,5960760," reach the zero then we do free it uh then we do free it it's kind of important because you cannot just"
5960760,5965480," move this thing in here because you have to unborrow it first and then borrow it back"
5965480,5973880," that's what you have to do okay so on pushing we do reference count one here we decrement the reference"
5973880,5979320," when we dump we don't have to do anything on clone this one is rather interesting right on clone"
5979960,5990840," what we have to do is we have to take eta uh first of all uh if let some index self top"
5990840,6000680," and i do ater uh the ref as mutable right so this is going to be index and then i'm going to take a"
6000680,6009560," mutable frame there we go so and when you clone it you have to do ref count plus one right so there is"
6009560,6018360," another account another reference uh pointing at that specific thing okay that's pretty cool that"
6018360,6029480," makes a lot of sense actually it makes a lot of sense uh and then um i have to return self which uses"
6029480,6038440," well it's just clothes and clones itself i suppose um self top top self top"
6039160,6046760," i guess that's right so we just check if top has anything and we de-reference that top and we"
6046760,6052040," increment its ref counter and we just like clone them ourselves um"
6052040,6064360," it might be awkward if you ever need to debug that if but i find it easier to read that uh shunting that to"
6064360,6071640," function as people usually do do people even step debug rust because like i tried to step debug rust"
6071640,6078840," and the tooling for that was actually very horrible so i'm not sure about that um so root black 45 thank"
6078840,6083160," you so much for everyone's application thank you thank you thank you and welcome to our epic rust club"
6083160,6088120," so i think here i need to unwrap this into i think and everything's just working i think we implemented like"
6088120,6094120," a reference counting what the f**k did we did we implement a reference counting i think we did"
6099960,6111640," um so how can we test all of that how can we test so we can actually log something uh when every time we free"
6112360,6129880," um so um can the reference counter count itself i don't understand the question"
6129880,6139160," it is possible but i think you need ldb for some reason i don't think i said it's impossible i said that"
6139160,6145000," it's very annoying uh and i said that i tried that and it was in fact very annoying"
6145000,6151080," um so in like quite often if you want to debug something with that with rust it's just like easier"
6151080,6161800," to do print up debugging um"
6161800,6167960," it's kind of interesting that modern environment kind of encourages you to do printf debugging"
6167960,6174520," because step debugging can be pretty powerful it can be pretty powerful and can help you to find very nasty"
6174520,6182360," bugs um you can blame nasty bugs for for like weak type system or something like that but then"
6182360,6186120," that at the end of the day step debugging actually very useful when you get used to it"
6194040,6204200," so uh we probably want to okay i want to dump the the current state and just see how useful that is"
6204200,6212040," but on top of that i want to be able to to see what frames are freed you see like the current dump is not"
6212040,6219000," going to work right because uh some of the frames that you're referring to they could be freed so they're"
6219000,6227320," not available anymore um but what's funny is that maybe it doesn't even matter you know"
6227320,6231240," maybe it doesn't even matter because we can just"
6231240,6235560," mark those nodes in a very special way"
6237720,6249480," right the question is how can we mark them um so i can basically set up the connection between nodes in"
6249480,6255800," here uh i set up the conversion uh connections in here and then after that um"
6255800,6265080," i can do the rest of the stuff it would be easier if the free nodes were set right it would be super"
6265080,6271400," easy if they were set in the final implementation they don't have to be set uh we just need to be"
6271400,6276760," well maybe it doesn't really matter right so we're not trying to be fast or anything does vector even"
6276760,6283720," support something like find can you find uh right contains yeah it does have contains okay so i can just"
6283720,6292360," search for a specific element uh right so and essentially i can do uh so frame we found the frame and we"
6292360,6301800," can do something like if uh self free contains index and it does not contain uh we basically not gonna"
6301800,6309640," even render this entire thing so it is slow it is linear search but this is a debug output right so"
6309640,6314440," this is not going to be like a final production solution and in the final production solution we"
6314440,6318840," don't even need to do the separation so this operation is only needed for the back purposes so"
6318840,6329880," yeah that's totally fine i think that is totally fine uh so let me let me see so uh"
6329880,6341240," can we have on top of the label i also want to have something like a counter right so i can do something like"
6341240,6349080," like this so this is going to be uh the string and i think you have to use double quotes right so this"
6349080,6356520," is going to be double quotes and here we can use the counter so i can do frame uh a ref count right"
6356520,6364840," okay now you can do that so it didn't really work uh uh-huh so here is the index um so it has to be a"
6364840,6371800," ref reference for whatever reason uh so we don't have a file so let's actually make it file"
6371800,6382680," i like the simplicity of reference counting actually uh is never used can i just allow uh that code"
6382680,6391400," because it could be dead sometimes just like myself haha self-deprecation uh is never used clone"
6392440,6398600," uh i think we're gonna use that so dump what is dump dump is not probably needed"
6398600,6409720," whatever okay so uh let me let me see so we have stack one right then i want to do stack two uh and"
6409720,6416120," i'm gonna do it like this i'm gonna clone using the allocator right so you can only clone it by using that"
6416120,6424760," allocator then we do stack one pop uh mutable eta and then stack uh one uh push"
6424760,6436280," uh push uh mutable eight data type pointer data type pointer data type pointer okay so this information"
6436280,6444440," is useless uh anything else we need to have in here let's try to call this entire thing and we have svg"
6444440,6450280," generated and let's take a look at this entire thing okay cool so this doesn't work uh so"
6450280,6458040," uh you suppose i think you're supposed to have two in here right i think you're supposed to have two uh"
6458040,6466920," but something went wrong during the cloning process and i wonder what exactly so let's find out uh let's find out"
6468360,6479480," uh two to two to two to two um i wonder what so if i just uh don't do any of this stuff will it work"
6479480,6491080," correctly uh i think it does right i think it does work correctly uh huh yeah okay this one is very interesting"
6492760,6499640," uh this one is very interesting so basically you have two pointers that point in here right so at this top"
6499640,6513480," you pop one out and this is the new top right this is the new top uh and as you push all right as you push"
6516040,6524440," hmm how is that how is that how is the difference so so there's a bug in push there's a bug in push"
6524440,6534440," so it's almost like i have to take the top and increment it by"
6536680,6553800," by zero by it's it's it's really unclear how we're supposed to even do that like yeah"
6553800,6556280," hmm"
6560200,6566760," it's really unclear it's really unclear so the easiest way to work out uh this kind of stuff"
6566760,6572040," would be mark a sweep but maybe okay so let's actually try to replicate the situation so we have"
6572040,6584280," this one uh right then uh this one and this this one right um actually uh at the beginning right you have"
6584280,6595560," one pointer so here is one uh then you push and you think uh right and you think you point here for a"
6595560,6605000," brief moment you have two of them right but then you go back to just one right uh and because of that"
6605000,6610200," it doesn't really make any sense to increment it twice or anything then you're creating another one"
6610200,6614680," so a brief moment is going to be one but then you're going to move it out so at the end you're"
6614680,6621160," going to have this thing so you clone the stack right you clone the stack you have two in here right"
6621160,6630520," so by popping from the stack you essentially decrement this thing uh you decrement this thing go back"
6632600,6642600," but that effectively means that now there is two pointing in here so pop while decrementing one thing"
6642600,6653400," should increment another one right should increment another one uh which does not make much sense to me"
6653400,6661880," uh oh i see so and we have a situation with a single stack right you have a situation with a single stack"
6661880,6670040," which looks like this right so there's a one uh one and here is the pointer so by popping the element"
6670040,6678760," you kind of move down here right you move down here and that makes it two but then you sort of dereference"
6678760,6685720," this thing which brings it back to one right so you have to kind of like it's kind of finicky"
6686360,6696200," to keep track of all of this kind of stuff right uh and the question is is it even worth it but if we"
6696200,6703400," come up with like a proper rules to do all of that maybe it feels like the this kind of stuff should be"
6703400,6709720," probably handled on a different level yeah it feels like it should be handled on a different level"
6712520,6718120," maybe not um so essentially the allocator itself"
6718120,6730040," the allocator itself when you free the node when you free the node it should look at the nodes it"
6730040,6738120," point to and decrement them as well i think that's what has to happen right so that's essentially what's"
6738120,6744920," going on right because that's essentially the operation that we're trying to do in here"
6747240,6755720," or also"
6755720,6763320," when you add a new node right when you add a new node"
6763320,6767720," and that nodes point to something"
6770120,6776840," we'll have to increment it as well it it feels like it has to be interplay between the uh the type"
6776840,6782120," stack and the allocator all the time right it's basically the interplay between them"
6782120,6790440," and i'm not sure it's kind of it's kind of painful to be fair it is kind of painful uh and i ran out of team"
6791960,6798280," so mark and sweep would be actually super easy to be fair with the marking sweep you just have to keep"
6798280,6805720," track of the like list of all of the stacks and then you will just iterate through all of them marking"
6805720,6811560," which ones are already visited and then you remove everything else so that would be actually way easier"
6811560,6818760," you you you you won't even have to think uh about uh like when to decrement or increment or whether you"
6818760,6826280," forgot to do that or not or something like that so um yeah maybe we should try to implement mark and sweep"
6826280,6832680," what do you guys think uh we can try to do that because i think i feel like it's easier for some reason"
6833320,6841800," right then messing with like ref counters and whatnot so uh okay for the um so instead of ref counter right"
6841800,6851160," let's actually go ahead and remove the ref counter uh so that way uh to to to so we don't have a ref"
6851160,6861800," counter so we don't have to print it in here uh okay so we don't need to do that stuff in here uh we don't"
6861800,6869560," need to have that stuff and we have to decrement anything oh and yeah by the way so if we're gonna"
6869560,6876440," do mark and sweep when we pop something we don't even have to care about this kind of stuff we can"
6876440,6887320," just go ahead and like derive it so uh yeah we can bring back uh so we can do that this is gonna be top"
6888200,6896200," then um yeah we don't even have to do any of this stuff don't we so you pop you just you just do that"
6896200,6900440," okay so just let it leak uh just let it leak"
6902920,6915240," let it leak let it leak let it leak let it leak memory costs nothing let it leak"
6915240,6923080," uh okay so when i clone something we yeah so that essentially means we can just use the"
6924280,6937640," uh the default clone uh okay and here that's where we clone all of that okay so let me see let me see"
6937640,6948600," frame previous data type and stuff like that uh let's have something like visited false of visited"
6948600,6951640," boolean i mean right so visited boolean"
6951640,6958120," visited boolean"
6958120,6969400," is it going to be on the frame or is it going to be like a different data structure that's also a good"
6969400,6969800," question"
6969800,6980120," it is also a good question and what's interesting is that now if we're gonna do it that way i need an"
6980120,6987640," operation that like checks whether the frame is already freed or not so that's kind of a problem in"
6987640,6994280," here right we want to be able to do that but maybe we can have additional flag that indicates whether"
6994280,7001560," something is freed or not right so that way we can easily skip the freed frame if you know what i'm"
7001560,7007080," talking about that's actually interesting idea like free right by default is going to be false"
7007080,7015800," right uh and that way you can quite easily check all of that you know what i think i want"
7015800,7020280," to make a small break because my brain is kind of like shutting down so and i'm already streaming"
7020280,7024360," for two hours right i'm already streaming for two hours so definitely want to make a small break so"
7024360,7033720," all right so mark and sweep is actually like solve some problems but it introduces another problems is"
7033720,7040360," that now i'll have to have a fast operation to check whether the frame is free or not and that will"
7040360,7045880," require me introduce like another field in here so maybe i want to still stick with the reference"
7045880,7051720," counting idea right so both of the ideas like have their trade-offs and stuff like that but if we can"
7051720,7057640," nail down the reference counting i think it's going to be you know relatively convenient to work with so"
7057640,7064280," maybe what i'm thinking is that for the reference counter we should get rid of the free operation"
7064920,7071640," right so maybe instead of free operation we have to introduce like something like acquire uh"
7071640,7080680," why is that how you spell that word did i spell it correctly uh acquire by okay so that's going to be"
7080680,7086600," acquire uh right self i'm not sure if i'm moving in the right direction by the way so i'm just experimenting"
7087160,7093240," uh right so this is going to be a size uh this is not implemented and then we're going to have something"
7093240,7101960," like release right so it can be mutable self index uh use size and this is going to be uh to do so you can"
7101960,7106920," acquire something and you can release something and we're not going to have like a ref or anything like"
7106920,7113960," that uh so an acquire will increment the reference counter and release is going to decrement the reference"
7113960,7120520," counter and if it reaches the uh like minus one or zero or like name why did you say minus one if it"
7120520,7127000," reaches zero we're gonna basically free it ourselves so when we allocate something i think it will"
7127000,7137640," automatically acquire that thing right so it will acquire it um and we'll have to basically quite carefully"
7137640,7142920," uh call these two functions right i think that's what needs to happen"
7143960,7151880," uh all right so and the question is where should we store the reference counts um we can store them"
7151880,7157560," somewhere here maybe right so maybe the frame itself should store them um so it doesn't really matter"
7157560,7162200," right so because this is a prototype code we can just store it somewhere here but it makes it rather"
7162200,7167720," inconvenient um makes it rather inconvenient"
7167720,7181240," uh two two two two"
7181240,7190520," uh it's going to be a rough count because the reason why it's going to be inconvenient by the way is because"
7190520,7196840," uh you have to uh you have to provide it in here in the in in the initialization right you have to"
7196840,7204840," provide it in here initialization but uh if we do it like this somewhere in the tuple uh right it's going"
7204840,7210920," to be a little bit more convenient so um what is more convenient it's kind of difficult to tell"
7211560,7216520," right because the user should just stick with this thing"
7216520,7225640," uh to two so this one is definitely going to be convenient but i don't remember how to access"
7225640,7229800," specific fields of the tuple how do you work with tuples in rust"
7229800,7239560," uh so tuple let me see so here's the tuple and if i want to access like a very specific field it's a dot"
7239560,7243720," zero dot one or something like that okay so this is basically what i want you to see"
7243720,7253880," uh okay um so then i do frames uh result uh so let's actually let the compiler do the job like the"
7253880,7260120," so the compiler should just tell me what to do uh okay so this is going to be the zero and then"
7260120,7265160," here we're going to have frames might as well just do something like this uh"
7265160,7274440," one because we acquire this thing uh right away uh right and in here we push in it and also one"
7274440,7285400," uh huh so and when i get this entire thing i also want to get this uh right i'll have to map it by the way"
7285400,7291560," right so we'll have to do something like x zero uh and here also i'll have to do something like x"
7291560,7298120," uh zero hopefully that will be sufficient enough i'm not sure if it will be sufficient enough let's"
7298120,7309400," see uh expect it to uh expect it uh because the return spirit but got just frame which is rather interesting"
7309400,7316360," so that means i have to explicitly just do that stuff uh sure uh that is totally fine"
7316360,7325080," so and in a frame i got uh this thing so this is not a frame anymore it's more of like a"
7325080,7331640," uh frame and a ref count right but i don't really care about the ref count so i'm gonna just"
7331640,7338200," simply ignore that thing uh okay does it work it seems to be working okay cool um all right so let's"
7338200,7344920," actually implement acquire right so when you try to acquire something uh we do frames index and then i"
7344920,7351480," take one and i increment it by one there we go so i just incremented it then if we release something i'm"
7351480,7362520," going to do frames index uh one minus one and if it reaches zero right if uh self frames index one is"
7362520,7369080," less or equal than zero i don't think it can be less than zero so we're just going to do equal zero uh we"
7369080,7378120," are going to free this thing right we're going to free this thing uh so when we frame the thing this"
7378120,7390120," one is quite important so we also have to release uh whatever it's pointing at all right so this one is"
7390120,7404120," very interesting right we have to do self frame uh frames index um self frames index uh zero then we'll have"
7404120,7414840," to take the previous right the previous and if the previous has anything all right uh if let some brief"
7414840,7422840," index right if it does even exist we'll have to release it again right so we have to release brief"
7422840,7430280," index like so uh so it sort of forms the chain right so it will uh create a chain reaction so i guess"
7430280,7436760," the need for this sort of chain reaction created the complication i was dealing with right so you you need"
7436760,7444600," to like cascade this kind of like releases and stuff like that um right so and obviously the"
7444600,7449880," borrower check is probably not going to accept that right so i'm just like outlining the idea um"
7449880,7453240," right so let's see if it's going to work"
7453240,7461640," and it worked surprisingly like i'm surprised the borrower check is fine with that oh this is because"
7461640,7466520," i'm borrowing this thing and i'm releasing it right away right so that kind of makes sense i suppose"
7466520,7469160," can i just like have something like"
7471400,7478520," i don't even know well i guess it's fine it's kind of a weird code but it's fine i guess"
7478520,7487640," i guess it's fine so we have acquire and we have a release cool uh so if i try to run this code now"
7487640,7493560," uh it it kind of works by the way it kind of works okay in the stack when i push something onto the stack"
7493560,7500920," right it right it right away acquires that thing right i don't have to do anything it just like"
7500920,7513240," acquires that uh and then interestingly enough so it should also increment the top but since we're updating"
7513240,7520520," the top it should yeah so this entire thing sort of like we have release and acquire that cancels itself"
7520520,7528280," out uh so we don't have to do anything in here in case of a pop uh this one is really really interesting"
7531000,7535720," so i take the frame uh right i take the frame"
7535720,7544120," oh man okay so"
7544120,7552600," let me assign it back in here so here's the frame all right and"
7554840,7563000," essentially i will have to release the current top right so this is the index might as well call"
7563000,7569640," it something like top index right so this is the top index right i'm taking uh yeah so the first thing"
7569640,7574120," i probably want to do i just want to release this thing uh i'm completely releasing it"
7577400,7580920," but it's kind of dangerous to do so uh so probably not gonna do that"
7580920,7587560," i'm taking the frame uh"
7587560,7598360," oh man my brain doesn't want to work uh but the problem here is that uh i need to release"
7598360,7606600," the top index right i'm releasing the top index is that a dangerous thing to do i feel like it is"
7606600,7611800," kind of dangerous thing to do because it will set off the cascade effect right so it's going to be one"
7611800,7621000," uh one one right and you have this stop you're releasing it right away it sets it to zero which"
7621000,7624760," releases that thing which sets it to zero which releases that thing and so on and so forth so it"
7624760,7630920," basically cascades so we don't want to do that all right so that means we don't want to release it"
7630920,7636280," right away first thing we want to do uh we want to grab the frame"
7636600,7640920," right so the current top frame right so the current top frame and we want to reassign the top to"
7640920,7645960," there right so we have a previous thing um"
7648600,7655480," um i guess the first thing i guess the first thing we want to do we want to do ater uh acquire"
7655480,7666920," right acquire um frame previous if if it exists right that's what we want to do so that's actually"
7666920,7672200," pretty cool so this is a cool idea this will not set off the cascade effect right so we have something like this"
7672920,7681400," uh right uh you have top in here so instead of releasing the top you grab this thing and you"
7681400,7688920," acquire it making it two right then uh we're gonna move the top to here and we're gonna release the top"
7688920,7694680," which will set it to zero which will remove that thing and which will recommend one back here so that"
7694680,7699560," will not set up a cascade effect which will remove the entire thing right so you have to"
7699560,7704040," do that in a particular order and this is why i was kind of scared of reference counting because"
7704040,7708840," you see you have to do that in a very particular order and you can set off something that you don't"
7708840,7715000," want to set off uh so but if you do that in the correct order maybe it's going to be even easier than"
7715000,7725000," implementing mark and sweep you see what i'm talking about um so yeah and again doing that in rust adds a"
7725000,7730120," complication of borrow checker right because now you have to also satisfy the borrow checker i'm not sure"
7730120,7735960," like if i will be able to do that so i need to take the frame right here i'm actually um"
7739160,7748840," yeah this one is interesting because here i'm borrowing aether but to acquire the previous frame"
7748840,7755080," i need to borrow it again right so that means i have to borrow this entire thing uh for a brief moment"
7755080,7763480," and take the previous value but this thing may not have previous value right this thing may not have it so"
7765800,7776920," let's actually set something like um if let some previous index right so this is something that we"
7776920,7784120," want to have right so we take the top index uh we unwrap it obvious obviously and then we take a previous"
7784120,7794840," if it does exist we have to acquire it so we have to do aether acquire uh previous index so we acquired that"
7794840,7807320," thing uh right so after that i need to do aether release aether release the top index so i'm releasing"
7807320,7812760," the top index and then i'm setting the top"
7812760,7821800," to the previous one this one is interesting so i have to like do the separation yet again"
7822680,7829160," um right which means that it would be better to actually save previous to here"
7829160,7833400," like so"
7833400,7848680," and then just set it like that i think i did this in the correct order that's right so here no release acquire"
7848680,7855400," is required because you do release acquire that cancel each other out so as you can just do that uh here"
7855400,7862200," you take the previous previous exists you acquire that previous to not set off a cascade effect and then"
7862200,7870360," you release the top and you assign the top to to that so all right i think i did it i think i actually did it"
7871000,7878680," all right so uh let me see so we we need to put a semicolon here uh is it compiling it seems to"
7878680,7886200," be compiling actually all right so i essentially just push some stuff onto the stack let's take a look"
7886200,7892680," at the svg output all right so here is that but we don't have a reference counter right right because"
7892680,7898200," remove their reference counting so let's go back to the reference counting uh this one is going to be"
7898200,7907400," something like this and the reference counting uh a ref count uh ref there we go uh so let me see"
7907400,7914840," there we go so here are the reference counting right so it is in fact correct we cannot see like the tops and"
7914840,7925240," stuff like that but that's fine we can just imagine them uh okay so i also i also clone this stack and"
7925240,7932280," again since i brought back the cloning i need to have my own clone operation right i need to have my own"
7932280,7940760," clone operation uh and let me quickly do that so this is going to be mutable self ater uh mutable frame ater"
7942200,7951640," frame ater and what we're going to do in here uh solve a self top if let some top index"
7951640,7960600," equal to that right um that means what i have to do in here i just need to acquire that top index"
7960600,7969320," right and then i can just return self self self top and that is basically it"
7970840,7979320," right so yeah you just need to do another acquire in here okay cool but only if it exists right"
7979320,7991560," so anything else so this requires a mutable ater uh all right cool so you see we cloned the stack"
7991560,8000520," and now we have two things in here that is cool so now if i pop something from the first stack right"
8000520,8008200," that means uh now we're gonna have uh single pointer in here but two uh reference counts in here because"
8008200,8014760," yeah you're gonna have first uh reference count from this node and the second one from the second stack"
8014760,8021800," right that makes sense i think i think that makes sense okay so if i uh do that there we go so two moved"
8021800,8029000," down and now if i push something to the first original stack uh we have correct reference cards okay let's go"
8030600,8036200," so we have correct so we have correct reference counting how about that how about that so we just have to do"
8036200,8044200," that in the correct order so that's pretty pog"
8051480,8057800," uh so we can push more stuff into here right into the first stack"
8057800,8072360," into the first stack uh so then can we just go ahead and delete that stack so the easiest way to delete"
8072360,8082440," that stack would be to just take stack top uh unwrap it and in the ater uh just to release that top"
8082440,8090120," right that kind of makes stack one incorrect right but since we're using indices instead of references the"
8090120,8095240," borrower checker is not going to tell us but yeah so essentially what this will do it should remove this"
8095240,8101720," entire branch automatically right it should just like remove it and i just want to see if it's going to"
8101720,8111880," happen uh okay so i uh forgot to do this thing all right and it kind of worked but this thing still exists"
8112440,8120440," right uh okay so this thing still exists and this is because when it reached the zero did we actually"
8120440,8124840," free it uh okay we didn't all right uh"
8124840,8140440," uh so what we forgot to do is to uh add this thing to the list of freed indices right so once the"
8140440,8148040," reference count reached zero we have to add it to this thing uh and then uh set of cascade effect but"
8148040,8151400," maybe it makes sense to actually do that in here does it really matter i don't think so"
8152600,8159400," so uh there we go and as you can see this i think was removed right so we removed one thing and removed"
8159400,8169560," everything so that's pretty cool hmm so we have a proper memory management uh based on reference"
8169560,8175640," counters and stuff like that isn't that cool i think that's pretty cool so it will be interesting to"
8175640,8184840," actually have like a more you know like better example um so maybe you do something like a tree of some sort"
8184840,8193560," mm-hmm um i wonder if i can we can do that recursively somehow"
8193560,8202520," can we do that recursively just generate like random data types and whatnot"
8203240,8207720," uh will be also nice to have like a function that can generate a random data type sort of and"
8207720,8215320," random uh type right and this thing will just return data type oh random number generators in rust are"
8215320,8222920," like really annoying so the standard library doesn't even have a random number generator right i think"
8222920,8228760," i think it doesn't have a random number generator like it's it's a crate it's a separate crate that you have"
8228760,8232040," to install okay"
8232040,8242120," you think this is gonna stop me uh i'm gonna just copy paste to the lcg"
8242120,8247240," uh all right so how do you do that i keep forgetting"
8247240,8255560," so essentially we have a and c uh right and we can have like some sort of a global seed uh might as well"
8255560,8270680," actually have like a struct run uh like uh so we have a and c uh u64 b uh c u64 right we can implement um rand"
8270680,8280520," method to rand which will accept a mutable self and will return a new thing so it would be also nice"
8281480,8291880," uh to uh to uh to have some sort of uh like a and c usually are constants right so uh i'm not sure if i"
8291880,8296600," want to make them constant okay let's actually make them constant so it's going to rand a uh i don't know"
8296600,8302120," which one to put in here so i'm going to put this one b is going to be another one so there's a couple of"
8302120,8309800," like good uh numbers in the in wikipedia so maybe we're going to use them so this is a seat to use 64"
8309800,8316120," and uh yeah so that way we don't have to initialize anything uh all right so and the"
8316120,8327720," result is going to be the following right so we take a rand a uh multiply by self uh seed right so this is the"
8327720,8335160," the current seed plus the current seed plus rand c and we just do mod on m and m"
8335160,8348280," so i don't remember uh let me see uh and mod is usually so okay so the the one that i use in port"
8348280,8354600," mod is 64 that means you don't need mod at all so we can just do something like this right so and"
8354600,8361240," we're going to do self uh seed equal to that and we're going to just return self seed right there we"
8361240,8368760," go so we might as well even like one thing that i learned from using this uh lcg thingy and one thing"
8368760,8374520," that people in comment section on my uh youtube channel pointed out is that you don't want to use the"
8374520,8383880," low uh 32 bits because they're like not really random uh so you want to use the uh higher 32 bits"
8383880,8389080," so the the video i'm talking about is this one actually right so um i really recommend to check"
8389080,8394040," it out this is where i was using that specific lcg so i'm going to put it in the chat for anyone who's"
8394040,8399080," interested and also in the description uh right so this is basically i made the whole language just to"
8399080,8413160," generate this thumbnail uh okay anyway so um let me see uh and maybe because of that we want to return 32"
8413160,8420440," and essentially we're going to return something like uh like move it by yeah 32 right so we're just"
8420440,8427000," basically removing 32 bits um and that way we can like have a random number generator we can even"
8427000,8433080," like check the quality of this random number generator um so you see you don't even need the"
8434280,8441720," uh right the the package or anything like that so i think the main uh justification for not having"
8441720,8447320," random number generators in the standard library is that to prevent people accidentally using it in"
8447320,8454440," like cryptographic cases right so because usually these random number generators are not cryptographic"
8454440,8458280," but we're not doing any cryptography right now so it doesn't really matter i think"
8460200,8466760," uh so yeah we just need to like generate some random stuff random stuff"
8466760,8479560," uh so let's actually check how this entire thing works right so let's do for e in uh 10 right i'm going"
8479560,8490120," to print lm uh so we have to put something in here so let's do it like this 69 can i just do it uh there we go"
8491720,8497320," it's gonna be mutable rand uh-huh rand rand cool"
8497320,8505880," uh to the two so this one is c okay so let's set it like this"
8505880,8514440," anything else uh so this thing wants a type i think right it wants a type"
8515240,8525320," uh right and think after that i have to explicitly cast it to you 32 right is it fine it should be fine"
8525320,8532680," now uh okay so what is it complaining about i'm not quite sure so there's a bunch of warnings and"
8532680,8540920," multiplication attempt to multiply with overflow but isn't that what i want uh isn't that what i literally"
8540920,8556600," want can i just say yeah please overflow um so can i just like literally overflow uh overflow abs oh oh"
8556600,8561960," you can actually explicitly do that that's actually pretty cool uh overflow multiply"
8565400,8578360," uh overflowing okay cool that's actually pretty cool uh all right overflowing multiply what a nice"
8578360,8589880," language uh can i have overflowing add as well so before why do like at this point why do you even need"
8589880,8598200," an infix notation rust if that's what you want your user to type out maybe get rid of the infix notation"
8598200,8604280," and just like do all of the operations like this that way you don't even need the traits for like add"
8604280,8610680," multiply and stuff like that because you won't have any infix operators right you can simplify your"
8610680,8615880," uh your type system you can simplify your standard library you can simplify your parser right if that's"
8615880,8627080," what you want you want users to do just like get rid of the infix notation and come on uh okay so oh it even"
8627080,8640840," okay on top of that it can also returns boolean or something serious um okay so uh all right so can be"
8642920,8651880," uh uh uh requires call expression requires okay so that's that's what you want okay cool i i generated a"
8651880,8659560," bunch of random numbers look at that i have a bunch of friendly numbers uh okay that's cool"
8666200,8673080," so wrapping mode so wrapping mode do i really want wrapping one maybe i do wrapping one you're right i"
8673080,8678280," think that's the one i want um do they return boolean"
8678280,8682760," uh thank god i don't return boolean holy shit okay"
8682760,8694120," and and i have to pretend this is normal right so if i if i want to be like a good member of the rust"
8694120,8699800," community i have to like smile and pretend that this is absolutely normal this is helping everyone this"
8699800,8706040," is good right do you understand i think i understand that correctly okay right so okay"
8706040,8708120," um"
8708120,8710760," so cool"
8710760,8718200," and so what do we got uh yeah all right"
8720200,8725640," um so what i want you to have is essentially just this thing"
8725640,8735240," uh rand uh so we're gonna accept rand uh random type all right"
8735240,8742360," uh two two two two we're gonna take a mutable rand and we're gonna return the data type and essentially"
8742920,8749560," i'm gonna do rand rand uh three and can i just cast this entire thing to like"
8749560,8753800," uh to the data type as data type is that a thing i can do"
8753800,8764680," uh hopefully uh as expression convert into primitive types um so rust in um number two in them how do you do that"
8767400,8775000," um you can disable overflow checks in cargo dot toml but i don't use cargo how am i supposed to do that"
8775000,8781560," uh how am i supposed to do that if i don't use cargo"
8783320,8797320," that's a very good question so there is some traits and some other stuff"
8807160,8814520," i know what i really don't care to the fan uh i just want to get this done right so"
8814520,8828680," how more annoying do you want to make generating a bunch of random data for testing make how more"
8828680,8835880," annoying do you have to make it this is a very interesting question you just have to make it annoying"
8835880,8843240," you just have to uh right so you cannot just like generate quickly no no what if somebody is using"
8843240,8848920," that in a cryptographical context you will get a vulnerability no no you you you can't you can't"
8848920,8856440," uh okay so can i just do something like this uh all right think about the children think about the"
8856440,8862680," children what if the children will see your codes right what if the children will see your random number"
8862680,8867560," generator and think that this is a cryptographic quality and we'll try to use that in their in"
8867560,8870120," their like security application or something like that"
8870120,8883080," anyway so uh rand type is going to be mutable rand uh so i just want to see if i can simply generate"
8883080,8891800," this kind of thing right uh all right okay uh"
8891800,8903160," so stack two non-exhaustive pattern okay so this one is going to be unreachable right"
8906120,8916520," okay so this is everything i wanted to do really like that's it how hard could it be to just generate"
8916520,8926920," a bunch of random shit my god holy fucking shit and and again according to the contract i must i'm"
8926920,8935960," supposed to pretend that this is normal everything's okay it is helping everyone uh okay so um cool um"
8936520,8944680," yeah i just want to generate a bunch of random data uh so now we can try to do a recursive generator"
8944680,8949640," right that i suppose do the thing"
8949640,8958440," so the idea is going to be the following right uh the idea is going to be the following uh generate"
8958440,8964040," tree uh we're going to accept the stack right we're going to accept some sort of like a root stack or"
8964040,8972360," something uh it's going to be stack and it's going to be mutable uh type stack right so in here we're"
8972360,8981320," going to just push like a couple of nodes onto the stack right so for um in zero three uh right so"
8981320,8988440," basically stack push and we'll also have to pass the uh allocator right so it has to be something like"
8988440,8999000," data mute um whatever what was that uh frame a time right frame a time there we go so i push this thing"
8999000,9005880," here and i just want to have a random uh and also you have to you need to have this thing right so you"
9005880,9012840," have to you need to have the random number generator and uh the allocator and there you go so here is the"
9012840,9020520," and you have a random type so you you just type a bunch of uh bunch of types oh my god i'm so tired"
9020520,9030280," okay so what do we have in here so you just have to do it like that uh cool um where is the main so i'm"
9030280,9036360," going to move the main this is going to be the new main uh generate the tree so here what i want to do"
9036360,9048200," i want to split this entire thing like in two right uh i want to split this thing in two essentially um"
9048200,9052680," i'm gonna continue generating the tree to"
9052680,9066200," let stack zero stack clone right and uh i'm gonna clone it in here right so"
9066360,9075480," uh something like this then i'm gonna continue execution on the previous stack might as well"
9075480,9083320," yeah that's fine so it's gonna be random ater stack and then uh on the stack zero but we also need to"
9083320,9090920," keep track of the level right so uh let's introduce level use size and if level is equal to zero we just"
9090920,9098920," return uh right so and in here every time we do a call we decrement the level by one right so we can"
9098920,9106920," have several levels in here so we start with a specific stack with the default stack right and i just want"
9106920,9117400," to generate a tree uh so i also need to do something like rand rand seed 69 so there we go and uh i generate"
9117400,9125240," tree so i provide the random number generator rand then i provide the allocator hater and then i provide"
9125240,9131720," this stack right so and how many levels we want to generate let's let's say three right so we can generate"
9131720,9137000," three and generate three levels so that will basically just push some stuff into the stack then it will"
9137000,9142760," split the stack and continue pushing and it will just do that recursively and just generate a bunch of"
9142760,9152600," stuff uh okay so this thing oh this one is interesting so i feel like maybe we have to pass this stack"
9152600,9161240," stack by the by the reference or something um so let me let me see um i might as well actually do it like"
9161240,9168120," that it feels like i have to do it like that uh cannot borrow as mutable it's not declared as mutable"
9168120,9177720," okay so okay all right so let's take a look at the svg are you guys ready are you guys ready boom"
9177720,9185640," so here is the current situation with the stack right so essentially we had a stack uh so basically"
9185640,9191720," the stack grows upwards right so we pushed a bunch of stuff then we split it and then continue pushing"
9191720,9197800," and uh as you can see yeah there we go so this is the persistent data structure so and at the end of the"
9197800,9207880," day we just had four stacks right and they share some of the parts of each other so yeah so and all of the"
9209560,9213400," all of the reference counting is actually correct in here as far as you can see we can"
9213400,9218840," increment the uh the levels right so let's actually have four levels so we have to be careful because"
9218840,9225080," it grows exponentially right so that's essentially what we have in here and maybe we can even split"
9225080,9231960," it in three because why not we can have something like stack one and stack one in here so it's going"
9231960,9240040," to be a little bit more branching uh right so as you can see yeah it's just grows exponentially so yeah and"
9240040,9245160," as you can see here is the reference counting is working more or less correctly um"
9245160,9248520," so that's pretty pound"
9248520,9254680," seems to be working so um"
9257000,9265480," and i can use this thing i can use this setup i can use this setup for porth finally right because"
9265480,9269480," at the beginning of the stream i said that for porth i need uh some sort of like a memory"
9269480,9275480," memory management system and data structure which will allow me to just clone the stacks"
9275480,9281240," right uh quite easily and quite inexpensively so i don't have to do too much of the memory"
9281240,9288760," memory management and i think this thing suits that goal quite well uh and i'm actually super happy so"
9288760,9295720," yeah i really like that uh does anyone have any questions about what we've done so far"
9295720,9298520," uh"
9298520,9306520," to do to um okay"
9311240,9322200," so do i need to upload this anywhere because this is like a throwaway program that i don't really"
9322200,9327960," plan to do anything with because i will need to translate this idea to porth at some point"
9327960,9332440," uh i just want you to explore that idea on the stream so all of that is going to be moved to porth"
9332440,9337160," um right and then first we're going to have like a fixed arrays and stuff like that"
9337800,9344600," um i might actually upload that to gist right so maybe some somebody wants to play with this thing"
9344600,9348200," um yeah so i'm going to put it in the gist"
9348200,9361080," so how am i going to call it persistent uh stack rs and i'm going to paste this into i think so i can't"
9361080,9367560," see in this mist unfortunately so let's create do i want to create a secret one let's actually create"
9367560,9368200," a public one"
9368200,9378920," so upload it to pornhub does pornhub even support like code uh or text information"
9378920,9385160," persistent did they make a typo"
9385160,9391880," uh where did they make a type of today persis"
9394840,9403160," i understand and see a type i'm sorry anyway so uh it doesn't really matter uh so here is this"
9403160,9412040," thing and i'm gonna put that in description as well right source uh source code all right so that's it"
9412040,9417080," for today i guess uh thanks everyone who's watching me right now i really appreciate that"
9417800,9423800," have a good one and see you next time uh thank you for all the subscriptions all the donations and stuff"
9423800,9429240," like that hope i hope this stream was interesting it was definitely interesting for me uh i never"
9429240,9437320," actually seriously used reference counting and i can see that for this specific case it is actually very"
9437320,9445720," very very useful so yeah okay thanks everyone for watching i'm really tired so i need to go eat something"
9445720,9458760," love you all you"
