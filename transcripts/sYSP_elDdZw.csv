start,end,text
0,5360," can i just write like a c program that uses all of these procedures so coroutine go it definitely"
5360,9600," doesn't return anything but it accepts the pointer to the function it's a pointer to the function that"
9600,15440," also doesn't take anything in it this one doesn't return anything and doesn't accept anything yield"
15440,19280," is kind of similar if you think about it so and now we should be able to create some something"
19280,29760," interesting like counter int 0 10 plus plus i so maybe here we can include stdio print f d and here"
29760,36480," is the entry point for routine in it coroutine go just use counter let's create like two of them and"
36480,42400," indefinitely let's just yield like this and by the way we should also yield on each iteration of the"
42400,45600," counter too otherwise it's not going to work properly i guess that's it"
48960,58880," let's go let's go look at that i have coroutines in c implemented in assembly in a completely"
58880,65120," different assembly not even a gnu assembly gnu assembly phasm phasm is the way to go"
65120,77040," all right chat do you guys know what is a what the is coroutine um i should probably not start the"
77040,83040," video with a what the otherwise i'm gonna get demonetized i mean i'm not monetized in the first"
83040,90880," place so that do you know what the is a coroutine right so uh essentially um let's actually"
90880,95680," take a look at some example a very interesting example we're going to write that in c uh because"
95680,101360," it's an example i want to be able to actually quickly uh quickly start an example so imagine you"
101360,108880," have a counter right so and it's a simple procedure that just counts uh right so you do something like"
108880,119360," from 0 to 10 uh plus plus i and you probably just want to print f uh something like d i so it's basically"
119360,126960," counting from 0 to 10 and printing the the numbers it is counting so you run that in the main uh in the main"
126960,134400," procedure all right so let's actually compile the entire thing uh main.c and run the entire application"
134400,141520," okay so but then i want to actually run the same routine the same procedure but in parallel"
141520,148880," right so i run it in parallel and uh well i mean yeah i'm running it sequentially so if i do it like"
148880,156400," that it's not going to be in parallel right so first uh the first call executes then uh the second call"
156400,163360," executes but i want them to be interleaved i want them to be interleaved um so essentially i could"
163360,169360," probably run them on separate threads but uh how exactly they're going to be interleaved is particularly"
169360,177120," not particularly predictable so uh essentially uh coroutines allow you to implement that uh so they"
177840,184560," usually traditionally introduce um like a special keyboard like yield uh right so and there's"
184560,189840," different kind of coroutines uh that work in a different way i have different kind of you know"
189840,197280," properties and different kind of keywords so i'm looking like it's you know very basic very generic"
197280,203280," coroutines right so imagine you have a procedure and uh it's executing in the loop and uh on each"
203280,210480," iteration after printing this thing it calls yield right so and essentially here we can use maybe a"
210480,215440," goal notation and we can say that run that in a separate sort of core routine right so this is how"
215440,223360," usually gold does that right and what essentially will happen is that this routine executes it prints i"
223360,230240," then on yield it will switch its context it will switch its execution to the next routine"
230240,237440," uh execute the code until the next yield and then switch to the next one and next one so it's basically"
237440,252160," going to round all right we're back uh so yeah this one actually was quick right so today we only started"
252160,258000," we already went down so i had to uh you know turn off the vpn and stuff like that so i'm glad that we're back"
258640,264160," right so essentially uh we are running two coroutines and they're running sort of like"
264160,270640," simultaneously uh right and every time you call yield it switches the execution to the next coroutine"
270640,276720," where the next coroutine uh actually called yield right so this yield becomes sort of like a switching"
276720,281680," point between several coroutines and what's interesting is that all of that can execute"
282400,288800," on a single thread so we're sort of switching the execution context within a single thread without"
288800,296560," any multi-threading or anything like that so why would you need this kind of stuff for the same reason"
296560,303200," you would need futures right so remember we developed like a future library for c3 uh right so and the whole"
303200,312320," point is kind of um to be able to do uh something while you're waiting for something else like in"
312320,317840," case of asynchronous networking right so in case of asynchronous networking you have non-blocking"
317840,324960," sockets that may have something to read or they have an opportunity to write but maybe sometimes"
324960,330160," they're not ready to read or write and while they are not ready you don't want to waste time you don't"
330160,335920," want to waste cpu cycles you want to do something else and this is where futures are really useful right so"
335920,342240," because they basically um split the code into these small blocking chunks and between those blocking"
342240,348320," chunks you can actually do something else right the same thing in here so it could be used for the"
348320,354560," same uh for the same purpose right so essentially you're doing something within a coroutine and then"
354560,360640," you encounter something that like you have to wait for something okay so i can basically tell the run time"
360640,366880," the execute the execution engine okay go do something else i have nothing else to do right now so go do"
366880,374960," something else and you yield right you can even say that okay so don't resume me until uh that socket uh"
374960,380320," you know has something to read or something to write you can even do something like that it's sort of like"
380320,388000," the same the same the same purpose in fact futures are literally kind of like that aren't they so uh we"
388000,394720," can take it some of the examples right so i think here we have a very simple example without any highlighting"
394720,401920," or anything like that and here we even have a counter right so an account of future uh so let's actually"
401920,410080," maybe fetch the stuff from the future library right so it feels when i looked at how uh coroutines worked"
410080,417120," in the lib meal library that we looked at uh i mean on one of the previous stream right um so on one of"
417120,423120," the previous stream and we looked into this library and this is by the way what inspired today's stream"
423120,428160," right so i looked at this library and i got really inspired and i wanted to explore how exactly you even"
428160,434880," implement things like that uh lib milf yeah exactly so here's the lib meal i'm going to uh go into the"
434880,442480," description so here is the lib meal and uh let me see so let's actually find this stream where we did"
442480,448080," i can't find the stream because i turned out the vpn so i i don't have an access to youtube i'm sorry"
448080,455520," so i i'm gonna do something like a lib meal uh string right to be done so it's going to be in the description"
455520,461440," for the uh for the youtube people but you here uh into which you can just google the app right so i"
461440,467040," think it's one of the like latest videos i think it's called something like this library turns c into go"
467040,477600," or whatever right um so essentially i i get really inspired and uh it feels like futures and coroutines"
477600,484400," are kind of isomorphic they're kind of like yeah they're kind of the same right so uh essentially"
484400,495280," the future has pole right so if you take a look at the interface of the future uh here it is so interface"
495280,503840," future right so it's just an object that has a method pole that gives you a result telling you that"
503840,508960," something finished or not and the execution environment the runner of the future is"
508960,516240," supposed to constantly pull it constantly call this thing checking whether the uh the job is done or not"
516240,522000," and uh so the future itself is supposed to do a little bit of a work a little bit of work within"
522000,528960," that pole and then return status spending telling the executor telling the runner that okay go do"
528960,535280," something else and you may have several futures right and the runner is going to just like pull one future"
535280,540080," right look at the result of this feature and then pull another one and another one and another one"
540080,547200," so essentially it's a mechanism to uh tell the environment i'm done for now go do something else"
547200,555040," kind of similar to what the coroutines uh are doing in here right it's it's kind of similar to that"
555040,563200," right so here i'm just like saying okay go do something else go do something else um so and um"
563840,571200," i really liked this approach because it's a little bit more uh readable in the sense that it's it's easier"
571200,577040," to reason about because it feels like just you know um a sequential imperative code when you're"
577040,580960," working with futures if you take a look at the examples they look horrible honestly"
580960,588320," they kind of look horrible uh so here it is so here's the how you do the counter right look at that"
588320,595200," so you're supposed to implement poll right and within the poll you extract the state you check"
595200,600320," that the state is less than 10 you print that stand and then if it's less than 10 it's pending"
600320,606560," if it's not it's finished so this is how it looks like this is one single future whereas with coroutines"
606560,613760," uh you basically do just a regular loop and you just insert additional yield in here right"
614800,622000," so uh it it's it's better it looks better it feels better it's easier to reason about but the question"
622000,632000," is how the do you even implement that right so like like how do i stop execution especially in c and see"
632000,638880," like or in c3 right how do i stop execution and switch to a completely different context"
639440,646240," like how the do i do that so in fact if the language doesn't have an explicit support for"
646240,654480," this kind of stuff there's nothing much you can do anyway unless you go lower level right unless"
654480,659120," you go lower level there's nothing much you can do about that because it's a mechanism that has to be"
659120,664960," implemented explicitly on a lower level with futures you can kind of implement them on a higher level right"
664960,669440," so if you don't have an explicit support for coroutines in your language like you don't need"
669440,674640," anything special you can just implement this abhorrent you know interface and it kind of works it kind of"
674640,681200," does what you want but it's kind of kind of meh right so but maybe functional programming fans love"
681200,686880," this kind of interface right so because future feels like kind of a monad even though some function"
686880,691760," programming purist will say no it's actually not a monad because it doesn't satisfy monadic laws that"
691760,696960," nobody knows about only i know about because so i can feel elitist and stuff like that so you know"
696960,703120," uh right so maybe people like that kind of laugh futures but as you can see they're kind of difficult"
703120,710400," to work with so i i as an imperative programmer right so who actually gets the done unlike functional"
710400,715600," programmers uh i would like to you know think imperatively i would like to think imperatively"
716400,723840," uh so and i want to explore how you would even implement something like that how you would implement"
723840,730640," something like that so first of all you kind of have to save the execution the the context of the"
730640,740400," execution and this kind of vaguely reminds me long jumps do you guys know what are long jumps"
741680,749280," so there is a regular go to's and stuff like that that allows you to jump over things uh right so for"
749280,757600," instance uh you can say you should never see me right so you should never see me and then you go go go"
757600,765440," to skip right so and in here you have a label skip uh and uh then you can put something like hello in here"
765440,771520," right so you can put something like hello in here and then we can try to compile this entire thing as you can see i never actually seen this"
771680,776800," print tab because i literally skipped it right so you can jump around however you want"
776800,783440," uh right so dextra said that go to's are bad and because of that every time programmers see go to they"
783440,790400," have a seizure so i suppose like half of the audience right now is literally having epilepsy right so i really"
790400,797360," apologize for that uh so i know that dextra said that it is bad but we are trying to explore things in"
797360,802160," here so stay open-minded we're gonna do a lot of horrible shit today"
802160,808880," seriously just just be prepared that's kind of welcome to the tzodian channel by the way right so"
808880,815120," where we say establishment best practices we do whatever the we want because it's a"
815120,820480," recreational programming it's a recreational programming we just enjoy what we do"
820480,825840," fuck you so that's basically the tzodian channel anyway so you can jump around but unfortunately"
825840,832320," uh you can't jump to a different procedure right so i i can't really create a label"
832320,839200," inside of this thing it honestly it will be actually kind of cool and it will like basically do what we"
839200,846160," expect i can't jump into full right so if i do some something like jump into full uh it will yeah label"
846160,851120," food used but not defined right so it's not defined so we can only jump within the procedure but you"
851120,858080," can't really jump between the procedure and this is where long jump comes into place right so we can"
858080,868480," take a look at this what what is long jump uh long gmp uh yeah perform a non-local go to perform"
868480,873440," a non-local go to and it consists of two functions it consists of two functions it consists of two"
873440,881840," functions set jump which accepts environment which accepts environment and long jump which also accepts"
881840,889360," environment and a value that said the jump will return so essentially said jump acts like setting a label"
889360,897600," right so it acts like setting a label um so what we can do in here essentially imagine that we have"
898880,909520," along a call stack right so essentially in here we're calling foo uh right and um so within foo"
909520,918480," uh within foo we're going to be calling bar uh like so we're calling bar and within bar maybe we're going"
918480,926400," to be printing something all right so we can say bar maybe within four we can also print foo so we can have"
926400,935520," some sort of like tracing in here right so we have some sort of tracing and essentially um essentially"
935520,946400," what i want to do um i want to uh basically put a label somewhere here right so let's say jump buffer"
946400,954960," right so this is the environment and then i say send uh jump environment so essentially this call"
955680,961280," uh takes the current execution environment takes the entirety of the execution environment and saves it"
961280,968320," into this opaque variable we don't really know the type of this variable it's absolutely opaque in fact"
968320,975760," it's um architecture specific right so it's even platform specific like it depends on uh the current"
975760,981760," cpu you're running and also the current operating system and libc usually implements like all of the"
981760,986480," possible combinations right and stuff like that well i mean libc usually works on posex operating system"
986480,994240," right so but it usually basically has like a little snippet of assembly code for each an individual um"
994240,998400," for each individual architecture in fact we can even see that right so you can go into something like"
998400,1006160," musil which is a like a very simple uh lightweight implementation of libc so we can put it somewhere here"
1006160,1011120," so it's going to be in the chat and for people who's watching is going to be in the description uh"
1011120,1019280," and also i think i want to put my futures library into into description as well right so here it is"
1019280,1025280," so let's actually download i think i already have it downloaded i do in fact think that we have it"
1025280,1032160," downloaded so here is musil you can literally just search for a file with a name set jump right so"
1033760,1040480," do that already okay so here it is and the um extension s is assembly and look at that here"
1040480,1046480," are all of the architectures all of the different cpu architectures and for each individual cpu architecture"
1046480,1051200," it has a little assembly snippet right so we can even take a look at x86 64."
1051200,1057840," uh right so and this is how it is implemented so set jump is literally just a sequence of uh you know"
1057840,1064640," x86 64 instructions right so it's never implemented in c you can't even implement it in c right you you"
1064640,1070560," can't implement this thing in c because c is too high level for this kind of thing we need to go like lower"
1070560,1078160," level uh right and what it does look at that so rdi is a register that contains the first argument so"
1078160,1085040," it's basically sort of like a pointer and look it actually basically treats it as an array of um you know"
1085040,1092480," 64 bit integers and it saves different registers in here right so it basically just saves registers"
1092480,1098320," into this buffer so you have some sort of a buffer and it dumps the registers in well into that buffer"
1098320,1104480," so then later you can restore it so essentially what it does it saves the current execution environment"
1105200,1114000," right um so and then what we can do uh right so we we save this environment in here and i think we can"
1114000,1119680," make it global because i want to be able to access this variable from within bar right so and in here"
1119680,1130800," what i do i perform long jump um right so and what this thing will do from here it will jump back into set"
1130800,1136880," jump through all of the call stacks look at that through all of the call stacks it will jump back to"
1136880,1143360," here right but in that case it will actually call foo again so we're going to go into this infinite weird"
1143360,1150400," loop and this is why long jump actually accepts a parameter right so if you just do set the jump as it is"
1150400,1157280," it returns zero false but then if you do long jump with one this particular call will return"
1157280,1161760," one or whatever you put in there and that way you can actually distinguish whether you're just setting a"
1161760,1169120," label for the first time or you're jumping or you're restoring the environment right restoring"
1169120,1177360," the environment so essentially in here if not uh so basically it returns zero so we do call uh otherwise"
1177360,1187280," um jumped back uh jumped jumped back now if we try to run this entire thing it's going to be rather"
1187280,1193280," interesting so jump is not available so we have to actually include something uh so it is probably"
1193280,1202080," available in one of the headers um set jump please what's the header oh it's literally set jumped at h okay"
1202080,1210240," fair enough fair enough uh okay so and we kind of forgot to add new lines for each individual thing in"
1210240,1221040," here so let's quickly do that um okay so there we go so look at that it said foo but it never said bar"
1221040,1230880," it then jumped back look at that so and jump back is behind this else so we went to foo then it printed"
1230880,1238640," foo we went to the bar and then it jumped back skipping bar and since it jumped back to here and returned one"
1238640,1247440," which is true it then went here look how non-linear it is right look how non-linear it is you can basically"
1247440,1254640," save the current execution environment and then restore it and that feels like exactly what we"
1254640,1261680," like this is mechanism through which you can kind of implement coroutines can't you like here it is like"
1261680,1268880," like like right there so yeah so because you save an execution environment so and then at some point"
1268880,1273360," in the core routine you can say okay switch to the next execution environment you can have an array of"
1273360,1278880," these things uh right you can have an array of these things and you can just basically switch between them"
1278880,1284240," and stuff like that and it's gonna be cool but no you can't do that"
1285360,1289200," who knows why who knows why who knows why you can't fucking do that"
1289200,1298640," a scout exception yeah it's it's kind of like skeptics exceptions um how to follow how code executed i mean"
1298640,1305760," we're talking about coroutines um call stack size yeah so essentially this is because of the stack"
1306560,1315040," at least i think so right so and there is even uh a note about that i think it's in this section undefined"
1315040,1323920," behavior yeah if the function which called set jump returns before long jump is called the behavior is"
1323920,1333280," undefined some kind of saddle or unsettle chaos is sure to result here is the thing the state of the execution"
1334640,1344800," the state of the execution is not only the registers it's also your current stack right so this entire"
1344800,1351200," thing if we take a look at the um implementation of this function of this function it the only thing"
1351200,1360000," it does it just saves the stack pointer nasal demons and coming yeah uh right so it just saves the stack"
1360000,1369600," pointer but the stack still stays the same the stack stays the same and if you have several coroutines"
1369600,1374560," what essentially is going to happen they're going to share the same stack and they're going to be"
1374560,1381760," overriding this their own state on the stack constantly between each other and some sort of a chaos will"
1381760,1389360," you know ensue some sort of a case will ensue we can even like maybe you know draw that i think it"
1389360,1397840," will be kind of useful i think it's going to be kind of useful um so do i have my my thingy majingy"
1397840,1408000," hopefully so here is this stack uh i'm not sure how can i conveniently place myself in here but"
1408000,1417360," so here's where the stack begins right so this is a stack pointer and very importantly uh this stack"
1418400,1430000," grows towards zero address it doesn't grow towards uh plus infinity right so it grows towards zero"
1430000,1437760," so every time you call a function every time you call a function a return address after the call of the"
1437760,1445040," function is put on the stack so you can return back so this is what primarily the stack is used for"
1445680,1452320," then the procedure that you called the procedure that you called puts some sort of arguments in there or"
1452320,1460880," local variables right so you can put vars in here like this then it may call another function which will"
1460880,1474320," result in return address put again and so on and so forth as you uh call as you execute the code the stack grows and"
1474320,1482320," and shrinks all the time it grows and shrinks all the time so essentially imagine that at this specific"
1482320,1489920," point where you're executing you're executing and then you say yield to the next procedure okay we jump to"
1489920,1495280," the next procedure but the stack uh for example for that procedure was pointing here as well"
1496080,1502000," so that stack that stack that stack is like that procedure is going to have the variables of the previous"
1502000,1509280," coroutine so if you have two coroutine on the same level they're going to be overriding its own local"
1509280,1522720," variables that is why you have to do set environment set jump in here and always do long jump where when you're"
1522720,1530640," you're somewhere here right so you have to do long jump after you did set jump not after like you returned"
1530640,1535200," it right because otherwise you grow in the stack and some sort of a garbage on the stack is happening"
1535200,1544720," right so this is quite important because of that you can't really use uh the uh you know set jump and long jump"
1544720,1552880," for implementing coroutines to implement coroutines you have to literally have a copy of the stack"
1552880,1561520," for each individual coroutine right and as you switch the coroutine context you have to literally switch"
1561520,1568480," the stacks that's what you have to do otherwise it's not going to work um can you have multiple stacks for"
1568480,1575600," each code this is a cool idea where do you get that idea from so thank you we'll think about that so uh"
1575600,1582320," just right now"
1582320,1593360," so yeah um essentially uh not only we can't uh use existing language mechanisms we can't even use the"
1593360,1599280," standard library even though the standard library kind of has something resembling what we want but"
1599280,1604400," we can't use that right so because it doesn't clone the stack we kind of need to clone the stack"
1604400,1613600," uh right and that means like we have to dive really really balls deep into assembly as much deep as"
1613600,1620400," possible and that's what we're going to be doing today on today's stream sounds good sounds gucci sounds what"
1620400,1633440," tamaguchi let's go let's actually do assembly finally um so yes so i want to do"
1633440,1639680," everything entirely in assembly right so the uh coroutines are going to be implemented in assembly"
1639680,1644640," we're going to implement the counter also in assembly i want to do everything in assembly to minimize the"
1644640,1652080," amount of noise introduced by the compiler we could have used in line assembler in c compiler or in c3"
1652080,1656640," compiler by the way c3 has an inline assembly which is actually kind of cool i haven't tried it yet"
1656640,1662560," but maybe in the future we're going to try it um i can't open it because c3 is banned in russia for"
1664480,1665920," for dangerous propaganda"
1665920,1678160," so yeah so c3 is uh actually spreading very dangerous propaganda in russia which is threatening the"
1678160,1686400," the state so anyway uh but trust me it has inline assembly right it does in fact have inline assembly"
1686400,1693840," so and uh because the compilers may generate all sorts of shits right so in uh preambola and like you"
1693840,1700160," know prologue and epilogue of the function right prologue and epilogue is usual names for boilerplates"
1700160,1707600," that uh you know compilers put between between the begin and end of the procedure uh they can introduce"
1707600,1712800," some additional noise uh and stuff like that i want to minimize the amount of noise right so we have full"
1712800,1719040," control over what is going on so we can understand precisely what the fuck is going on in a very low"
1719040,1726960," level i think it is important right i think it is in fact important so let's create a simple uh you know"
1726960,1732320," asm program right so we already did a stream where i sort of refreshed my assembly skills right so you can"
1732320,1738640," maybe watch that stream on youtube i can't open youtube but i'm gonna put myself a tbd uh right so tbd"
1738640,1748800," stands for for the the big d so it stands for to be done all right so um um assembling stream right so"
1748800,1758080," i'm gonna put that there when i upload the video so uh let's do format uh elf 64 executable right so"
1758080,1766240," executable and let's just create this kind of thing uh so we need to do as you know exit sys call so i'm"
1766240,1772880," going to move into rex sys exit and and i just happen to remember that sys exit is actually 60."
1772880,1776480," the the reason why i remember it is because we literally did it in the previous stream so i"
1776480,1781760," still kind of kind of remember these codes right so to program an assembly you don't have to remember"
1781760,1787280," any of that shit you can always look it up uh right so you can do like a linux um you know it's just called"
1787280,1793280," table it's just called table i already did that so in here it is you can just look it up there"
1794080,1799920," i just happen to remember that it's 60 because i work it's also banned in russia okay is the chromium"
1799920,1806000," also banned in russia no chromium is not banned in russia okay that's cool uh okay okay okay okay so"
1806000,1811680," we can do exit and in this specific case it's 16 right so as you can say i was right i remember that"
1811680,1820560," okay so an rdi which is the first argument is going to be the exit code uh sys69 and let's do a sys code so"
1820560,1826640," let me rebuild the whole thing so this is going to be something like that let's go and uh now if i try"
1826640,1833120," to run that it does in fact return 69 which is pretty cool okay so let's create some sort of a message"
1833120,1841520," uh right so let's say maybe hello world uh new line zero and then here let's put something like a message"
1841520,1847680," len which is the current address minus the address of the message which effectively gives you the length so and"
1847680,1854560," in here we can do rex sys right and i don't remember what is this right it's either zero or one uh it's"
1854560,1865280," actually one zero is read uh right so and here rdi is the file descriptor stdn file no right which is also"
1865280,1875840," one i happen to remember that uh rdi uh so rsi is the buffer message and message len and then we perform"
1875840,1882320," this is called message len all right so let's actually try to run that and we have an illegal"
1882320,1889520," instruction at 19 which i do not quite understand uh so because this has to be db to allocate some bytes"
1889520,1896160," bytes you have to do db and uh it exited up normally but they didn't print anything"
1896800,1903760," which is kind of weird in my opinion so because i supposed to put rdx in here okay so and it's also"
1903760,1911840," printed uh zero in here oh yeah i forgot yeah yeah we're supposed to put zero uh like everywhere in"
1911840,1918240," here by the way uh i haven't acknowledged the subs people been subscribing so let me quickly do that"
1918240,1924400," uh so thank you so much the rug uh the rugged bear 40 one's question with message cock routines very"
1924400,1929360," funny very funny indeed uh numeral zero thank you so much for telling the message listen to this stream"
1929360,1935120," makes me really realize my assembly couldn't handle those in score routines i mean it's just it's all"
1935120,1939200," about the practice there's also google there's also chat gpt you can you can learn all that stuff"
1939920,1945040," uh alimark71 thank you so much for twitch prime with the message new to twitch shy do i have to"
1945040,1951760," manually subscribe every month i don't really know because i don't really subscribe to anyone else i"
1951760,1957360," can't do that uh but as far as i know twitch prime i think twitch prime has to be manually resubbed"
1957360,1965520," right so it's just a regular subs uh that are automatic but twitch prime is manual so razz"
1965520,1969760," jr08 thank you so much for the prime uh with the message thank you mr for kickstarting"
1969760,1974240," my interest in recreation programming again you're welcome that's exactly my goal"
1974240,1977600," tam voodoo thank you so much for the prime and journey the rest thank you so much for the prime"
1977600,1985040," with the message uh what's sys call a 69 uh let's actually find out uh 69 and message sent"
1985040,1990480," it's it's sending the mystery that's what it is i have no idea what the fuck is that"
1990480,1999600," message sent so message cooperation so yeah that's what it is that's what this are you satisfied my friend"
1999600,2005920," are you satisfied are you satisfied i hope you are anyways uh so let's actually do zero in here and so on"
2005920,2007200," and so forth"
2007200,2020880," so anyway we need to be able to you know print numbers right so from the previous stream i got a routine"
2022160,2029760," so i got a routine which allowed me to print numbers which i implemented long time ago in ports so i'm"
2029760,2036560," going to copy paste it in here right so this is a routine that accepts um a number through rdi the"
2036560,2043920," usual call convention on linux and it just prints that number on the standard out of output plus new line"
2044560,2050880," the way i implemented this entire thing i implemented this entire thing in c and i compiled it down to"
2050880,2053680," assembly using c compiler and then i copy pasted it in here"
2053680,2063600," so people ask me how how do you program an assembly i i don't i just program in in normal"
2063600,2070960," language and i just compile down to assembly and just copy paste"
2070960,2075760," whatever works whatever works like i just don't want to implement it i i could implement this thing"
2075760,2080720," manually like i know how to do that right so the basic idea is that you allocate a little bit of a"
2080720,2089760," space on the stack right and then you divide the number by 10 and mod the number by 10 filling the"
2089760,2097600," digits into this stack and then you use that stack space uh as the buffer for for the right sys code"
2097600,2101760," so that that's what this entire procedure does it was just like easier to describe it and see"
2101760,2107840," uh right so and as you can see it also optimized it a little bit right so it uses really weird"
2107840,2113760," optimizations with these huge negative numbers and stuff and by the way here it allocated some space"
2113760,2119360," on the stack by subtracting rsp and stuff like that so yeah it did a good job c compiler did a"
2119360,2123840," good job so that's why nobody programs in assembly anymore by the way because c compilers are"
2123840,2128720," sufficient for this kind of shit anyways so we can actually test how it works uh so let's put"
2128720,2138880," move rdi69 and call print so that should do it and it didn't work and it's sequaled it i think it's"
2138880,2148720," not rdi rsi is that what it is bro what the it's scuffed uh yeah it's supposed to be rdi and it didn't"
2148720,2155440," work what the fuck huh no it doesn't work"
2155440,2167120," i'm surprised like ah i forgot that you need to put entry here so it basically if you didn't specify the"
2167120,2172960," entry it just starts the execution from the top uh right and at the top we have print and we we didn't"
2172960,2178160," have anything there so what we have to do we have to say entry and as you can see it brings 69 there we go"
2178160,2182560," there you go there you go you can actually put whatever numbers in there a one two three four"
2182560,2188560," five six seven eight nine whatever fits into your register and it actually prints all of that very"
2188560,2194560," conveniently so we can't really use printf because we don't really link with the standard library right"
2194560,2199360," so okay let's actually implement the counter routine let's implement procedure that we're going to be"
2199360,2207440," using as a core routine right so let's do counter uh and in here um we need to have a counter right so"
2207440,2213360," let's actually allocate that counter on on this stack right so let's allocate that on the stack so i wonder"
2213360,2223520," how we're going to be doing all that um so maybe i'm going to save the previous stack base right on the stack"
2224320,2232080," and then i'm going to say that the current stack is the new stack base right so rbp or uh stack base is"
2232080,2237280," basically like as you can see i've already said the stack is constantly growing right to the left left"
2237280,2243360," and right it's constantly growing but sometimes you want to have like a stable address within the stack"
2243360,2249280," right that doesn't move constantly left and right uh like relative to which you can identify the variables"
2249280,2256880," so quite often after uh you know people uh after you call the function you have a return address"
2256880,2263920," right so what people do they save on the stack the previous rbp value right so which was probably used"
2263920,2270560," by the previous function right and then they say the current rbp value to this so that means it doesn't"
2270560,2276400," matter where the rsp moving left and right you you always have the stable value value relative to which"
2276400,2282080," you can identify the variables and stuff like that right so uh yeah that's basically what's going on"
2282080,2291680," in here um so and in here we can maybe even say like subtract uh rsp8 so essentially we allocated one"
2291680,2298160," byte on the stack right so we allocated one byte in the stack uh so and when we are returning out of"
2298160,2305440," the function we kind of need to do the opposite operation so we add eight bytes to the rsp basically"
2305440,2314480," deallocating the variable uh then we are popping rbp and then we are returning so essentially people"
2314480,2321360," really take it for granted uh people really take it for granted when uh the basically defined variables"
2321360,2327520," local variables within uh procedure and stuff like that they never have to manage them but if you're"
2327520,2334160," programming an assembly you have to allocate local variables and deallocate them automatically right"
2334160,2341200," so here i'm allocating a local variable uh manually and then at the end of the function i'm deallocating it"
2341760,2346640," so and essentially uh what i'm going to be doing uh so the the variable is going to be located at the"
2346640,2353520," address rbp minus eight right so it's located at rbp minus eight and the first thing i want to do"
2353520,2359840," probably with this variable is actually set it to zero right so it's going to be zero so then uh we're"
2359840,2364640," going to have a start of the loop somewhere here so the first thing we do at the beginning of the loop"
2364640,2370560," we're checking whether the current variable um exceeds a certain value right so for example we can"
2370560,2378720," compare it to 10 right and if it is greater or equal than 10 we want to kind of you know finish the"
2378720,2383920," entire loop right we're going to do over right so we're going to have a special special label in here"
2383920,2390880," so if something like this happens uh it's over it's jover okay so and then here what we're going to do"
2390880,2396000," i'm going to take the current sort of flag pointer right and i'm going to move it into rdi as an"
2396000,2400240," argument for the print and i'm going to call print right so i'm going to just print the current count"
2400240,2408160," after that i'm going to simply increment this specific variable rbp minus eight just incrementing"
2408160,2413360," it and just doing it again right so just do it again i'm going to do it again and we're going to"
2413360,2420560," be doing it again uh at comparison right so here is the basic loop uh right which allocates a"
2420560,2426960," local variable which is basically like i variable uh initialize it with zero and just like iterates"
2426960,2432320," and prints the variable until it becomes 10 and then it just exits so that's basically the entire"
2432320,2438800," procedure very simple nothing particular special so it's actually uh try to maybe call this procedure"
2438800,2449680," once call counter uh like so and it doesn't work operand say oh yeah so essentially um here i'm trying to"
2450240,2458000," set zero to the address located at rbp with an offset minus eight but i didn't say"
2458000,2464480," how many bytes i want to actually write there so i have an address i say write zero at that address"
2464480,2470240," but i mean what is that is that a byte is that a short is that an integer is that a you know long"
2470240,2477360," integer what is that right so and in fact since i allocated eight uh it's basically 64 bit integer so"
2477360,2483040," that means it's a a quad word right in terms of assembly right so i'm saying that safe quad word"
2483040,2489440," in here so it probably will complain in here as well right so let's actually see uh yeah in fact it"
2489440,2494240," complained in here as well but it's not going to complain in here by the way it's not going to complain"
2494240,2500160," in here right so it now it complains at increment uh it also complains at increment but it's never going to"
2500160,2507840," complain to complain in here uh right so and the reason is uh you're trying to move this thing"
2507840,2514800," into the 64-bit register it infers the size of the read from that address from the size of the register"
2514800,2520160," into which you're saving so depending on what kind of size of the register you use it will just read"
2520160,2524160," different amount of bytes in here so you never really have to specify how much you want to do the"
2524160,2530080," read and write there but if it can't infer that you have to explicitly say that right so that's"
2530080,2536320," basically how it works right hopefully hopefully that makes sense but anyway uh so if i try to now"
2536320,2542080," run the whole thing right it actually prints from 0 to 9 as you can see so it just prints from 0 to 9."
2542080,2546960," type inference in my sample yeah exactly um so and this is basically the counter the counter routine"
2546960,2551440," that we implemented and i suppose one of the things i want to be able to do in here is i want to be able"
2551440,2559360," to call call routine yield or something right so some sort of procedure and that procedure should switch"
2559360,2565760," to the next uh you know counter routine right somehow by modifying the stacks by modifying the"
2565760,2570400," environment and stuff like that it has to do that luckily we are programming an assembly so we can"
2570400,2576160," actually do all of that stuff so i'm going to comment it out for now uh right so if i just call this"
2576160,2581840," entire thing uh if i just call this entire thing right so as you can see it just like executed one"
2581840,2587920," then it executed another and so on and so forth so this is not going to work that easily"
2587920,2596800," okay so first we need to be able to allocate separate stacks for each an individual um for each"
2596800,2603840," individual quarantine so that's one thing we need to do let's actually go ahead and just allocate like"
2603840,2611520," at the end of the executable in here let's just reserve like a huge as buffer right huge as buffer"
2611520,2617040," and say that this is where we're going to have all of the stacks right so there's going to be stacks and"
2617040,2624960," just like reserve bytes like and allocate like i don't know 100 500 like like a lot of bytes in there and"
2624960,2630080," there we go so i don't want to be calling to malloc or anything like that just like allocate shit ton of"
2630080,2641120," stuff um so to be fair what we can do um we can basically say that we can limit the amount of core"
2641120,2646080," routines you can actually start within a single application just for the demonstration purposes"
2646080,2656320," for the exploration purposes um right so we can say core routines um max or maybe capacity right so"
2656320,2661760," capacity uh and let's say that you're going to have 10 core routines right so we're going to have arrays"
2661760,2670080," of stacks and maybe arrays of contexts contexts contexts contexts arrays arrays of contexts and we're"
2670080,2675120," going to have uh you know their size to be this thing right so that way we don't have to work with"
2675120,2682560," dynamic memory too much so and um let's actually say that we're also going to have like a stack uh"
2682560,2689680," capacity right so the maximum capacity of the stack per core routine so what's the ideal capacity for the"
2689680,2697600," stack is one kilobyte for the stack enough for everybody with this thing how about four kilobytes"
2697600,2706000," so yeah i don't know so four kilobytes is okay so let's actually put four kilobytes in there"
2706000,2712000," so essentially here we can allocate um you know coroutines capacity multiplied by the stack capacity"
2712000,2715440," stack capacity so this is how we're going to be doing all that"
2717360,2722160," so golang has one kilobyte oh people know how go golang internally works i personally don't know"
2722160,2727280," so yeah thank you thank you for telling me right what's interesting is that we can now build it and"
2727280,2733760," the size of the entire executable is actually this what's funny is that what's funny is that if you move"
2733760,2743840," the reserve beef like before the message uh the size of the executable will blow up to 41 kilobytes"
2746800,2751360," right if you put it in here it actually becomes three hundred and ten bytes"
2751360,2762480," uh so this is because rb doesn't really set a specific value it reserves it reserves a certain"
2762480,2769040," amount of memory so i feel like uh you have to do the reserves at the end of the executable so then"
2769040,2773920," the assembly has an opportunity to just like not actually include any zeros in there or anything like"
2773920,2782720," that but if you say reserve in here ah what the is going on okay but if you say reserve in here"
2782720,2788560," and then a specific value i think it will literally just fill everything with zeros and then put hello"
2788560,2794320," world at the end we can actually check that i think i think i want to see that so let me let me actually"
2794320,2798000," open it open it didn't bro where is main"
2798000,2809440," ah i'm sorry i just like okay so here are the zeros uh you know at thingy with the the cap uh is basically"
2809440,2815680," zero this is how emacs denotes zero then at the end yeah and at the end we have a hello world so it's he"
2815680,2822880," so here's he and here is a low world right so maybe i can yeah here it is so it literally put hello world"
2822880,2829600," at the end and then it reserved the shit ton of zeros so that's how it works so because of that when you"
2829600,2834640," reserve things uh you have to be really careful so it's better to reserve the these kind of things and"
2834640,2841040," initialize memory at the end right so that way you're not creating huge ass executables so as you can see"
2841040,2850080," here it's just like um so i suppose when you reserve everything at the end it gives the opportunity"
2850080,2856160," for the compiler to just create an elf that can be just mapped to memory and then you can say okay"
2856160,2861680," after that specific point just like uninitialized or filled with zeros or whatever and the operating"
2861680,2864400," system will just do that so you don't have to store that additional information"
2867760,2877280," so this is how i presume it works anyways so we also need to store on top of like having a space"
2877280,2884320," for the stack we need to have our own jump buffer environment right so our own environment things"
2884320,2892080," so to be fair since we're programming an assembly we're not really modifying registers too much like we"
2892080,2899280," don't really care if we retain the states of the registers right so the only registers that are important"
2899280,2907280," for us to retain here i suppose are rsp the pointer to the stack rbp the base of the stack or the base of the"
2907280,2919600," frame and uh rip right so basically current um instruction pointer so we only care about rsp rbp and the"
2919600,2926320," instruction pointer so we can only save those you know what i'm looking about right so for now since"
2926320,2931760," it's sort of like a exploration let's not over complicate everything let's not just save everything"
2931760,2937120," as for example set jump does in muscle right so it saves shit ton of different like registers and stuff"
2937120,2941360," like that let's not do that let's not do that let's only save these things and i think for for now"
2941360,2948080," these things are the only things we care about so uh where can we actually store all that stuff"
2948080,2952160," so it would be nice to maybe store them in a structure right some sort of a structure"
2952160,2964000," um right so let me see so xbps query f fosm here is the documentation let me grab the documentation"
2964000,2973120," you didn't copy paste it in the right place brother okay so struck i really don't like the structure"
2973120,2980160," syntax in fosm in fosm it doesn't really make much sense to me um i still have not figured out how to"
2980160,2990080," make arrays of structures right uh so it allows you to create a bunch of things but how do i create"
2990080,2999600," several of them i have no idea i literally have no idea like so okay we can go ahead and maybe just"
3000560,3008720," you know create this kind of thing you know so we can say this is the context"
3008720,3016240," right and within the context we're going to have we're going to store uh the current rsp which is going"
3016240,3029280," to be you know reserve q right so it's just one uh one 64-bit integer so then rbp rq1 and then rp also rq1 so"
3029280,3035920," this is the register that we are storing in here so and obviously then what i want to do i want to do"
3035920,3043760," context and i just want to allocate a bunch of them right so but i can only allocate one in here right so"
3043760,3051600," it's going to be one how do i do several of them right so it doesn't make any sense to me right so it"
3051600,3061440," compiles but um can i can you do repeat so there was a rept so what if i want to allocate coroutines"
3061440,3070320," capacity is that something i could do so let me see fuzz them uh like this yeah so you're telling me"
3070320,3079520," that i can just do something like this do i have to put curly braces in here yeah you can't do that that's a"
3079520,3085920," illegal instruction and you can't even repeat that several times it is so bizarre all right so it has"
3085920,3092320," a mechanism for creating structures but it doesn't have a mechanism of creating arrays of structures"
3092320,3097360," like i could never understand does anybody know how to create arrays of structures in fosm"
3097360,3102400," it's just so bizarre to me and the official documentation doesn't have anything about arrays or"
3102400,3110000," several of them there's a times keyword like i just tried wrapped keyword are you talking about"
3110000,3118480," wrapped keywords right so i tried it it doesn't work with structures there's no times uh all right so"
3118480,3126640," there's no times directive repeats one instruction uh number of times blocks of instruction okay so can i"
3128400,3140960," uh okay times repeat this one no none of that works none of that actually works um so it's bizarre"
3140960,3145520," because it's kind of useless if you can't create arrays of structures the entire thing is useless"
3145520,3153040," um the entire thing is entirely useless so if we can't create arrays of structures can we create"
3155280,3158560," structure of arrays"
3158560,3164880," wait uh so because one of the things wait wait wait wait wait wait um"
3164880,3170320," you can parameterize this right so that means i can put"
3170320,3177200," yeah i can actually just put something like core routines capacity"
3180400,3183440," yeah how about fuck you yeah so"
3183440,3196400," i think like i just don't know repeat people guys if you don't know for sure there's no need to"
3196400,3204320," confabulate different things right like i can't confabulate myself different ideas so like times repeat"
3204320,3209200," while loop like i can't confabulate that myself i don't need chat for that if you don't know for sure"
3211280,3216960," anyways uh right so we're gonna have a structure of race we're gonna have a structure of race"
3216960,3228240," um so and i suppose now we should be able to do contexts uh rsp right so and then we can access it"
3228240,3236000," with like by upsetting it right so by upsetting it in a certain way um right we'll see how it goes so let me"
3236000,3243360," see if it compiles it does in fact compile so i suppose now i suppose now what we need to do"
3243360,3252800," what we need to do we need to have a structure we have a operation that creates a new routine"
3253680,3264160," uh right so let's create cool routine goal right and i suppose the easiest thing in here the easiest"
3264160,3269120," thing in here would be for this procedure to actually accept the pointer to the function that it needs to"
3269120,3279600," execute to start the routine uh all right so let's say rsi the like a procedure procedure to start in"
3279600,3284480," a new call routine right so that's what we're going to be doing here"
3284480,3291120," all right so here's the procedure so and i suppose how we're going to be approaching this entire stuff so"
3291120,3302240," i'm going to move on into rsi the count uh the counter and then i call core routine goal right so and i can"
3302240,3308480," call that like several times so and it should create several corrections okay that's cool uh the first thing"
3308480,3314960," we need to check the capacity right we need to check the capacity of this entire thing so we need to"
3316080,3322000," we need to track uh how many contexts will already allocate it right so that means we need to"
3322000,3331440," have something like contexts count right so and this is going to be rq1 right so this is a single"
3331440,3339840," 64-bit integer not cl but count right and in here so what do we do we take this value and"
3341280,3349920," and we compare it to the coroutines capacity right so the the maximum the maximum amount coroutines we"
3349920,3354960," can have in here and since we can't really infer the size of the reading here we have to say it's a q"
3354960,3363840," word okay and if that value is greater or equal to the coroutines capacity we should probably just fail"
3363840,3368560," the whole execution because this is sort of an assertion right this is sort of an assertion so let's"
3368560,3375680," actually do overflow fail right so this is an overflow fail and then that overflow fail we can just"
3375680,3382560," we can just straight up like exits right so with non-zero exit code and whatnot like with 69"
3382560,3391840," uh right and we also want to probably print the message that like too many coroutines right um so"
3393040,3406320," move racks sees right move rdi to many coroutines message uh but i mean it has to be something like an"
3406320,3410960," std error file number this one is rsi"
3413600,3419120," this one has to be rdi assembly assembly assembly is hard rsi rdi"
3419120,3427680," all right and this one uh rdx uh right and this one is going to be length so and then we do cisco"
3427680,3432640," so we just need to allocate the message for too many coroutines right so let's actually put it"
3432640,3437280," like somewhere along with other messages like hello world we probably don't even need hello world anymore"
3437280,3446400," right so many coroutines don't forget the zero and then the new line right so then we're gonna put a"
3446400,3454640," length in here uh and it's going to be just that there we go we don't need hello world and here is the"
3454640,3465280," message here is the message uh yep so in here maybe i'm gonna put something like int3 so int3 basically creates a"
3465280,3472080," a debug interrupt for those who doesn't know right so it's a special debug interrupt and um"
3472080,3481600," so usually that interrupt it invokes the debugger in one way or another so if you don't have an"
3481600,3487120," operating system i suppose you you just create a special routine in the interrupt table the famous"
3487120,3493600," interrupt routine right so how many of you actually read an interrupt routine in the chat tell me"
3495120,3499280," so yeah so for this kind of thing you're supposed to write an interrupt routine i suppose which calls"
3499280,3507040," the debugger or something uh right and um so when we are in the operating system i suppose gdb can"
3507040,3512560," actually handle that right so if you run in the gdb and you throw this sort of like interrupt gdb will"
3512560,3516320," stop at that specific place right so i'm going to use that as sort of like an indication that this"
3516320,3522720," thing is not implemented yet i love some embedded oh we have embedded developers in here mr tear would"
3522720,3531520," be proud i think i wrote an interrupt routine once when i was developing pin pogger uh so pin pogger so"
3531520,3536800," for those who doesn't know it's just a simple game uh that works without operating system all right and it"
3536800,3544000," fits into 512 uh bytes of the bootloader all right so and obviously when you are working on that level"
3544000,3548960," you kind of have to write interrupt routines right at least for the timer and also for handling input i"
3548960,3553920," don't remember i think in yeah i think input was also a specific interrupt but specifically for timer i"
3553920,3558880," actually had to to write some stuff in here so i'm going to put that in the description for anyone who's"
3558880,3566960," interested it was fun it was fun so i can proudly say that i did in fact wrote an interrupt routine so"
3566960,3573680," i don't really write them very often but like at one time i actually wrote it"
3573680,3581680," but i mean it's it's a it's literally a callback i'm not even joking it's literally a callback"
3582640,3589200," but on a very low level so isn't it embedded developers please confirm this is just a"
3589200,3595920," literally callback uh right you you put an address into that table and the cpu will just call that"
3595920,3604960," procedure there but when something happens callback literally callback um if you oh i also did that in"
3604960,3612400," unix stall uh no unix how would you sell it uxn right so this little thing uh so it's a small"
3612400,3617760," virtual machine uh very small virtual machine uh very small virtual machine and yeah it's based on"
3617760,3623440," interrupts right so it has a lot of events that may happen within the virtual machine the timers the"
3623440,3628240," inputs and stuff like that and all of that is interrupts you you really have to like create"
3628240,3633280," special interrupt routines and just like register them and whatnot uh so it's also pretty cool so i wrote"
3641280,3655760," okay okay so uh yes so i'm gonna put in three in here i want to kind of test if this thing is going"
3655760,3666080," to fail um so yeah if i try to run this thing right now it is going to uh fail with the sig trap thing yeah"
3666080,3670880," right so let's actually go ahead and try to do that so it's going to be sick trap uh std error no"
3670880,3677680," is not available okay so this is the um actually this is zero out"
3677680,3683760," i did i confuse stdin with std out again chat"
3686480,3694800," um i think i think i did yeah i think i think i did confuse them again but anyway as you can see"
3694800,3699920," it's like yeah so it's basically trap thingy so it will basically stop the debugger at that specific"
3699920,3706720," place but we don't run in the debugger so uh yeah it's fine uxn not banned in russia yeah"
3707520,3720320," so which is pretty cool i really appreciate that um so and now we can try to maybe set coroutines capacity"
3720320,3732880," to zero no coq routines are allowed coq blocked routines okay too many coroutines perfect and it"
3732880,3740560," actually exited with 69 so that specific assertion works correctly uh that specific assertion works"
3740560,3746640," correctly and if you have enough routines it actually allocates them and then goes into in three uh thingy in"
3746640,3751520," here okay we confirm that we confirm that that specific part of this thing uh it actually works"
3751520,3756240," i really like that so what's cool is that we don't even have to return from this routine all right"
3756240,3763120," because we call exit so it's just like we can fire and forget right just fire and forget okay cool"
3763120,3769840," so here is an interesting thing uh rsi is the address into which we have to jump"
3772320,3779360," so uh what we need to do we need to take the current index of the current routine so"
3779360,3788080," the context count contains basically right now the index of the newly allocated context"
3788080,3793200," right so we have to allocate the new context at that specific place so let me read the value stored in"
3793200,3800400," that address into some sort of a register like which one like maybe racks whatever right so let's put it"
3800400,3805120," into racks maybe rbx because racks is used for syscalls so i don't know maybe i'm going to actually"
3805120,3813520," clobber it uh do you guys know what is clobbering or whatever so it's just like when you like trash the"
3813520,3821840," the registers right so because registers are in a constant flow state right so anyway so the rbx stores the"
3821840,3828720," index of the context that that we care about uh right so and essentially what we can do"
3828720,3836800," uh the context starts the context start at that address right so this is the label that we have in"
3836800,3845360," here so they do start at that address but we only care about rsp part of that context thingy right rsp part"
3846160,3851520," um so we could have actually do we even need structures in here chat"
3851520,3858640," do we even need that like i mean i can just do something like"
3864480,3867920," i feel like i feel like we don't need structures like if we're going to be doing like a structure of"
3867920,3876400," arrays who said we can't do something like this and we can maybe prefix this like context rsps rdps and"
3878480,3889600," yeah fuck that soa ours you know structure of arrays array of structures so we're optimizing our"
3889600,3897200," our replication earlier right so data oriented stuff you know it's a data program"
3902320,3909680," um be careful about cache locality gatekeepers yeah i mean it's like we're we're just prototyping anyway"
3909680,3916320," so we're picking whatever solution is easier to implement so as of right now this is easier to"
3916320,3922320," implement so we're going to be going with that maybe i'm going to even take like remove uh this thing"
3922320,3927680," right so remove s i'm removing s so it makes it a little bit easier for me to read"
3928480,3937120," okay so here's the index and i want to save i want to assign the stack right i want to assign this stack"
3937120,3945840," in here uh what's funny is that the stack grows from positive values to negative"
3945840,3956000," so that means we have to allocate the stacks in here from right to left that makes sense i suppose i think"
3956000,3964240," that in fact makes sense uh right so essentially here we have like stack let's put it like this"
3964240,3968880," so it's going to be like this and we have a bunch of sort of reserved spaces for the stacks"
3968880,3975120," so if we allocate the new stack for the routine we have to say that the stack starts in here"
3975120,3981840," right so it starts in here and so as the routine goes and does things it's going to be allocating"
3982400,3988800," uh memory into here and if the stack overflows it will start overriding the stack of another coroutine"
3988800,3994320," we can try to prevent that by maybe putting some sort of stuff in here but i mean let's just like"
3994320,4000320," don't do stupid things right if you're afraid of doing stupid things go programming rust right so"
4000320,4004960," rust is the language for you here we live dangerously we're programming in low level assembly"
4006640,4010720," i mean the reason why i don't care right now is because this is a prototype right so obviously in"
4010720,4016160," the future it will be kind of nice to maybe put some sort of like a thing in here that triggers"
4016160,4020720," something when you actually try to read right there i don't really know how to do that but that would be"
4020720,4027120," nice uh right maybe separate it with pages like each individual stack imagine separated with pages"
4027120,4033120," with like zero permissions where you can't really read write or execute so every time this stack overflows"
4033680,4039440," yeah it goes into this area it actually set faults that would be nice right so don't really allow them"
4039440,4046400," to overwrite but again right now i don't want to over complicate it uh that would be nice put impenetrable"
4046400,4055040," wall yeah that would be nice so uh because of that like we have to allocate them from the end so because as"
4055040,4060960," we allocated this stack when we create a new core routine we have to allocate this stack in here so we"
4060960,4069360," have to jump through these stacks so because of that i feel like it's kind of difficult to use con"
4069360,4075840," like context count to keep track of all of that maybe we can have another variable which is something like"
4075840,4083280," stacks and uh right and so this is going to be a pointer and it's a pointer that is going to be pointing at"
4083280,4089520," the end of the stacks yeah we can do something like that but we need to initialize it with something"
4089520,4093360," um all right so we need to initialize with something i wonder if i can"
4093360,4105920," if i could do something like db i could have just said okay it's it has yeah that would be actually"
4105920,4115360," perfect if if i managed to do something like this look at that but then this all of that stuff is"
4115360,4121280," going to blow up the size of the executable right this is going to blow up the size of the executable"
4121280,4130240," so maybe i can maybe i can put something like this so this is the stacks but plus uh the size of the whole"
4130240,4136720," thing in here is that something we can do right so that will point at the end in here"
4136720,4144480," huh so let me try to compile this entire thing just to see if it's going to work so value out okay"
4144480,4151360," okay so you can't do that it's out of wrench like you you can't literally assign it like that"
4153200,4159840," damn broski damn okay so can i just do oh it's not yeah yeah"
4159840,4167680," ah it has to be dq maybe i still can do that yeah maybe i still can do that"
4167680,4176160," okay you know what i want to try in the main okay so this one is going to be in three and i'm going to"
4176160,4186480," load up interacts stacks and then into rbx stacks end but since it's a variable i have to read it"
4186480,4191440," so this is just a static address that points at the buffer that stores all of the stacks and stuff like"
4191440,4195760," that and this is the variable that is going to be changing right so and i just want to load them up"
4195760,4200080," into the registers and see that the difference between them is exactly the size that they expect right so"
4200080,4204960," just so just to see that it initialized everything correctly so if i try to build this entire thing"
4204960,4209600," the size of the executable didn't blow up we're still below one kilobyte it's not like it's goal"
4209600,4215760," or anything but i mean i don't want you don't want it to blow up too much so and then we can just do gf2"
4215760,4223760," right so let's go so here we are loading the address of the stacks right so it is in racks now"
4223760,4233920," sorry okay so in here it is so i wonder if i can co i can't even copy paste"
4234720,4242560," bro can i okay i can probably print this stuff in rex and then i can print rbx"
4242560,4265840," can i copy paste them now can you copy paste them now okay so and if we take a look at"
4265840,4278800," this kind of stuff so the size is 10 multiplied by this uh we can do 10 one kilobytes and four"
4278800,4283680," yeah it's initialized correctly"
4283680,4290560," uh g2sd thank you so much for for the raid thank you thank you thank you hello radios hello hello"
4290560,4295120," how was your stream so we're just programming in assembly uh we're not doing anything super"
4295840,4302480," cool and advanced or even useful i would say we're just exploring how to implement coroutines on a"
4302480,4308720," very low level uh all right so in assembly right so we're kind of like luring assembly so to speak"
4308720,4314560," we're kind of like learning assembly uh okay so this is actually very useful uh that's very cool i would"
4314560,4323760," even say okay so here is the index and essentially when i create a coroutine i suppose what i can do"
4323760,4331760," what i can do i can literally just set the rsp of that new routine to the stacks end i can just set it"
4331760,4338880," there like who said i can't do that like yeah so that's your new rs like rsp so i take the stack end"
4338880,4347920," that's your new rsp and then i subtract the stack capacity from stacks end so then on the next coroutine"
4347920,4357520," allocation i can again use stacks end of the rsp for the new coroutine um so be nice to use stdin to"
4357520,4364640," specify a coroutine number yeah so we're definitely going to be keeping track of the current coroutine"
4364640,4372960," and this is going to be a variable so yeah so as we switch between things we're going to be incrementing"
4372960,4378720," this variable and wrapping it around uh and who said this variable can't be used within the coroutine"
4378720,4383920," each coroutine can just look at this global variable and know what coroutine it is"
4383920,4392560," so and use that in the output just to see like uh what is going on in there so that sounds pretty cool i"
4392560,4397920," i think um that sounds pretty cool"
4397920,4415040," look at that beautiful alignment is not pop it looks pretty close um okay now um might as well by the way"
4416560,4424240," yo perfect so we still keep all the reserves in here all right so and kind of related variables are"
4424240,4431520," near to each other really like that so stack send is modified yeah stack send is modified so it's basically"
4431520,4437040," like an allocator so it points at the end of the stacks buffer we use it as the stack for the new"
4437040,4442400," coroutine and then we subtract it so then we can use the next chunk for the next coroutine then subtract"
4442400,4448720," again the next chunk so it's it's a simple allocator so it's a simple like slab allocator how is it called"
4448720,4454880," uh right so it's a but it allocates actually in the opposite direction usually slab goes from left to right"
4454880,4460640," but since it's a stack we're going from right to left because it makes sense for the stack"
4460640,4463040," uh so yeah it's kind of cool"
4464480,4468880," listen chat i just got the yeah it's a bump allocator yeah thank you thank you so much"
4468880,4477680," what what if coroutine go as it allocates the stack as the last element on the stack"
4477680,4482880," it pushes the address of some sort of a routine which deallocates the coroutine"
4482880,4490000," holy this is such a cool idea so yeah so this coroutine will eventually return"
4490880,4497200," and it may return into the address that we as we go allocating the coroutine put in there"
4497200,4504000," and that routine will deallocate everything that is so holy i really like that"
4504000,4511040," okay but let's not jump ahead of ourselves um so i'm already streaming for one hour i think"
4511040,4515360," the time has come to make a small break chat uh right so because i ran out of tea uh i want to"
4515360,4521440," refill my cup of tea and then we're going to continue so i think yeah things doable that's so cool"
4521440,4528480," right so it doesn't you don't even have to call explicitly anything uh to deallocate the routine"
4528480,4532960," right so we can just put the return address there it's like a defer yeah it's kind of similar to defer"
4533600,4543120," uh so the time has come the time has come all right so make some break and up all right let's continue"
4543120,4551280," so um yeah so we don't need this choice anymore it was just just a debug choice and we are implementing"
4551280,4560880," the cook routine all right so here is the stacks and and so on and so forth so i suppose uh we might"
4560880,4567280," as well just increment context count right so let's actually keep rbx as the index of already allocated"
4567280,4574880," context right so that's totally fine so after that i'm instantly incrementing it uh right so yeah so i'm"
4574880,4583680," just incrementing it as it is so then it can be reduced for the next uh coroutine goal so in here uh rbx is an"
4583680,4593360," index uh we need to find the location of the rsp because we want to set up the rsp thingy so um"
4593360,4603280," that means it starts somewhere here right so here is the rsp plus an index but it also has to be"
4603280,4609120," multiplied by the size of the element of this array the size of the element of this array is actually"
4609120,4615040," eight because it's a quad word 64 bits so that means it has to be multiplied by eight so this is the"
4615040,4622160," address into which we have to uh into which we have to save the stack ends right so essentially we have to"
4622160,4630960," move uh stacks stacks end into here right and i don't know if it's going to work i think"
4632080,4638400," um i think you can't move one memory into another memory like i don't quite remember uh at least in"
4638400,4647200," in x86 64 we can try to build the whole thing uh-huh come on you can do that yeah invalid upper end"
4647200,4656000," we can try to maybe we can try to maybe um um save that value into rex"
4659360,4669520," so yeah let me actually put some notes in here rbx contains the index of the current context right"
4669520,4679520," of the context we just allocated can i oh i can even wrap around thank you emacs ripple um so"
4681200,4690000," rex contains the rs p of the new um routine"
4690000,4702800," there we go so this is rex and i suppose it is going to work uh invalid opera i forgot to oh okay so"
4702800,4705600," do you tell me that i can actually move this kind of stuff in here"
4706400,4715280," uh-huh but can i say then q word can you specify yeah you have to first save that thing into a"
4715280,4721520," register and only then okay okay so that's understandable uh so this is rsp uh and we're"
4721520,4728240," doing this stuff like that what's interesting is that here is kind of a deceiving thing about intel"
4728240,4733760," style assembly it makes it feel like you can put arbitrary arithmetic expressions in here"
4734960,4741680," actually it's not true you can't put or betray you can't like put minus racks in here right you"
4741680,4747120," you literally can't do that it's it's an invalid address so you can only put uh"
4747120,4757200," basically you have very specific roles for each individual element in here so you have the base address"
4758000,4765200," then you have an index address and then you have like sort of like a scalar or multiplier so and this"
4765200,4771840," is you can only have these three things and that's it it's like a layer instruction yeah uh you can only"
4771840,4778960," have these three things uh and they are part of the format of binary format of the instructions the binary"
4778960,4784800," formative instruction literally has three places for this specific formula right so the thing that goes"
4784800,4791840," before plus or minus uh right so then the you know the index and the multiplier and yeah so"
4791840,4802080," i don't like at&t syntax but in that regard at&t syntax is at least more honest about what the"
4802080,4809520," is going on underneath you know what i'm talking about in at syntax you can't really do this kind of stuff right so"
4809520,4815760," it literally you have to put this thing in specific places right it actually reveals what's going on"
4815760,4823840," underneath the syntax right so we can even take a look at that at&t syntax but i personally like intel"
4823840,4834000," syntax more uh because i actually started uh programming on windows right so and i also started to learn"
4834000,4840480," assembly on windows and on windows everything is intel syntax at&t syntax is usually a posix things"
4840480,4848080," so i have like a more of a sentimental value towards intel syntax right so it's kind of weird even though"
4848080,4853200," there are some parts of at&t syntax that are just like objectively better like for example the syntax for"
4853200,4859600," for these kind of operations uh intel syntax are basically superior yeah i kind of like it right so it's i mean"
4859600,4866320," syntax by the creators of the processor itself right so um it kind of makes sense um"
4866320,4873680," versus intel so is there some sort of comparison uh"
4873680,4885040," intel or at&t limitations of the intel syntax i can't really find is there some some formula memory"
4885040,4889520," operand complex mnemonic suffixes data size declarations"
4889520,4901520," yeah yeah essentially all right so the syntax is the following instead of writing ebx plus three"
4901520,4910960," they would write three in parentheses abx and then the index and multiplier would go into"
4911920,4918560," they're separate places so instead of writing this they would write something like um so this is an"
4918560,4927840," offset i remember something like this probably um i don't remember even but yeah so they would put"
4927840,4933840," them these kind of things in like different places and whatnot right so is that what it is right i think i"
4933840,4940160," think that was this so somebody actually provided an example yeah thank you like i'm not particularly"
4940160,4948160," familiar uh with the with the syntax right so add this becomes yeah so you literally just specify them in"
4948160,4956320," their corresponding places so it doesn't it doesn't lie to you right so this one makes it feel like you can put"
4956320,4962880," whatever stuff in here in fact you cannot right so and here it just like you explicitly specify different"
4962880,4968720," roles for things right this explicit specify roles right thank you thank you so much um"
4968720,4979360," you have no idea what at&t syntax does though at least plus and uh well yeah true sometimes you look at"
4979360,4984480," AT&T you you kind of have to know that but here you look at it and you instantly see what it does even"
4984480,4991040," if you don't know that there is like different roles for different places in here right so yeah"
4991040,4994800," um it's basically like tabs versus spaces at this point"
4994800,4999840," okay so here we're saving rsp so what's going to be the initial rbp"
5001920,5009680," what's the initial rbp of the um of the main program right because rbp is usually set up"
5009680,5014640," by the procedure but we're only starting the procedure right so it's sort of like an entry point"
5014640,5022880," so let's actually stop in here uh and let me just try to do gf2 uh all right so i'm going to run it"
5022880,5029520," and what's this uh value of rbp initial value as we started the program oh it's actually zero"
5030880,5039200," okay so all right let's let's set it to zero then um so this one is going to be rbp and it's going to"
5039200,5049840," be zero uh so and next thing is we need to have instruction pointer rip so what's going to be a rip a"
5049840,5060240," rip has to be the rsi or is it rsi so what's the call convention uh the first thing is rdi actually this"
5060240,5066720," one is rdi and when i call to this one we already set it to rdi so the current execution point has"
5066720,5073600," to be the whatever we have in our di all right so we basically saved everything in here uh we basically"
5073600,5080640," saved everything but i suppose another thing we have to do in here is subtract stack end with the size of"
5080640,5088400," the stack right so we have to do something like sub uh all right stack stack capacity right so then it can be"
5088400,5095600," reused for the next thing imagine you so and after that i suppose we just return so essentially as you"
5095600,5104720," create a new coroutine it does not start the coroutine immediately it's going to wait for the next"
5104720,5114240," yield right it's going to wait for the next yield um yeah so it just registers that coroutine in the table of"
5114240,5119680," like in in the contexts right and doesn't execute it so it will only start executing on the next sort of"
5119680,5125440," yield when you actually switch to that coroutine um so let me actually try to run the whole thing"
5125440,5133520," right so here we just create two coroutines and what we expect in here is that this thing will just like"
5133520,5138640," exit successfully right so let's actually go ahead and try to run that uh all right so it doesn't like"
5138640,5145600," something about 79 uh actually have to subtract the value in here right so i'm subtracting it as keyword"
5145600,5154720," obviously yeah operand size not specified ah all right for the zero right so here it can infer uh this"
5154720,5159760," kind of stuff from the register but here it can't really do that so it's actually set zero okay so i"
5159760,5164720," didn't really want to run the debugger i just wanted to run this thing okay so it exited with success"
5164720,5171760," so let's maybe create an okay message of some sort so we can test things"
5171760,5180000," so this is going to be okay again um so this is right"
5182640,5194480," so let's write into std out something like oak oak mate oak mate so it has to be actually not"
5194480,5201040," capitalized uh let's not capitalize on that okay so it says oak so that means it successfully actually"
5201040,5209600," created two coroutines we might as well even print some of them so move rdi and let's move contexts"
5210320,5218560," count and let's just like call to print so it should print two okay so this is how many we created"
5218560,5229360," this is how many you create um okay and i just realized the main execution thread sort of speak"
5229360,5240240," has to be a coroutine as well but i mean it already has its own stack and everything it already has its own"
5240240,5250240," stack so we kind of need to either have a separate entry point which is started as a coroutine"
5250240,5258560," or we have to register the current execution as a coroutine you know what i'm talking about because"
5258560,5262800," we have already a thing that is executed with its own stack and stuff like that but it's not registered"
5262800,5270160," in the context and like that it doesn't have its rsp and rbp and rip stored and stuff like that like it was"
5270160,5275840," never properly created so it's never properly created so to speak so how could we do that we could have"
5275840,5287520," just like created like main right created a main and just maybe jump there sort of speak"
5287520,5296080," or maybe yeah so maybe we can have a separate procedure or something like a coroutine init"
5298080,5303440," and let's just take the current execution environment and say okay that's one of the coroutines"
5303440,5309360," right so that's that's one of these so the first thing that we're doing here that's that's the first"
5309360,5318080," coroutine so so we init and then we just do that um so i think that would be that would be fine"
5320400,5327200," so as soon as soon as you run this main itself becomes coroutine right so it becomes coroutine"
5327200,5331280," so how can we do that um"
5331280,5337360," obviously uh we need to allocate a new coroutine and the way we're allocating"
5337360,5346480," we need to check the capacity one more time right right because we're creating a new one"
5347440,5356880," um so what i'm thinking is that what if i just make this entire thing reusable because it fails"
5356880,5364800," anyway right so i can basically put it somewhere down there right it's assembly right so there's no"
5364800,5370320," uh like a fixed boundaries of the procedures procedures are just like a social construct"
5370320,5373840," they don't really exist in assembly there's only a sequence of instructions"
5373840,5375840," right so and"
5375840,5382160," yeah you know there's no procedures right so there's just labels and you jump to labels like procedures"
5382160,5384240," exist only in your head it's just a construction"
5384240,5389600," uh right so that means i can just put this thing in here and this kind of becomes a procedure but it's a"
5389600,5397840," procedure that never returns so that means yeah i just jump there it's sort of an assertion as soon"
5397840,5404800," as you jump there the program crashes anyway so it doesn't matter it's a good one right so it's like"
5404800,5411920," a sink point for for any of the failures or anything just like jump there and just die uh so overflow fail"
5411920,5422960," it's a good one i really like that um so yeah so here is an eight overflow fail and we now need to"
5422960,5427680," allocate a new context maybe it would be nice to maybe factor it out to a separate procedure but i'm"
5428480,5436240," not really sure um and here is the thing so the next step in allocating the routine is allocating"
5436240,5442000," the stack but we already have a stack we already have a stack so"
5442000,5449760," but the stack is rather interesting so this stack currently contains a return address right"
5449760,5456400," so again it grows into the left right it grows into the left and it contains the return address"
5457360,5470480," but we actually want to store this thing without the return address so we may either set the rsp"
5470480,5481520," to minus eight or something we can we can try to do that um so here we are saving all of that stuff so"
5481520,5491520," let me actually grab this thing so i'm grabbing this thing uh so here is the current uh stuff and i need"
5491520,5503600," to do rsp but that rsp has to be hmm i've got an idea what if i just pop the return address okay"
5505040,5515440," uh return address is in racks now we properly return address so rsp contains the stack as if this function"
5515440,5522480," was not called right so we popped the return address so that means now uh stack is exactly as this thing"
5522480,5528480," was not called and what's interesting is that so we can set that rsp in here uh rbp"
5530000,5534880," yeah we didn't modify rbp we can just set rbp as it was so which actually means that i didn't have to"
5534880,5542000," put this thing in here and the instruction pointer is the return address"
5542000,5550480," so you see when one of the routines will call yield that means when we switch the context to this thing"
5550480,5557520," it's going to continue execution from its own init so by using the return address as the"
5557520,5562720," instruction pointer for the current thing we're going to be continuing the execution from here"
5562720,5570960," so this is actually kind of cool but then we need to yeah then we need to return to that address"
5570960,5580960," somehow well i mean we can we can just jump there so return return is basically jump uh but from the"
5580960,5589440," stack so jump racks and push racks return are two equivalent instructions instruction sequences"
5589440,5600640," right so you see so jump jumps into the address in the operand returns jumps into the address on the stack"
5601280,5608080," and this is needed because coal puts the return address on the stack so but we already popped it so we"
5608080,5608800," can just jump there"
5608800,5619680," so that's pretty cool um all right all right all right"
5619680,5628080," did i miss anything i think that's it actually i think that's it i didn't see anything else"
5630000,5635600," um all right um all right let's try to maybe run that and see if it okay so it didn't crash at least"
5635600,5644000," right so we didn't try to uh read something unusual and uh so we should also at the end as we print"
5644000,5647680," we should do rdi"
5647680,5658160," contexts count right and just call print let's actually take a look at that all right so so this is how many"
5658160,5664080," contexts we have the main execution thread and two counters right and the main execution thread is going"
5664080,5670000," to be basically i suppose constantly yielding into the rest of the counters right it's going to be"
5670000,5674880," constantly yielding into the rest of the counters okay but to do all of that we need to implement the"
5674880,5678240," yield right how we're going to be doing the yield"
5680880,5704080," okay so when we're doing yield what we need to do essentially uh we have context current which i suppose"
5704080,5711920," initially is set to zero right it is set to zero we may maybe even do something like dq and explicitly"
5711920,5717280," set it to zero so we don't have to worry about this thing being initialized or not initialized so it"
5717280,5726480," doesn't matter um and essentially what we have to do we have to save the current execution in the current"
5726480,5733200," context and switch to the next one a sync await no not really a sync await uh it's a yield"
5733200,5741040," right it's not a sync await it's yield um but we can kind of emulate a sync awaiting here but all right"
5741040,5747120," actually we can put all of that stuff into different"
5747120,5755040," segments with different permissions if you think about that so all of that stuff for example these messages they"
5755040,5761200," will never get gonna be modified so we can actually put this into a segment that is readable but not"
5761200,5769520," writable this one can be readable writable right so and the segment with the code can be only executable"
5769520,5777680," segment executable so we can actually put that so as far as i know uh it will make the operating system"
5777680,5783520," like set up the permissions for the pages accordingly right so this stuff we can modify that this is just"
5783520,5789520," data it doesn't need to be writable and this is code that is also doesn't need to be writable"
5789520,5797280," so it's only executable does it make the application more safe do you think check did they just make it"
5797280,5804400," more safe did they just make rust irrelevant just with a few instructions in assembly rust is completely"
5806000,5809440," submissive and readable"
5809440,5812000," submissive and readable"
5812000,5817440," i wonder if it still works so let's try to compile"
5817440,5820880," oh it still works look at that so yeah"
5820880,5823600," absolutely"
5823600,5825440," absolute coding"
5826080,5832320," okay so how do we save the execution in here how do we save the execution we need to take the"
5832320,5840400," context's current so since we've been using rbx as an index a lot we might as well do the same thing in"
5840400,5848240," here so move rbx okay so we need to save the current execution so that means it's going to be kind of similar to this"
5849200,5855760," kind of similar to this so we save an rsp but rsp here is scuffed"
5855760,5859440," because it contains the return"
5859440,5866880," we literally have to do the same thing chat believe it or not we literally can do the same thing"
5868000,5874960," we pop out the return address fixing up this stack so now we can safely save the rsp"
5874960,5879760," also save the rbp and also racks becomes the new rp for the current context"
5879760,5885600," yeah that's actually perfect it's actually perfect so and now we can um"
5885600,5893760," basically go to the next counter so we can increment rbx but it this can overflow"
5894880,5900800," this modaflippa can overflow uh maybe we can use a little bit of a cmovgi"
5900800,5908080," it's like pepega but cmovgi so we can compare cmp rbx uh to"
5908080,5920320," core routines capacity and if this thing is greater or equal move rbx rbx zero"
5922000,5926400," right and we also have to update the current right so because it has to wrap around and"
5926400,5938320," shit uh yeah look at that so now rbx pointing at the next context and we have to restore that context"
5938320,5947520," actually um we have to restore that context so we have to do this operation but in reverse so we set in the"
5947520,5956800," rsp from the new context we're setting the rbp from the new context and we have to set the uh the"
5956800,5961920," instruction pointer but as far as i know you can't really set the instruction pointer but you know what is"
5961920,5964640," equivalent of setting the instruction pointer"
5967360,5975200," jumping there isn't it i think it is right so jumping is setting the instruction pointer"
5975200,5981920," you set in the instruction pointer uh so and you don't even have to return it to that so and we yield"
5981920,5990720," it we switch the context uh so yeah that's basically it so we switch the context so we save the context for"
5990720,5996560," for the for the current thing and now it is the new one so that's yield essentially"
5996560,6003040," right so this is safe it's surprising how easy it is to take a snapshot in here"
6003040,6006160," you just pop the return address and everything is the environment"
6006160,6009600," and it kind of makes sense honestly right so because you've made a call"
6009600,6012960," so you just need to undo the changes that were made"
6014000,6019920," by the call and there you go you have an environment without the call so you just save it as it is"
6019920,6024640," and on top of that you have a return address it yeah it's it's kind of beautiful in a way"
6024640,6028160," it's kind of it's kind of beautiful in its simplicity"
6037920,6042880," all right so let's see if this entire shot compiles uh let's go mine and find out"
6042880,6047520," ah"
6047520,6054320," how do you use"
6064800,6074640," where is the um there was a felix uh something something yeah felix clouter"
6074640,6081600," wait what register or memory"
6081600,6089600," i i can't put immediate values in there are you serious who designed this cpu"
6092960,6100960," c move can do intermediate okay okay now it can't it can't do that it's only memory it's all the"
6100960,6103120," freaking memory bro with the key"
6103120,6106000," bro with the key"
6106000,6110320," now it's like"
6114480,6120080," f**k you f**k you f**k you f**k you so"
6120080,6124080," ah s**t"
6124080,6135920," you think you can stop me you you think you can stop me f**k you can't stop me i'm unstoppable"
6140320,6141280," anyways so"
6141280,6146880," so yeah that's how you switch it's actually surprising"
6146880,6150560," is it gonna work"
6150560,6154640," i'm not sure if it's gonna work"
6154640,6158480," okay so uh um"
6158480,6162320," let's try to run it and see if it's going to"
6162320,6167280," okay so here is the well i mean we didn't do any yield right so"
6167280,6174960," okay so essentially uh coroutine go doesn't run the routine right away it just registered it"
6174960,6183120," registers this registers it in the context table to actually start executing it you need to yield"
6183120,6189360," in the current thread so it will switch to that and then that thing will switch as well so that means"
6189360,6197600," this counter itself yeah it has to call yield periodically in its loop right so it's printing and it's going to be yielding"
6197600,6201440," it's printing and yielding printing and yielding"
6201440,6203200," um so yeah"
6203200,6205760," so let's actually see"
6205760,6215040," okay so that means the main thread has to also constantly yield right so let's actually call yield only once"
6215520,6217920," right right let's call yield only once maybe we even"
6217920,6225040," yeah let's actually do that in here so i call core routine yield"
6225040,6232160," created two things yield and then i print the amount of context and then print okay and then exit with zero"
6235040,6242720," and then it's faulted which is quite surprising um huh"
6242720,6258640," jump into no no zone probably it for some reason it couldn't jump back so"
6261840,6264240," huh"
6264240,6266880," did i fuck up something in here"
6266880,6268880," so"
6268880,6272800," maybe it's something with the need"
6272800,6280080," all right because you see yield successfully switched uh to"
6280080,6284480," cmp context uh i don't think so"
6287120,6287360," um"
6287360,6291120," no"
6291120,6296880," ah to context oh i see okay i see"
6296880,6303360," all right context count you you're right i was about to go into like a long"
6303360,6306800," chain of thoughts but you you found yeah okay"
6306800,6313280," all right all right so here is the output of the first uh routine"
6314720,6318960," then the second one and then we printed how many routines we have in here"
6318960,6323200," so maybe it would make sense to actually print them after they're okay right so let's actually"
6323200,6328640," print them after they're okay uh where is the okay so let's put them in here"
6328640,6332240," let's put them in here yeah"
6332240,6337280," so both of the counter routines managed to"
6337280,6344000," execute one iteration but they didn't finish their iteration so we literally stopped their"
6344000,6350400," execution in the middle of them executing and never continued so if we do yield twice"
6350400,6352480," let's just call yield twice"
6352480,6354640," zero zero one one"
6354640,6357200," then yield another one"
6357200,6362320," and so on and so forth so we have to do that 10 times until one of them"
6362320,6370160," will uh finish execution so i suppose we don't have anything in the um in the stack for them to return"
6370160,6372480," so as soon as they will try to return they will"
6372480,6378960," probably jump to some garbage memory so some sort of a chaos will ensue as usual right one of the things"
6378960,6386080," we can do we can just do them uh forever right so we'll just call these things forever uh just to see"
6386080,6392640," what's going to happen yeah so forth right so that's that's understandable so we can introduce something"
6392640,6398640," like i don't know uh core routine finish and this thing is supposed to finish"
6398640,6405200," the current routine so for now let's actually put in three in here so do we call in three anywhere no we"
6405200,6411600," we don't so as we create a new core routine look at that"
6411600,6420560," so we allocated contains index of the racks contains the rsp of the new routine so this one is important in"
6420560,6432320," my opinion let's now subtract 64 bits from racks so racks contains the rsp of the new routine and"
6432320,6442720," let's move into that thing the address of the uh core routine um core routine finish"
6444240,6449520," so we're literally pushing the return address to the core routine finish onto the new stack of the core"
6449520,6454640," routine so if the core routine will return it will actually return into this function"
6454640,6463360," so and in here we can do something uh we can print some sort of a message right so let's actually um"
6465600,6474000," do something like do something like this core routine finish not implemented all right so and let's put"
6474000,6486000," this stuff in here uh core routine finish is not implemented 0 10 all right so and we can put this stuff in here"
6486000,6488320," uh boom"
6491600,6499280," is it going to is it going to okay so something something horrible has happened to know what wait what the"
6499280,6515040," fuck um that's that's bizarre so if i do uh go right so we just added this thing um subtracted racks and just move"
6521600,6530320," so that's kind of uh so that's kind of bizarre uh uh you're right i should have actually put brackets"
6530320,6534720," in here ah and it's keyword"
6534720,6546240," uh-huh that is very cool but then for routine finish"
6550320,6556000," uh-huh uh-huh uh-huh uh-huh uh-huh uh-huh"
6556000,6562560," exit it with 69 and it called coroutine finish"
6562560,6567920," so what we have to do now we have to deallocate this entire thing"
6567920,6574400," the question is how do we deallocate them right so allocating is super easy deallocating is kind of hard"
6577280,6585760," um so this is the moment where i feel like it would be kind of cool if i just had a higher level language"
6585760,6590800," right we're gonna cool if i just like yeah"
6590800,6600320," so i started with assembly because i didn't want to introduce too much noise by higher level languages"
6600320,6605440," right so because like like i don't know they will generate some stuff that modifies the stack and i"
6605440,6611600," don't really know what to expect from the stack but now assembly kind of stays in my way i want to go"
6611600,6618080," like a layer higher i want to keep all of these like context saving and stuff like that on the lower level"
6618080,6628720," but then go a level higher you know what i'm thinking can i like extract this entire thing into a separate"
6628720,6634800," library and link it with c and maybe call these kind of things from c that would have been interesting"
6635920,6638880," yeah i wonder how difficult would it be"
6638880,6651040," so let's give it a try um so let me let me see so i'm gonna create a make file uh right so this is a main"
6651040,6657120," uh so let's rename it to something um i don't know like a proof of concept or whatever"
6657680,6666320," you can see asm so fasm folk asm pog uh right so in here we're gonna have make what i want to do i"
6666320,6673040," want to have a copy of this thing so let's actually create core routine uh asm right and i want to remove"
6673040,6680480," everything that is related to the main executable right so i want to only leave the coroutine api"
6680480,6686800," right so then i can use it as a library uh from for example c or c3 i don't know so we don't need"
6686800,6691680," counter uh right can we implement all of that in a high level language so that's the real question"
6691680,6700960," so coroutine go coroutine init uh okay so the yield uh finish main we don't need the main anymore"
6700960,6709040," fuck all of that overflow we need to keep overflow it's going to be useful we're actually using it"
6709040,6716320," so all of that stuff um so too many coroutines that's understandable some sort of error"
6716800,6725520," this one is to do uh right do we need anything else no okay so and this is not executable so we"
6725520,6734080," need to create like an object file out of that so core routine all let's compile it like this so it's"
6734080,6742720," going to be fuzzum uh coroutine awesome uh let's make that and we have some sort of illegal ah yeah i don't"
6742720,6749120," remember that so if i remember correctly so if you're creating the object file you have to use"
6749120,6754720," sections now right so this is a section and it's a text section this is where you start the code"
6755440,6762560," uh this one uh maybe doesn't matter so let's get rid of the sections uh so i think you don't have to"
6762560,6767760," create them you can just like yeah there you go and created a pretty huge one honestly"
6772560,6781120," but anyway we can maybe do something like a section section bss i think"
6781120,6787520," yeah it actually reduced it this one is a section data"
6787520,6795760," yeah maybe having sections is fine in here so this is section data and where is the code is the section text"
6797920,6808080," yeah yeah yeah okay so can i just write like a c program that uses all of these procedures"
6808080,6816480," coroutine awesome cool routine so coroutine go so it definitely doesn't return anything but it accepts"
6816480,6821520," the pointer to the function and it's a pointer to the function that also doesn't take anything"
6822160,6828560," right so this is basically you know forward declaration of that function in here okay for"
6828560,6836720," routine underscore uh init this one doesn't return anything and doesn't accept anything that one is easy"
6836720,6842960," yield is kind of similar if you think about it it's kind of similar finish"
6842960,6848000," i think we should not call finish explicitly we haven't implemented it yet but"
6848000,6853440," yeah i think we should not call it explicitly so i think for the user library this is the api that"
6853440,6860240," they should call right so and now we should be able to create some something interesting with counter"
6860240,6863600," and finally we can implement counter in a proper language right so"
6863600,6871760," int 0 10 plus plus i so maybe here we can include stdio"
6872400,6883120," i o stdio print f uh d uh like this so this is the counter and here is the entry point"
6883120,6893120," and let's do coroutine init which makes the current execution threat uh you know coroutine"
6893120,6900880," then we have to do coroutine go and we just use counter let's create like two of them and indefinitely"
6901520,6911120," and definitely let's just yield coroutine yield like this and by the way we should also yield on each"
6911120,6916720," iteration of the counter too otherwise it's not going to work properly uh i guess that's it so now"
6916720,6924720," if i try to maybe build all of that stuff main main.c uh and just link them together though honestly if"
6924720,6931920," we are using like gcc and stuff coroutine o coroutine o coroutine o should have been implemented in gnu assembly"
6931920,6940400," honestly should have been implemented in the gnu assembly so so gcc o main main.c coroutine o"
6940400,6948080," uh all right so let's just try to do that it didn't like the fact that i didn't have a boolean in here"
6949120,6955200," all right oh"
6955200,6962000," oh something with the real oh shit okay can i how can i build fuzzum without relocation"
6962000,6966880," like or with relocation i don't know i doesn't have anything talk"
6966880,6974480," fuck yeah i should have been implemented that in gnu awesome but it uses a t and t syntax which i don't"
6974480,6982720," fucking know and it's just like ah uh what was that so is there anything can i"
6982720,6990560," can you just build f well i mean maybe we can try that um"
6990560,6993600," so f"
6997200,7002800," no it doesn't do shit i think it means that these things should have been compiled with fpie"
7002800,7007280," or maybe f no yeah so let's actually do that no peak"
7007280,7014720," raw data cannot be used when no it doesn't doesn't want that"
7014720,7020320," fuck i don't want to be rewriting that in gnu awesome"
7023040,7028080," um you have to use peak compatible code in the coroutine assembly relative addressing etc"
7028080,7034560," all right so let me see let me see let me see so how do we do relative addressing here"
7034560,7043360," okay so let's actually look at coroutine in how do i do relative addressing here"
7048160,7055920," so do i because this is a global variable rip based okay"
7055920,7063200," so"
7063200,7075120," how can i instruct move to do relative addressing if your reference labels without it will not be pic"
7076960,7079280," um"
7079280,7084000," need to use layer register address instead of move register address"
7084000,7090640," okay this one is interesting uh this one is interesting so just a second i need to copy paste"
7090640,7099920," this message that was suggested in the chat uh so thank you layer register instead of what was funny is that"
7100560,7102240," okay we need to do moves"
7102240,7112080," uh-huh so i suppose so do we use rbx okay so we already use rbx in here for stuff and everything"
7112080,7116560," we can try to rewrite that we can try to rewrite that but"
7117280,7128480," uh-huh first i want to i probably want to experiment with the main poc uh so i suppose"
7128480,7133520," yeah so all of the main offenders are in here"
7136160,7140400," maybe maybe maybe you can do it without that chat okay can i just maybe"
7140400,7149440," can i just compile it like this like c and just link it separately it also won't work"
7151840,7160000," okay okay so and then main main all because i remember i already kind of did this kind of stuff"
7160000,7165680," in one of my programming languages actually uh let me see just a second"
7171680,7183200," this one i apologize in advance so this was an april fool's joke but um so yeah this is a programming"
7183200,7188480," language that i'm not even joking the the entirety of the programming language is written like that"
7188480,7196000," even the source code so if you can read russian uh you would have a good love at it i guarantee you"
7198480,7204000," so i mean it's hard to believe but i can actually read the source code in here"
7204000,7210640," so here i'm generating phasm and i'm just like calling phasm and i remember like implementing so i"
7210640,7219280," could link with leapc i remember being able to link with leapc um so i would call to ld somewhere yeah here"
7219280,7227600," it is um oh i would actually i would actually specify the dynamic linker maybe this is one of the"
7227600,7236800," the things you have to specify so here yeah okay so we'll give it a try um where is my stuff in here"
7236800,7250640," so ld o main main o coroutine o uh all right okay okay so it just can't find all of these routines"
7250640,7255920," which is understandable okay okay okay so it means i need to make them public uh coroutine"
7256720,7266800," okay okay public coroutine go will you like it okay so that works so let's go somewhere here um so this"
7266800,7278880," one has to be public as well and yield now uh this is public as well uh in the function counter okay so"
7280160,7287120," oh print tab so we need to link with yeah if you're starting to use linker like that you have to link"
7287120,7294000," with the c runtime yourself can i just do something like this oh and it can yeah so as soon as you start"
7294000,7306880," using linker you are on your own and shit um okay i remember it was somewhere okay what was that type file name"
7307680,7318160," crt one or something um yeah this one right it's a crt one isn't it so it's a 30 one"
7323200,7328240," you work you work wait holy shit"
7328240,7335360," okay so"
7335360,7348560," uh it does not execute properly fuck you you can't run it ah i know that actually happens when you don't have a"
7348560,7355040," dynamic linker uh do i even have this thing yeah so if if it can't dynamically find dynamic linker it just"
7355040,7362880," like can't uh yeah i can't do things so this thing exists so we have to specify that then i'm going"
7362880,7367280," out like a really deep i should not be doing this kind of shit i definitely should not be doing this kind"
7367280,7375520," of shit but i i i went pretty deep rabbit hole so if i implemented it with gnu c i think it would have been way easier for me"
7375520,7382000," all right all right so i think the next version of this thing has to be implemented in in gnu c uh"
7382000,7383360," holy"
7383360,7393440," let's go let's go let's go look at that i have core routines in c"
7393440,7404400," implemented in assembly in a completely fucking different assembly not even a gnu assembly"
7404400,7407920," fuck gnu assembly fasm fasm is the way to go"
7411200,7419200," hell yeah hell yeah hell motherfucking yeah uh uh like how do i now use that in c3"
7419200,7428960," how do i use that in c3 that will be interesting actually um yeah so because in c3 i think you"
7428960,7436880," can't create a separate o file in c3 like this uh you can create a separate o file uh so that means we"
7436880,7443680," won't be able to like use this kind of linky trick yeah i don't don't need lib new but obviously like"
7443680,7450720," this one is not finished honestly um it basically assumes that the execution context is not going to"
7450720,7459760," optimize out any local variables into registers one of the things the um set jump does let's take a look at"
7459760,7468720," it chat let's take a look at it so third party musil uh third party musil and let's find this file with"
7468720,7483680," the name set gmp like so set gmp uh x 8664 uh right so it saves such registers as r12 r13 r14 and so"
7483680,7488560," so on and so forth i think this is the register that usually used for like local optimized variables"
7488560,7494400," um right instead of putting them on a stack it will put them on these things because they are not part"
7494400,7504480," of any abi right so they're like usually free to use um make all coroutines volatile maybe i also need to"
7504480,7509360," make them volatile yeah that's for sure yeah because this is something libmu would do as well"
7510240,7517040," right so i feel like on top of just saving rbp and rsp we have to do this kind of thing"
7517040,7524640," right so we're basically kind of extending the implementation of long jumps so it's long jumps"
7524640,7531200," but also with a clone of a stack yeah so it's like long jumps on steroids um"
7531200,7538880," that's pretty cool that's pretty cool so but we're obviously like running out of time already"
7538880,7543440," soon for two hours i don't know for how long i can go with this kind of stuff but that's a pretty"
7543440,7549600," good base right so this is like a proof of concept that this approach works uh honestly i don't really"
7549600,7555680," know how libmu implements that so this is basically my take on coroutines do we have anyone in the chat"
7555680,7562160," who knows how like libmu internally works i think it works kind of similar similarly right we looked into it"
7562160,7574000," very briefly uh but i think the only thing i saw in libmu is that it basically implements its own yeah it's"
7574000,7582640," only this thing which is basically a set jump yeah so it's their own set jump but i don't see allocation"
7582640,7586320," of the stack it doesn't really allocate its own stack so i don't really know what's up with that"
7587360,7594640," um right so it kind of does that but i don't see the stack situation right so here we do pretty cool"
7594640,7599520," shit where we allocate the stack though it does allocate some sort of like an anchor in here"
7599520,7606640," which i suspect could be sort of like the you know the space for the stack right so it allocates the new"
7606640,7613680," stack on the current stack or something like that so i don't know i don't know what exactly it does it"
7613680,7619040," looks super complicated our implementation is actually super simple uh maybe not super optimal"
7619040,7626000," but it's super simple nonetheless and i'm actually replied so yeah i think i'm gonna continue working"
7626000,7633680," on that and maybe use this kind of approach instead of futures in c3 because this is much easier to reason"
7633680,7642960," about right much easier to reason about and in the future we can even implement uh similar sleeping on events"
7642960,7650800," because in c3 feud we implemented a thing that okay so the current future uh don't want to execute"
7650800,7656240," anything until something is available on that socket we can implement something like this in here too"
7656240,7664320," like instead of field we can do coroutine sleep uh right so and provide the socket and say"
7664880,7675120," right so it basically yields and the context switcher will put that um put that coroutine into the bat into"
7675120,7680800," the hash table of things that are sleeping and then on the next iteration when something is available"
7680800,7686640," on the socket it will wake it up again and start running again so while the coroutine is sleeping it's"
7686640,7691520," not going to be switching into that right so we can implement a similar thing as we did in the futures"
7691520,7698640," library button here um so it's not like it's not that difficult right so it's it's surprisingly simple"
7698640,7704800," coroutines when you're thinking about them on a very low level on a fundamental level"
7704800,7711680," they are incredibly simple i think a lot of people are confused about coroutines and find them"
7711680,7716640," difficult because they are thinking about them on a higher level right from the point of view of a high"
7716640,7723200," level language as soon as you go into assembly and think about the stacks and saving the stacks and"
7723200,7732960," registers it just makes sense it just makes a lot of sense uh so yeah yeah i guess that's it for today"
7732960,7737840," i'm going to continue developing this thing and maybe eventually we can embed that into c3 and start"
7737840,7743520," using it with web assembly implementation and stuff like that so that was actually pretty cool exploration"
7744080,7750560," so uh let's take a look at the subs let's take a look at the subs uh thank you so much t martino"
7750560,7754400," uh for 100 beats i think i already read that the best way to predict the future is to create it"
7754400,7759280," thank you thank you thank you all right that's it for today thanks everyone who's watching right now"
7759280,7763840," i really appreciate that have a good one and i see you all on the next recreation programming session"
7763840,7769520," with a hu and mr azuzin i love you"
